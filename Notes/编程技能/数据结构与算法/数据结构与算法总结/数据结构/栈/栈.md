# 一. 简介

**栈**（Stack）也是线性表的一种，其主要特点是只能在线性表的一端进行插入或删除操作，其主要操作性能如下：

- 添加、删除元素：只能在线性表的一端进行，都是 $O(1)$
- 访问元素：可以访问任何元素，但在栈中一般不实现该功能，而只是访问栈顶的元素
- 查找元素：可以查找，但在栈中一般不实现该功能
- 遍历：可以像其他线性表一样遍历元素

> 相比于数组和链表来说，栈是舍弃了诸多功能的一个线性表，从而获取了极其快速的插入、删除速度以及对栈顶的访问速度。
>
> 从结果上来说，栈这种数据结构不适合解决那些对栈内元素操作较频繁的问题，但是对一些其他问题有着独特的贡献，如递归问题、四则运算表达式求值的问题



# 二. 关键概念

- **栈顶**：允许插入和删除的一端称为栈顶（top）
- **栈底**：与栈顶相对的另一端称为栈底（bottom）
- **空栈**：不含任何数据元素的栈称为空栈
- **LIFO结构**：即后进先出的一种结构（Last In First Out）
- **进栈、压栈、入栈**：即栈的插入操作
- **出栈、弹栈**：即栈的删除操作



# 三. 抽象数据类型

> - ADT 栈(Stack)
> - Data
>   - 同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系
> - Operation
>   - `InitStack(*S)`：初始化操作，建立一个空栈
>   - `DestroyStack(*S)`：若栈存在，则销毁它
>   - `ClearStack(*S)`：将栈清空
>   - `StackEmpty(S)`：若栈为空，返回`true`，否则返回`false`
>   - `GetTop(S, *e)`：若栈存在且非空，用`e`返回栈`S`的栈顶元素
>   - `Push(*S, e)`：若栈`S`存在，插入新元素`e`到`S`中并成为栈顶元素
>   - `Pop(*S, *e)`：删除栈`S`中栈顶元素，并用`e`返回其值
>   - `StackLength(S)`：返回栈`S`的元素个数
> - endADT



# 四. 主要应用

## 1. 递归

- 定义：一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称作递归函数。

- 条件：每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出。

- 实例：斐波那契数列

  - 引例：如果兔子在出生两个月后，就有繁殖能力，一对兔子每个月能生出一对小兔子来。假设所有兔子都不死，那么一年以后可以繁殖多少对兔子呢？

  - 分析：经过的月数和兔子的总数可以列出下表：

    | 经过的月数 | 兔子对数 |
    | ---------- | -------- |
    | 1          | 1        |
    | 2          | 1        |
    | 3          | 2        |
    | 4          | 3        |
    | 5          | 5        |
    | 6          | 8        |
    | 7          | 13       |
    | 8          | 21       |
    | 9          | 34       |
    | 10         | 55       |
    | 11         | 89       |
    | 12         | 144      |

  - 建模：根据上表我们可以写出以下数学模型
    
    $
    F(n)=\begin{cases}
    0,&n=0\\
    1,&n=1\\
    F(n-1)+F(n-2),&n>1
    \end{cases}
    $
    
  - 常规迭代方法
  
    ```c
    int main()
    {
        int i;
        int a[40];
        a[0] = 0;
        a[1] = 1;
        printf("%d ", a[0]);
        printf("%d ", a[1]);
        for(i = 2; i < 40; i++)
        {
            a[i] = a[i-1] + a[i-2];
            printf("%d ", a[i]);
        }
        return 0;
    }
    ```
  
  - 迭代方法
  
    ```c
    int Fbi(int i)
    {
        if(i < 2)
            return i == 0 ? 0 : 1;
        return Fbi(i-1)+Fbi(i-2);
    }
    
    int main()
    {
        int i;
        for(i = 0; i<40; i++)
            printf("%d ", Fbi(i));
        return n;
    }
    ```



## 2. 四则运算表达式求值

- 方法：四则运算表达式的求值方法主要有两步，首先将原四则运算表达式（也叫中缀表达式）转换成**后缀表示法**，然后将后缀表达式进行运算求值，这两步都会用到栈作为数据结构。该方法解决了四则运算表达式中括号以及运算符的优先级的问题。
- 后缀表达式转换规则：
  - 从左到右遍历中缀表达式的每个数字和符号
  - 若是数字就输出到后缀表达式中
  - 若是符号，则判断其与栈顶符号的优先级
    - 若是左括号，则进栈
    - 若是右括号，将栈顶元素依次出栈，直到遇到左括号（左括号需要出栈，两个括号不用写到后缀表达式中）
    - 若是优先级不高于栈顶符号的符号，则将栈顶符号出栈并输出，然后与下一个栈顶符号比较
    - 若是优先级高于栈顶符号，将该符号入栈
  - 当中缀表达式遍历完后，将栈顶元素依次出栈并输出
- 后缀表达式计算规则：
  - 从左到右遍历后缀表达式的每个数字和符号
  - 若是数字，则进栈
  - 若是符号，则将栈顶两个数字出栈进行运算，然后将运算结果进栈
    - 先出栈的数字作为运算符的右侧运算对象
    - 后出栈的数字作为运算符的左侧运算对象
  - 表达式遍历完成后，将最后的结果数字出栈