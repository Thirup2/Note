# 一. 简介

链表是使用指针实现的一种逻辑上连续但物理上内存地址不连续的表结构。当我们使用链表实现线性表时，最明显的一个不同应该是不能再以 $O(1)$ 的时间复杂度通过位序访问元素了。理论上它们在存储空间的灵活性以及插入删除操作的时间复杂度上有区别，但实际上顺序表的存储空间不灵活可以通过动态分配的方式解决，而链表的插入删除看上去很快，但它在插入删除前基本上都需要进行查找，又由于链表的按值查找和按位查找都变成了 $O(n)$，所以实际上链表的插入删除仍然是 $O(n)$。将链表的所有插入删除的时间复杂度优化为 $O(1)$ 也是可行的，但需要传入一个实际的结点指针来表示位置而不是用位序来表示位置。

链表下又细分为多种逻辑结构，分别是单链表、双链表、循环单链表和循环双链表。它们主要是根据可选择的遍历方式区分的。单链表只能从头结点开始往后遍历；双链表可以从头结点或尾结点开始遍历，即正向遍历和反向遍历；循环单链表可以从链表中任意结点开始单向遍历；循环双链表可以从链表中任意结点开始双向遍历。

另外，链表还有一种使用数组实现的方法，这种实现的链表称为静态链表。这种链表虽然充满了不必要性，但是在某些情况下它是很有用的，比如在没有类似于指针的类型的编程语言的链表实现中。由于没有指针或者说没有动态分配内存的操作，所以我们使用的数组也应该是静态数组，同时必须用数组模拟分配内存和释放内存的操作。



# 二. 实现

## 1. 单链表

```c
typedef struct node
{
    ElemType data;
    struct node *next;
} Node, *SinLList;
```



## 2. 双链表

```c
typedef struct node
{
    ElemType data;
    struct node *pre;
    struct node *next;
} Node, *DouLList;
```



## 3. 循环单链表

同 “单链表”



## 4. 循环双链表

同 “双链表”



# 三. 操作

## 1. 创建

在创建链表时，我们可以选择是否创建头结点或尾结点以及是否需要头指针/尾指针（实际上头指针和尾指针的选择应该在类型定义的时候进行），具体可以根据以下内容进行判断：

- **单链表**：

  1. 头指针：必须（作为链表入口）。同时可以使头插和删头操作为 $O(1)$
  2. 头结点：可选。将头插和删头操作一般化
  3. 尾指针：可选。可使尾插操作为 $O(1)$，但删尾操作仍为 $O(n)$
  4. 尾结点：禁用。会将尾部操作特殊化，且无任何正面效果

- **双链表**（在双链表中，头、尾二字可交换看待）：

  1. 头指针：必须（作为链表入口）。同时使头插和删头操作为 $O(1)$

     **注意**：如果你选择将尾指针作为链表入口，则实际上你选择的尾指针就成了头指针，所以在此处说头指针是必须的并无问题，你也可以说尾指针是必须的而头指针是非必须的，这样尾指针也就变成了头指针，头指针也就变成了尾指针。实际上，根据双链表能双向遍历的条件，我们应该一般头尾指针都要设置。

  2. 头结点：可选。将头插和删头操作一般化

  3. 尾指针：可选。使链表能反向遍历；同时使尾插和删尾操作为 $O(1)$

  4. 尾结点：可选。将尾插和删尾操作一般化

- **循环单链表**：

  1. 头指针/尾指针：必选其一（作为链表入口）。
     - 头指针：在有头结点或尾指针时，头插和删头操作为 $O(1)$，否则为 $O(n)$；尾插和删尾操作为 $O(n)$
     - 尾指针：头插和删头操作为 $O(1)$；尾插操作为 $O(1)$，删尾操作为 $O(n)$
  2. 头结点：可选。在通过头指针进行头插和删头时可将操作一般化。但同时会增加从链表任意结点开始遍历的难度。
  3. 尾结点：禁用。会将尾部操作特殊化，同时增加从链表任意结点开始遍历的难度，且无任何正面效果。

- **循环双链表**：

  1. 头指针/尾指针：必选其一（作为链表入口）
     - 头指针：头插和删头操作为 $O(1)$；尾插和删尾操作为 $O(1)$
     - 尾指针：头插和删头操作为 $O(1)$；尾插和删尾操作为 $O(1)$
  2. 头结点/尾结点：可选。可将头部操作或尾部操作的一般化。但同时会增加从链表任意结点开始遍历的难度。



## 2. 插入/删除

根据位序插入/删除的时间复杂度为 $O(n)$，主要消耗为查找该位序所在位置上。

所以根据结点指针插入/删除的时间复杂度为 $O(1)$



## 3. 查找

按值查找和按位查找都是 $O(n)$