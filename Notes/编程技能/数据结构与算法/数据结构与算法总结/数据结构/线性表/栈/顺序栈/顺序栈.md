# 一. 简介

和顺序表一样，顺序栈也是用连续内存空间实现的栈结构。使用 C 语言时通常采用数组实现，并且通常将第 1 个元素（下标为 0）作为栈底元素，而将当前表的最后一个元素（下标为表长-1）作为栈顶元素，所以我们需要一个标志来标识当前的栈顶。

至于数组大小不灵活的缺点，我们在顺序表的部分已经介绍过一种改进的方法，就是使用动态分配的内存并根据需要扩张和收缩。另外，对于一种特殊的情况是两个栈的其中一个在出栈时另一个栈总是在进栈，而当其进栈时另一个总是在出栈，这是我们可以将一个数组用来给这两个栈同时使用，称为共享栈。



# 二. 实现

## 1. 静态实现

```c
#define MaxSize 50
typedef struct
{
    ElemType data[MaxSize];
    int top;
} SqStack;
```



## 2. 动态实现

```c
#define InitSize 10
typedef struct
{
    ElemType *data;
    int capacity;
    int top;
} SqStack;
```



## 3. 共享栈

```c
#define MaxSize 50
typedef struct
{
    ElemType data[MaxSize];
    int top1;
    int top2;
} SharedStack;
```



# 三. 操作

栈的各种操作都是可以达到 $O(1)$ 的时间复杂度的，所以此节不具体解释说明各种操作的时间复杂度，而说明重要操作的一些关键点。

## 1. 创建

使用顺序存储创建栈时，我们需要注意的一点是初始状态下栈顶应该等于多少，是等于 0、-1。

当我们使用 -1 表示空栈时，已经表明了我们是用栈顶保存数组下标值，而不是栈中第几个元素，因为当我们往其中添加一个元素时，无论如何它最终应该等于 0。我们总不可能使用栈顶项来标志倒数第二个元素吧。当使用这种方式时，栈顶标志指向栈顶元素，当我们添加元素时，应该先增加栈顶计数，再往里添加元素；当栈顶项 +1 后等于`MaxSize`时，说明栈满。

当我们使用 0 表示空栈时，如果我们的入栈操作是先递增再插入，那此时栈顶项应该保存栈顶位序而非数组下标，而且栈顶项应该指向栈顶元素，在插入时我们就应该将该值进行转换，在这种情况下，当栈顶项的值为`MaxSize`时，说明栈满。而如果我们的入栈操作是先插入再递增，那么此时栈顶项应该保存栈顶的下标值，并且栈顶项应该指向栈顶元素的后一个位置，同样，当该值等于`MaxSize`时标志栈满。

我们最常使用的还是用 -1 标识空栈，因为栈顶项从逻辑上来说应该指向栈顶元素而非栈顶元素后空位的，并且对用户来说，接触到这个数据项的机会并不多，所以直接使用下标标识并没有问题。



## 2. 共享栈

为了操作的统一，我们通常用同一种方法标识共享栈中两个栈的空栈状态。

假设我们选择用 -1 标识第一个空栈，那么我们就应该用`MaxSize`标识第二个空栈。