# 一. 简介

**循环队列**是队列的一种顺序实现方法，之所以是循环队列而非顺序队列，是因为顺序队列几乎不可行。首先队列会在队头删除元素，在队尾插入元素，若以数组的头端为队头，那么前面删除之后剩下的空间将不再能得到利用，而如果以数组的尾端为队头，那么队尾就在数组的头端，那么插入元素时将会时常移动数组后面的元素，这在时间复杂性上又降低了。总的来说，循环队列的主要特点如下：

- 常用定容数组实现，即大小固定且无法改变
- 与顺序栈相同，继承了定容数组的部分缺点如可能导致空间浪费或数据溢出，同时隐藏了定容数组的一些优点



# 二. 代码实现

## 1. 概念实现

- 完全存满数组

  该情况可以有多种方法实现：

  - 第一种方法是特殊处理第一个元素，插入之后不移动队尾，当队尾的下一个位置为队头时，即判断队满。在这种方法下，如果插入元素是第二个及之后的元素，那么应该判断当前队列是空队列还是有一个元素的队列。实际上该方法并不实用。
  - 第二种方法是每插入一个元素都移动队尾指针，那么到队满的时候很显然队头和队尾应该指向同一个位置，此时判断队是空或满的方法是设置一个标志变量，当两个指针相遇时，就判断标志变量的值。标志变量可以按下面的方法设置：初始值为 0，即队空为 0，若插入元素导致指针相遇则将标志变量设为非 0，若删除元素导致指针相遇则将标志变量设为 0

- 保留一个空位

  该方法即将队空和队满的状态区分开，当队空时两指针相同，当队满时队尾位置的下一个位置应该和队头相同

- 插入位置的计算

  由于是循环队列，所以当数组的最后一个元素存满之后，此时如果数组前端有空位，那么下一个位置应该是从数组的第一个位置开始，此时就不能是单纯的将插入位置加一了，而是按照下面的公式计算：
  $$
  InsPos=(NowPos+1)\ \%\ MaxSize;
  $$



## 2. 代码

- 数据元素类型

  ```c
  typedef struct items ElemType;		// 基础数据元素类型，struct items自行定义
  typedef ElemType *PtrElem;		// 一般数据元素指针
  typedef const ElemType *cPtrElem;		// 指向常量的数据元素指针
  ```
  
- 循环队列类型

  ```c
  struct queue
  {
      PtrElem data;
      size_t head;
      size_t last;
      size_t size;
  };
  typedef struct queue Queue;
  typedef Queue *PtrQueue;
  typedef const Queue *cPtrQueue;
  ```



# 三. 难点操作

- 队列长度

  ```c
  size_t QueueLength(cPtrQueue queue)
  {
      return (queue->last + queue->size - queue->head) % queue->size;
  }
  ```

- 入队列

  ```c
  Status EnQueue(PtrQueue queue, cPtrElem elem)
  {
      if ((queue->last + 1) % queue->size == queue->head) {
          return ISFULL;
      }
      AssignElem(&queue->data[queue->last], elem);
      queue->last = (queue->last + 1) % queue->size;
      return SUCCESS;
  }
  ```

- 出队列

  ```c
  Status DeQueue(PtrQueue queue, PtrElem elem)
  {
      if (QueueEmpty(queue)) {
          return ISEMPTY;
      }
      AssignElem(elem, &queue->data[queue->head]);
      queue->head = (queue->head + 1) % queue->size;
      return SUCCESS;
  }
  ```

- 遍历

  ```c
  void PrintQueue(cPtrQueue queue)
  {
      size_t i = queue->head;
      while (i != queue->last) {
          PrintElem(&queue->data[i]);
          i = (i + 1) % queue->size;
      }
      printf("\n");
  }
  ```

