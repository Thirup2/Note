# 一. 简介

**顺序栈**是栈的一种实现方法，其主要特点如下：

- 通常用定容数组实现，即长度固定且无法改变
- 继承了定容数组的一些缺点：如无法灵活改变大小，可能造成空间的浪费或数据的溢出。且由于栈的特殊性，定容数组的一些优点并不能体现出来



# 二. 代码实现

## 1. 概念实现

当以定容数组为栈的实现方法的时候，我们需要明确下面的一些概念应该如何实现：

- **栈底**：以数组的哪一端为栈底呢？很明显，应该是下标为 0 的那一端，因为如果以 0 为栈顶，每次插入删除都需要移动后面的元素
- **栈顶**：我们需要一个`top`来指向栈顶，那这个栈顶应该是最后一个元素的位置还是最后一个元素的下一个位置呢？在栈这种结构中，这并不是一个问题，指向最后一个元素的位置我们很明显还可以多存一个元素。但是在顺序队列中需要注意这一点
- **空栈**、**栈满**、**栈长**：直接查看`top`即可



## 2. 代码

- 数据元素类型

  ```c
  typedef struct items ElemType;		// 基础数据元素类型，struct items自行定义
  typedef ElemType *PtrElem;		// 一般数据元素指针
  typedef const ElemType *cPtrElem;		// 指向常量的数据元素指针
  ```

- 顺序栈类型

  ```c
  struct stack
  {
      PtrElem data;
      size_t top;
      size_t size;
  };
  typedef struct stack Stack;
  typedef Stack *PtrStack;
  typedef const Stack *cPtrStack;
  ```



# 三. 难点操作

- 压栈

  ```c
  Status Push(PtrStack stack, cPtrElem elem)
  {
      if (StackLenth(stack) == stack->size) {
          return ISFULL;
      }
      AssignElem(&stack->data[stack->top++], elem);
      return SUCCESS;
  }
  ```

- 弹栈

  ```c
  Status Pop(PtrStack stack, PtrElem elem)
  {
      if (StackEmpty(stack)) {
          return ISEMPTY;
      }
      AssignElem(elem, &stack->data[--stack->top]);
      return SUCCESS;
  }
  ```

