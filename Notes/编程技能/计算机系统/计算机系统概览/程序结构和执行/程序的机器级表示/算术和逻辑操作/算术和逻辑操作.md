# 一. 简介

下表列出了x86-64 的一些整数和逻辑操作：

| 指令                                                         | 效果                                                         | 描述                                                      |
| ------------------------------------------------------------ | ------------------------------------------------------------ | --------------------------------------------------------- |
| `leaq S, D`                                                  | $D\longleftarrow \&S$                                        | 加载有效地址                                              |
| `INC D`<br/>`DEC D`<br/>`NEG D`<br/>`NOT D`                  | $D\longleftarrow D+1$<br />$D\longleftarrow D-1$<br />$D\longleftarrow -D$<br />$D\longleftarrow \sim D$ | 加1<br />减1<br />取负<br />取补                          |
| `ADD S, D`<br/>`SUB S, D`<br/>`IMUL S, D`<br/>`XOR S, D`<br/>`OR S, D`<br/>`AND S, D` | $D\longleftarrow D+S$<br />$D\longleftarrow D-S$<br />$D\longleftarrow D*S$<br />$D\longleftarrow D$ ^ $S$<br />$D\longleftarrow D\ \|\ S$<br />$D\longleftarrow D\ \&\ S$ | 加<br />减<br />乘<br />异或<br />或<br />与              |
| `SAL k, D`<br />`SHL k, D`<br />`SAR k, D`<br />`SHR k, D`   | $D\longleftarrow D<<k$<br />$D\longleftarrow D<<k$<br />$D\longleftarrow D>>_A k$<br />$D\longleftarrow D>>_L k$ | 左移<br />左移（等同于`SAL`）<br />算术右移<br />逻辑右移 |

> - 对于大写的操作表示指令类，这些指令类有各种带不同大小操作数的变种；小写的操作表示具体的某个指令
> - 对于上表中的每一个操作来说，都是在$D$的基础上执行了一些操作，并将值放在$D$中，并没有用第二个寄存器来存储结果



# 二. 加载有效地址

加载有效地址的指令为：`leaq`。其两个操作数，左边的是一个按照内存引用格式写出的操作数，右边操作数是一个寄存器或一个地址引用。

其执行的操作是将左操作数的计算结果赋给右操作数，所以通过这一个指令，我们可以将一些简单的加法和乘法运算放在一个指令中。

需要注意的是，左操作数虽然是一个内存引用格式，但是其并未执行内存引用操作，整个过程是先展开地址运算式，然后将寄存器中的值放到这个运算式中进行计算，然后将计算所得的结果放入右操作数中；而对于`movq`操作来说，如果有内存引用格式的操作数，那么其执行的操作是，先按照与上述相同的方式计算地址运算式的值，**然后根据计算所得的值，将其作为地址对内存进行访问**，然后将访问得到的值赋给右操作数。所以二者的区别就在于`movq`指令多出了加粗的那一部分。

例：

对于一个C代码：

```c
long scale(long x, long y, long z)
{
    long t = x + 4 * y + 12 * z;
    return t;
}
```

将转换为下面的汇编代码：

```assembly
scale:
	leaq (%rdi, %rsi, 4), %rax		; 将 x + 4 * y 存入 %rax 寄存器
	leaq (%rdx, %rdx, 2), %rdx		; 地址计算结果为：z + 2 * z = 3 * z, 然后将 3 * z 存入到 %rdx 寄存器
	leaq (%rax, %rdx, 4), %rax		; 地址计算结果为：(x + 4 * y) + 4 * (3 * z) = x + 4 * y + 12 * z, 然后将结果存入到 %rax 寄存器
	ret
```



# 三. 一元和二元操作

对于一元操作来说，包括`INC`、`DEC`、`NEG`、`NOT`这四类操作，它们只有一个操作数，既是源也是目的。这个操作数可以是一个寄存器，也可以是一个内存位置。

对于二元操作来说，包括`ADD`、`SUB`、`IMUL`、`XOR`、`OR`、`AND`这几类操作，第二个操作数既是源也是目的，前三个是算术运算，后面三个是逻辑运算。



# 四. 移位操作

最后一组是移位操作，包括`SAL`、`SHL`、`SAR`、`SHL`这四类操作，它们有两个操作数，第一个操作数是位移量，第二个操作数是要移位的数。这四类操作又可分为两类操作，一是算术移位：`SAL`和`SAR`，二是逻辑移位：`SHL`和`SHR`。只不过因为对于左移操作来说，其算术左移和逻辑左移效果相同，所以二者任选一个即可。

**注意**：

- 对于左操作数来说，只能是一个立即数或者放在单字节寄存器`%cl`中

- x86-64 中，移位操作对 $\omega$ 位长的数据值进行操作，移位量由`%cl`的低`m`位决定，其中 $2^m=\omega$ 。

  如当寄存器`%cl`的十六进制值为`0xFF`时，指令`salb`会移 7 位，`salw`会移 15 位，`sall`会移 31 位，而`salq`会移 63 位



# 五. 特殊的算术操作

在算术操作中，有一些操作比较特殊，如乘法，当两个 64 位的数相乘需要 128 位才能完整的表示所有乘法结果，所以 x86-64 对 128 位数的操作提供有限的支持，被称为**八字**（oct word），下表列出了与 128 位相关的指令：

| 指令                    | 效果                                                         | 描述                           |
| ----------------------- | ------------------------------------------------------------ | ------------------------------ |
| `imulq S`<br />`mulq S` | $R[$`%rdx`$]: R[$`%rax`$]\longleftarrow S\times R[$`%rax`$]$<br />$R[$`%rdx`$]: R[$`%rax`$]\longleftarrow S\times R[$`%rax`$]$ | 有符号全乘法<br />无符号全乘法 |
| `cqto`                  | $R[$`%rdx`$]: R[$`%rax`$]\longleftarrow$ 符号扩展$(R[$`%rax`$])$ | 转换为八字                     |
| `idivq S`               | $R[$`%rdx`$]\longleftarrow R[$`%rdx`$]: R[$`%rax`$]\ mod\ S$<br />$R[$`%rax`$]\longleftarrow R[$`%rdx`$]: R[$`%rax`$]\div S$ | 有符号除法                     |
| `divq S`                | $R[$`%rdx`$]\longleftarrow R[$`%rdx`$]: R[$`%rax`$]\ mod\ S$<br />$R[$`%rax`$]\longleftarrow R[$`%rdx`$]: R[$`%rax`$]\div S$ | 无符号除法                     |

## 1. 乘法

在普通的乘法指令中，也存在`imulq`指令，但那个是双操作数指令，对于`IMUL`类的乘法来说，乘积最终会截断为指令指定的位数。

而单操作数的`imulq`指令和`mulq`指令，乘积不会被截断，但需要满足一些条件：

- 其中一个操作数应该保存在寄存器`%rax`中
- 另一个操作数作为指令的源操作数给出

其执行的操作是：

- 首先计算出结果
- 然后将结果中高 64 位存放在寄存器`%rdx`中
- 将结果中低 64 位存放在寄存器`%rax`



## 2. 除法

128位的除法与128位乘法相对应，因为有了128位的乘法结果，所以128位的被除数也是有可能产生的。

`idivq`和`divq`就是除法指令，同样使用它之前需要满足一些条件：

- 被除数被保存在`%rdx`（高64位）和`%rax`（低64位）中，若被除数低于64位，则其应该全部被保存在`%rax`中，`%rdx`中的位应全部设置为 0（无符号运算）或`%rax`的符号位（有符号运算）。后面的符号扩展操作可以通过`cqto`指令来完成，它读出`%rax`的符号为，并将它复制到`%rdx`的所有位
- 除数作为指令的源操作数给出

其执行的操作是：

- 首先按整数除法计算出结果
- 将商存储在寄存器`%rax`中
- 将余数存储在寄存器`%rdx`中