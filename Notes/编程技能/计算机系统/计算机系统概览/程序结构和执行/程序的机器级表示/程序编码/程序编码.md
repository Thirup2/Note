# 一. 简介

本节主要介绍在汇编语言中，一些特殊符号的含义以及一些基本的语法。最后会对一个实例进行分析。



# 二. 基础

## 1. 操作硬件

- **程序计数器**

  程序计数器（通常称为“PC”，在 x86-64 中用`%rip`表示）给出将要执行的下一条指令在内存中的地址

- **整数寄存器文件**

  整数寄存器文件包含 16 个命名的位置，分别存储 64 位的值。这些寄存器可以存储地址（对应于C语言的指针）或整数数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。

- **条件码寄存器**

  条件码寄存器保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化，比如说用来实现`if`和`while`语句。

- **向量寄存器**

  一组向量寄存器可以存放一个或多个整数或浮点数值

## 2. 汇编基础

在C语言中，可以声明各种各样的类型，但是在汇编语言中，就只有一种类型，那就是字节，以下是汇编语言的一些特点：

- C语言中的数组或结构等聚合类型在汇编语言中用一组连续的字节来表示
- 对于标量数据类型，汇编代码不区分有符号或无符号整数
- 汇编代码不区分各种类型的指针
- 汇编代码不区分指针和整数

另外，汇编语言也经常访问内存，对于一个程序来说，其可访问的内存有以下四个部分：

- 程序的可执行代码：程序一条一条的指令
- 操作系统需要的一些信息
- 用来管理过程调用和返回的运行时栈：主要是函数使用
- 用户分配的内存块：如用`malloc`库函数分配的内存

对于我们在程序中所使用的地址是操作系统在内存上抽象出来的虚拟内存，在编译程序时，操作系统负责将虚拟地址翻译成实际处理器内存中的物理地址。

另外，对于汇编指令来说，一条机器指令只执行一个非常基本的操作，如将存放在寄存器中的两个数字相加；在存储器和寄存器之间传送数据；或是条件分支转移到新的指令地址。



# 三. 示例

## 1. C源代码

```c
long mult2(long, long);
void multstore(long x, long y, long *dest)
{
    long t = mult2(x, y);
    *dest = t;
}
```



## 2. 汇编代码

### 1）命令

```bash
gcc -Og -S mstore.c
```

### 2）结果

```assembly
multstore:
	pushq %rbx
	movq %rdx, %rbx
	call mult2
	movq %rax, (%rbx)
	popq %rbx
	ret
```



## 3. 目标代码

### 1）命令

```bash
gcc -Og -c mstore.c
```

### 2）结果

一个二进制文件，名称为`mstore.o`



## 4. 反汇编

主要是对目标文件进行反汇编，从机器级的二进制指令转换为汇编代码。

### 1）命令

```bash
objdump -d mstore.o
```

### 2）结果

```
0000000000000000 <multstore>:
0: 53							push	%rbx
1: 48 89 d3						mov	%rdx,%rbx
4: e8 00 00 00 00					callq	9 <multstore+0x9>
9: 48 89 03						mov	%rax,(%rbx)
c: 5b							pop	%rbx
d: c3							retq
```

### 3）特点

以下是关于机器代码和它的反汇编表示的一些特性：

- x86-64 的指令长度从 1 到 15 个字节不等。常用的指令以及操作数较少的指令所需的字节数较少，而那些不太常用或操作数较多的指令所需字节数较多
- 设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码成机器指令。例如，只有指令`pushq %rbx`是以字节值 53 开头的
- 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码。它不需要访问该程序的源代码或汇编代码
- 反汇编其使用的指令命名规则与GCC生成的汇编代码使用的有些细微的差别。