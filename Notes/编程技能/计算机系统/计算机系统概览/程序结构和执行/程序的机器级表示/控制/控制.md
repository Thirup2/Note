# 一. 条件码

## 1. 简介

**条件码**（condition code）寄存器是另外一种寄存器，它只有**一个位**，用来标示最近一次算术或逻辑操作的属性：

- `CF`：进位标志。最近的操作使最高位产生了进位，可用来检查无符号操作的溢出。
- `ZF`：零标志。最近的操作得出的结果是 0
- `SF`：符号标志。最近的操作得到的结果为负数
- `OF`：溢出标志。最近的操作导致了一个补码溢出——正溢出或负溢出



## 2. 设置条件码

在所有的指令中，只有`leaq`不会改变任何条件码，它只用来进行地址计算。除此之外，所有的指令都是有可能改变条件码的值的，其中又分为两类，一类是正常的操作指令，这类指令在完成操作的时候，操作数涉及的寄存器或指令涉及的寄存器的值会发生改变，同时条件码可能会被改变，如`ADD`、`SUB`指令；另一类是只改变条件码的值，但是不会改变操作涉及的寄存器的值，如：

| 指令                                       | 基于      | 描述                                             |
| ------------------------------------------ | --------- | ------------------------------------------------ |
| $CMP\ \ \ S_1,\ S_2$                       | $S_2-S_1$ | 比较                                             |
| `cmpb`<br />`cmpw`<br />`cmpl`<br />`cmpq` |           | 比较字节<br />比较字<br />比较双字<br />比较四字 |

> 该指令的操作是执行 $S_2-S_1$ 但是并不改变 $S_2$ 的值，该指令将根据两个操作数之差来设置条件码。如果两个操作数相等，那么零标志会设置为 1

| 指令                                           | 基于       | 描述                                             |
| ---------------------------------------------- | ---------- | ------------------------------------------------ |
| $TEST\ \ \ S_1,\ S_2$                          | $S_1\&S_2$ | 测试                                             |
| `testb`<br />`testw`<br />`testl`<br />`testq` |            | 测试字节<br />测试字<br />测试双字<br />测试四字 |

> 该指令的操作是执行两个操作数按位求与，但是并不改变 $S_2$ 的值。典型的用法是，两个操作数是一样的，用来检测操作数是正数、负数还是零；或其中的一个操作数是一个掩码，用来指示哪些位应该被测试。



## 3. 访问条件码

条件码通常不会直接读取，常用的使用方法有三种：

1. 根据需要的条件，对条件码进行某种位组合，然后将该组合计算所得的值赋给某个字节，来检查该条件是否成立。该方法通过 `SET` 指令进行。
2. 可以条件跳转到程序的某个其他的部分
3. 可以有条件的传送数据

此处先详细介绍 `SET` 指令：

| 指令      | 同义名     | 效果                                           | 设置条件               |
| --------- | ---------- | ---------------------------------------------- | ---------------------- |
| `sete D`  | `setz D`   | $D\longleftarrow ZF$                           | 相等/零                |
| `setne D` | `setnz D`  | $D\longleftarrow \sim ZF$                      | 不等/非零              |
| `sets D`  |            | $D\longleftarrow SF$                           | 负数                   |
| `setns D` |            | $D\longleftarrow \sim SF$                      | 非负数                 |
| `setg D`  | `setnle D` | $D\longleftarrow \sim(SF$ ^ $OF)\ \&\ \sim ZF$ | 大于（有符号>）        |
| `setge D` | `setnl D`  | $D\longleftarrow \sim(SF$ ^ $OF)$              | 大于等于（有符号>=）   |
| `setl D`  | `setnge D` | $D\longleftarrow SF$ ^ $OF$                    | 小于（有符号<）        |
| `setle D` | `setng D`  | $D\longleftarrow (SF$ ^ $OF)$ &#124; $ZF$      | 小于等于（有符号<=）   |
| `seta D`  | `setnbe D` | $D\longleftarrow \sim CF\ \&\ \sim ZF$         | 超过（无符号>）        |
| `setae D` | `setnb D`  | $D\longleftarrow \sim CF$                      | 超过或相等（无符号>=） |
| `setb D`  | `setnae D` | $D\longleftarrow CF$                           | 低于（无符号<）        |
| `setbe D` | `setna D`  | $D\longleftarrow CF$ &#124; $ZF$               | 低于或相等（无符号<=） |

> - 每一条指令中所用到的条件码都是上一个指令之后设置完成的，所以进行条件判断跳转，格式为先写出要判断的条件的指令，然后通过`SET`指令获取条件成立与否的值，然后将值写入`D`中。通常在`SET`指令前的应该是`CMP`指令，即比较两个数的大小，需要注意的是，`CMP`指令的操作数的顺序和最终比较的顺序是相反的，即如果在小于比较之前执行：`cmpq %rsi, %rdi`，那么实际上后续比较的是：`%rdi < %rsi `是否成立。
> - 某些机器指令可能有多个名字，这是因为其表意可以有多个，如大于等于也可以说成不小于



# 二. 跳转

## 1. 指令

跳转操作通过`JUMP`指令来进行，它也可以比较数的大小关系和正负零值，但与`SET`指令不同的是，在结果为 1 的时候，会跳转到`JUMP`指令操作数所指的标签处。具体的`JUMP`指令如下表所示：

| 指令           | 同义名       | 跳转条件                       | 描述                   |
| -------------- | ------------ | ------------------------------ | ---------------------- |
| `jmp Label`    |              | 1                              | 直接跳转               |
| `jmp *Operand` |              | 1                              | 间接跳转               |
| `je Label`     | `jz Label`   | $ZF$                           | 相等/零                |
| `jne Label`    | `jnz Label`  | $\sim ZF$                      | 不相等/非零            |
| `js Label`     |              | $SF$                           | 负数                   |
| `jns Label`    |              | $\sim SF$                      | 非负数                 |
| `jg Label`     | `jnle Label` | $\sim(SF$ ^ $OF)\ \&\ \sim ZF$ | 大于（有符号>）        |
| `jge Label`    | `jnl Label`  | $\sim(SF$ ^ $OF)$              | 大于或等于（有符号>=） |
| `jl Label`     | `jnge Label` | $SF$ ^ $OF$                    | 小于（有符号<）        |
| `jle Label`    | `jng Label`  | $(SF$ ^ $OF)$ &#124; $ZF$      | 小于或等于（有符号<=） |
| `ja Label`     | `jnbe Label` | $\sim CF\ \&\ \sim ZF$         | 超过（无符号>）        |
| `jae Label`    | `jnb Label`  | $\sim CF$                      | 超过或相等（无符号>=） |
| `jb Label`     | `jnae Label` | $CF$                           | 低于（无符号<）        |
| `jbe Label`    | `jna Label`  | $CF$ &#124; $ZF$               | 低于或相等（无符号<=） |

> 直接跳转和间接跳转都是不需要条件成立，或者说其跳转条件永远都成立，间接跳转的目标位置应该是通过寄存器或内存位置中读出的，其操作数写法是`*`后面跟一个操作数指示符，如`jmp *%rax`



## 2. 标签

用于标示程序中某处开始的代码位置，其语法如下：

```assembly
.Label：
	...
```

