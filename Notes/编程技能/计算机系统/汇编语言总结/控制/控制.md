# 一. 简介

在 x86-64 中，控制语句通过条件码和一系列相关指令实现。

首先条件码是客观存在的，一共四个条件码保存在条件码寄存器中，每种条件码只有是或否两种状态。而进行算术、逻辑以及移位操作（`leaq`操作除外）都会导致条件码发生改变，以及专用于设置条件码的 $CMP$ 和 $TEST$ 指令也会改变条件码。对于逻辑操作，进位标志和溢出标志会设置成 0；对于移位操作，进位标志将设置为最后一个被移出的位，而溢出标志设置为 0；$INC$ 和 $DEC$ 指令会设置溢出和零标志，但是不会改变进位标志。

而将这四个条件码进行组合运算之后就可以知道上一次的单操作数指令中操作数的符号或双操作数指令中操作数的大小关系。根据这个大小关系，我们可以根据判断某关系是否成立将一个字节设置为 0 或 1，也可以根据某关系成立与否跳转到程序的某个其他的部分，以及可以根据条件来传送数据。



# 二. 条件分支

## 1. 条件控制实现

- C 语言`if-else`语句的通用形式模板如下：

  ```c
  if (test-expr)
      then-statement;
  else
      else-statement;
  ```

- 只用 C 语言中的`goto`语句模拟的汇编语言如下：

  ```c
  	t = test-expr;
  	if (!t)
  	    goto false;
  	then-statement;
  	goto done;
  false:
  	else-statement;
  done:
  ```

  - 其中第一行代码就是汇编语言的 $TEST$ 指令，第二行和第三行的`if`语句就是汇编语言的 $JUMP$ 类的指令



## 2. 条件传送实现

上一种实现方法比较传统，也比较简单且通用，但是在现代处理器上，它可能会非常低效。而一种替代的策略就是使用数据的条件转移，其原理是：计算一个条件操作的两种结果，然后再根据条件是否满足从中选取一个。但是只有在一些受限制的情况下，这种策略才可行。

示例如下：

- 一个常见的 C 语言函数（计算 $x-y$ 的绝对值）

  ```c
  long absdiff(long x, long y)
  {
      long result;
      if (x < y)
          return y - x;
      else
          return x - y;
      return result;
  }
  ```

- 该函数还可以像下面这样实现（即条件赋值）

  ```c
  long cmovdiff(long x, long y)
  {
      long rval = y - x;
      long eval = x - y;
      long ntest = x >= y;
      
      if(ntest)
          rval = eval;
      return rval;
  }
  ```

- 将后者表示为汇编代码如下（`x`在`%rdi`中，`y`在`%rsi`中）

  ```assembly
  absdiff:
  	movq %rsi, %rax
  	subq %rdi, %rax
  	movq %rdi, %rdx
  	subq %rsi, %rdx
  	cmpq %rsi, %rdi
  	cmovge %rdx, %rax
  	ret
  ```

可以很明显的发现使用这种方法模拟的`if`语句比上一种方法模拟的`if`语句整洁不少，因为它不需要跳转。而这种方法通常比上一种方法要更快速。



# 三. 循环

## 1. do-while 循环

- C 语言`do-while`循环

  ```c
  do
      body-statement;
  while (test-expr);
  ```

- C 语言使用 `goto`语句实现的`do-while`循环

  ```c
  loop:
  	body-statement;
  	t = test-expr;
  	if (t)
          goto loop;
  ```

汇编语言可以仿照第二种 C 语言实现来模拟`do-while`语句



## 2. while 循环

- C 语言`while`循环

  ```c
  while (test-expr)
      body-statement;
  ```

- C 语言使用`goto`语句实现的`while`循环

  ```c
  	goto test;
  loop:
  	body-statement;
  test:
  	t = test-expr;
  	if (t)
          goto loop;
  ```

- 也可以先将逻辑转换成`do-while`的实现，将`while`循环转换为`do-while`后如下

  ```c
  t = test-expr;
  if (!t)
      goto done;
  do
      body-statement;
  while (test-expr);
  done:
  ```

- 将其使用`goto`语句实现

  ```c
  t = test-expr;
  if (!t)
      goto done;
  loop:
  	body-statement;
  	t = test-expr;
  	if (t)
          goto loop;
  done:
  ```



## 3. for 循环

- C 语言的`for`循环

  ```c
  for (init-expr; test-expr; update-expr)
      body-statement;
  ```

- 由于`for`、`while`和`do-while`循环可以互相转换，所以可以转换成如下形式

  ```c
  init-expr;
  while (test-expr) {
      body-statement;
      update-expr;
  }
  ```

- 然后根据`while`的汇编实现，可以有下面两种形式

  ```c
      init-expr;
      goto test;
  loop:
  	body-statement;
  	update-expr;
  test:
  	t = test-expr;
  	if (t)
          goto loop;
  ```

  ```c
  	init-expr;
  	t = test-expr;
  	if (!t)
          goto done;
  loop:
  	body-statement;
  	update-expr;
  	t = test-expr;
  	if (t)
          goto loop;
  ```



# 四. switch 语句

首先分析 switch 语句，switch 语句可以根据一个整数索引值进行多重分支。在处理具有多种可能结果的测试时，这种语句特别有用。它们不仅提高了 C 代码的可读性，而且通过使用 **跳转表**（jump table）这种数据结构使得实现更加高效。

而什么是跳转表呢？简单来说，跳转表就是一个数组，这个数组根据输入的整数索引（下标）确定要跳转指令的目标。

具体的示例如下：

- C 语言 switch 语句

  ```c
  void switch_eg(long x, long n, long *dest)
  {
      long val = x;
      
      switch (n) {
          case 100:
              val *= 13;
              break;
              
          case 102:
              val += 10;
              
          case 103:
              val += 11;
              break;
              
          case 104:
          case 106:
              val *= val;
              break;
              
          default:
              val = 0;
      }
      *dest = val;
  }
  ```

- C 语言 goto 语句模拟 switch

  ```c
  void switch_eg_impl(long x, long n, long *dest)
  {
      /* 通过 && 运算符获取一个代码段的地址 */	
      static void *jt[7] = {
          &&loc_A, &&loc_def, &&loc_B,			// 中间插入默认代码段以填充两个整数之间的空位
          &&loc_C, &&loc_D, &&loc_def,			// Case 104 和 Case 106实际运行代码相同，用一个代码段表示即可
          &&loc_D
      };
      unsigned long index = n - 100;
      long val;
      
      if (index > 6)
          goto loc_def;
      goto *jt[index];
      
  loc_A:		/* Case 100 */
      val = x * 13;
      goto done;
  loc_B:		/* Case 102 */
      x = x + 10;
  loc_C:		/* Case 103 */
      val = x + 11;
      goto done;
  loc_D:		/* Case 104, 106 */
      val = x * x;
      goto done;
  loc_def:	/* Default Case */
      val = 0;
  done:
      *dest = val;
  }
  ```

- 汇编语言模拟 switch 语句

  ```assembly
  switch_eg:
  	subq $100, %rsi
  	cmpq $6, %rsi
  	ja .L8
  	jmp *.L4(,%rsi,8)
  .L3:
  	leaq (%rdi, %rdi, 2), %rax
  	leaq (%rdi, %rax, 4), %rdi
  	jmp .L2
  .L5:
  	addq $10, %rdi
  .L6:
  	addq $11, %rdi
  	jmp .L2
  .L7:
  	imulq %rdi, %rdi
  	jmp .L2
  .L8:
  	movl %0, %edi
  .L2:
  	movq %rdi, (%rdx)
  	ret
  ```

  其中根据索引跳转部分的指令就是 `jmp *.L4(,%rsi,8)` ，使用到的整个跳转表定义在别处，以`.L4`标签开头