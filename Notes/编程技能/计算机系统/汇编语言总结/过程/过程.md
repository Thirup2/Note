# 一. 简介

**过程**是软件中一种很重要的抽象。它提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现了某种功能。然后，可以在程序中不同的地方调用这个函数。设计良好的软件用过程作为抽象机制，隐藏某个行为的具体实现，同时又提供清晰简洁的接口定义，说明要计算的是哪些值，过程会对程序状态产生什么样的影响。

在不同的编程语言中，过程的形式不同，有：函数（function）、方法（method）、子例程（subroutine）、处理函数（handler）等等，但是它们有一些共同的特性。

假设过程 P 调用过程 Q，Q 执行后返回到 P。这些动作包括下面一个或多个机制：

- **传递控制**：在进入过程 Q 的时候，程序计数器必须被设置为 Q 的代码的起始地址，然后在返回时，要把程序计数器设置为 P 中调用 Q 后面那条指令的地址
- **传递数据**：P 必须能够向 Q 提供一个或多个参数， Q 必须能够向 P 返回一个值
- **分配和释放内存**：在开始时，Q 可能需要为局部变量分配空间，而在返回前，又必须释放这些存储空间。



# 二. 控制

## 1. 运行时栈

C 语言过程调用机制的一个关键特性（大多数其他语言也是如此）在于使用了栈数据结构提供的后进先出的内存管理原则。在过程 P 调用过程 Q 的例子中，可以看到当 Q 在执行时，P 以及所有在向上追溯到 P 的调用链的过程中，都是暂时被挂起的。当 Q 运行时，它只需要为局部变量分配新的存储空间，或者设置到另一个过程的调用。另一方面，当 Q 返回时，任何它所分配的局部存储空间都可以被释放。因此，程序可以用栈来管理它的过程所需要的存储空间，栈和程序寄存器存放着传递控制和数据、分配内存所需要的信息。当 P 调用 Q 时，控制和数据信息添加到栈尾。当 P 返回时，这些信息会释放掉。

在数据栈中，只需要栈指针`%rsp`向栈顶方向增长就分配出一段空间，而向栈底方向增长就释放一段空间。在运行时栈中也一样，具体的运行时栈如下图所示：

![01](images/01.png)

图中上方为栈底，下方为栈顶，其中第一部分就是调用 P 之前分配的空间，第二部分就是调用 P 之后，P 过程使用的空间，而第三部分也就是 P 调用的 Q 所使用的空间。这三部分都有同一个名字：**栈帧**（stack frame）。

从图中可以知道以下几点：

- 当前正在执行的过程的帧总是在栈顶
- 当过程 P 调用过程 Q 时，会把返回地址压入栈中，指明当 Q 返回时，要从 P 程序的哪个位置继续执行。我们把这个返回地址当作 P 的栈帧的一部分，因为它存放的是与 P 相关的状态。
- Q 的代码会扩展当前栈的边界，分配它的栈帧所需的空间。在这个空间中，它可以保存寄存器的值，分配局部变量空间，为它调用的过程设置参数。

另外，大多数过程的栈帧都是定长的，在过程的开始就分配好了。但是有些过程需要变长的帧。

通过寄存器，过程 P 可以传递最多 6 个（因为只有 6 个寄存器是用来保存参数的）整数值（也就是指针和整数），但是如果 Q 需要更多的参数， P 可以在调用 Q 之前在自己的栈帧里存储好这些参数。

为了提高空间和时间效率，x86-64 过程值分配自己所需要的栈帧部分。例如，许多过程有 6 个或者更少的参数，那么所有的参数都可以通过寄存器传递。因此，上图中画出的某些栈帧部分可以省略。实际上，许多函数甚至根本不需要栈帧，当所有的局部变量都可以保存在寄存器中，而且该函数不会调用任何其他函数，就可以这样处理。



## 2. 转移控制

简单来说，使用 `call` 和 `ret` 指令可以完成一个过程的调用和返回。

`call` 指令首先记录好它要继续的 P 的执行的代码位置，即将这个地址压入 P 的栈帧中，然后将程序计数器（PC）设置为 Q 的起始地址。

`ret` 指令则从栈中弹出保存好的返回地址，然后把 PC 设置为这个地址



# 三. 数据传送

当调用一个过程时，需要传递的不只是程序的控制权，在调用过程时可能还需要传递参数以及在过程的返回时可能需要返回一个值。

在 x86-64 中，大部分过程间的数据传送是通过寄存器实现的，可以通过寄存器最多传递 6 个整型（即整数和指针）参数。寄存器的使用是有特殊顺序的，寄存器使用的名字取决于要传递的数据类型的大小，如下表所示:

<table>
    <tr>
        <th rowspan="2">操作数大小（位）</th>
        <th colspan="6">参数数量</th>
    </tr>
    <tr>
        <td>1</td>
        <td>2</td>
        <td>3</td>
        <td>4</td>
        <td>5</td>
        <td>6</td>
    </tr>
    <tr>
        <th>64</th>
        <td><code>%rdi</code></td>
        <td><code>%rsi</code></td>
        <td><code>%rdx</code></td>
        <td><code>%rcx</code></td>
        <td><code>%r8</code></td>
        <td><code>%r9</code></td>
    </tr>
    <tr>
        <th>32</th>
        <td><code>%edi</code></td>
        <td><code>%esi</code></td>
        <td><code>%edx</code></td>
        <td><code>%ecx</code></td>
        <td><code>%r8d</code></td>
        <td><code>%r9d</code></td>
    </tr>
    <tr>
        <th>16</th>
        <td><code>%di</code></td>
        <td><code>%si</code></td>
        <td><code>%dx</code></td>
        <td><code>%cx</code></td>
        <td><code>%r8w</code></td>
        <td><code>%r9w</code></td>
    </tr>
    <tr>
        <th>8</th>
        <td><code>%dil</code></td>
        <td><code>%sil</code></td>
        <td><code>%dl</code></td>
        <td><code>%cl</code></td>
        <td><code>%r8b</code></td>
        <td><code>%r9b</code></td>
    </tr>
</table>

每一列的寄存器只能使用其中一个，因为这一列的寄存器实际上是同一个寄存器的不同大小的划分，如果使用了其中一个如`%edi`，则说明第一个参数就是一个 32 位的整数。

通过寄存器我们可以传递最多 6 个参数，而如果一个函数有大于 6 个整型参数，那么超出 6 个的部分就要通过栈来传递。假设过程 P 调用过程 Q，有 n 个整型参数，且 n > 6。那么 P 的代码分配的栈帧必须要能容纳 7 到 n 号参数的存储空间，如上一节中的图片所示。需要注意的是，参数 7 位于栈顶，这意味着在构造参数的时候应该从最后一个参数往前入栈。通过栈传递参数时，所有的数据大小都向 8 的倍数对齐。

而如果要返回值，则将需要返回的值放到 `%rax` 寄存器中即可。

# 四. 内存管理

## 1. 栈上的局部存储

大多数时候，我们都不需要超出寄存器大小的本地存储区域。不过在下面这些情况下，局部数据必须存放在内存中：

- 寄存器不足够存放所有的本地数据
- 对一个局部变量使用地址运算符`&`，因此必须能够为它产生一个地址
- 某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到

当需要分配这一部分内存时，运行时栈通过减小栈指针在栈上分配空间。分配的结果作为栈帧的一部分，标号为 “局部变量”。



## 2. 寄存器中的局部存储空间

寄存器组是唯一被所有过程共享的资源。虽然在给定时刻只有一个过程是活动的，我们仍然必须确保当一个过程调用另一个过程时，被调用者不会覆盖调用者稍后会使用的寄存器值。为此，x86-64 采用了一组统一的寄存器使用惯例，所有的过程都必须遵守。

根据惯例，寄存器：`%rbx`、`%rbp`和`%12` ～ `%r15` 被划分为**被调用者保存寄存器**。当过程 P 调用 过程 Q 时，Q 必须保存这些寄存器的值，保证它们的值在 Q 返回到 P 时与 Q 被调用时是一样的。过程 Q 保存一个寄存器的值不变的方法要么就是根本不去改变它，要么就是把原始值压入栈中，改变寄存器的值，然后在返回前从栈中弹出旧值。压入寄存器的值会在栈帧中创建标号为 “被保存的寄存器” 的一部分。

所有其他的寄存器，除了栈指针 `%rsp` ，都分类为 **调用者保存** 寄存器。这就意味着任何函数都能够修改它们。可以这样来理解 “调用者保存” 这个名字：过程 P 在某个此类寄存器中有局部数据，然后调用过程 Q，由于 Q 可以随意修改这个寄存器，所以在调用之前首先保存好这个数据是 P 的责任。
