行I/O可以用两种方式执行——未格式化的和格式化的。这两种形式都用于操纵字符串。区别在于未格式化的I/O简单读取或写入字符串，而格式化的I/O则执行数字和其他变量在内部和外部表示形式之间的转换。

# 一. 未格式化的行IO
## 1. 相关函数
### 1). 输入
```c
char *fgets(char *buffer, int buffer_size, FILE *stream);
char *gets(char *buffer);
```
- `fgets`
    - 参数：参数`buffer`是缓冲区，参数`buffer_size`是缓冲区一次能存储的最大字符个数，参数`stream`则是一个输入流
    - 操作：`fgets`从指定的`stream`读取字符并把它们复制到`buffer`中。当它读取一个换行符并存储到缓冲区之后就不再读取。如果缓冲区内存储的字符数达到`buffer_size - 1`个时它也停止读取。在任何一种情况下，一个NUL字节将被添加到缓冲区所存储数据的末尾，使它成为一个字符串。
    - 返回值: 如果在读取任何字符前就到达了文件尾，缓冲区就未进行修改，`fgets`函数返回一个NULL指针；否则返回它的第一个参数
    - **注意**：`fgets`无法把字符串读入到一个长度小于两字符的缓冲区，因为其中一个字符需要为NUL字节保留
- `gets`
    - 参数：`buffer`作为缓冲区，将接受标准输入的字符串
    - 操作：`gets`将标准输入中读取的字符串复制到`buffer`中。当它读取到一个换行符并存储到缓冲区之后就不再读取。
    - 返回值：达到文件尾时返回一个NULL指针；否则返回它的第一个参数
### 2). 输出
```c
int fputs(char const *buffer, FILE *stream);
int puts(char const *buffer);
```
- `fputs`
    - 参数：参数`buffer`是缓冲区，必须包含一个字符串，它的字符被写入到参数`stream`中
    - 操作：将`buffer`中的内容写入到`stream`中
    - 返回值：如果写入时出现了错误，`fputs`返回常量值EOF，否则返回一个非负值
- `puts`
    - 参数：参数`buffer`是缓冲区，必须包含一个字符串
    - 操作：将缓冲区中的字符串输出到标准输出中
    - 返回值：如果写入时出现了错误，`puts`返回常量值EOF，否则返回一个非负值

## 2. 注意
1. 输入和输出都是将流（缓冲区）中的字符复制到缓冲区（流）中，而并非进行指针交换，所以如果缓冲区的参数并非一个数组，而是一个字符指针，那么它所指向的地址的内容将会被修改，如果指针未初始化，那么造成的后果将更严重。所以缓冲区请使用数组名
2. 由于`gets`函数并没有缓冲区长度参数，因此`gets`无法判断缓冲区的长度。如果一个长输入行读到一个短的缓冲区，多出来的字符将被写入到缓冲区后面的内存位置，这将破坏一个或多个不相关变量的值
3. 关于换行符
    - `fgets`和`fputs`：`fgets`将换行符保存到缓冲区，`fputs`将缓冲区中的内容原封不动地输出到流中
    - `gets`和`puts`：`gets`将不保存换行符到缓冲区，`puts`会在输出到缓冲区的内容后面添加一个换行符

# 二. 格式化的行IO
## 1. scanf家族
### 1). 相关函数
```c
int fscanf(FILE *stream, char const *format, ...);
int scanf(char const *format, ...);
int sscanf(char const *string, char const *format, ...);
```
- 参数
    - `fscanf`: `stream`为指定的输入流，`format`是一串格式代码字符串，然后是一个可变长度的指针列表
    - `scanf`：同上，使用标准输入流
    - `sscanf`：`string`是给定的字符串来代替输入流，其他同上
- 操作
    - `fscanf`：从指定的输入流中读取字符并根据`format`字符串给出的格式代码对它们进行转换，然后存储到后续各个指针所指的内存位置
    - `scanf`：从标准输入流中读取字符然后完成和上述相同的工作
    - `sscanf`：从给定的字符串中读取字符然后完成和上述相同的工作
- 返回值：返回被转换的输入值的数目。如果在任何输入值被转换之前文件就已经到达尾部，函数就返回常量值EOF
- **注意**：为了能让这些函数正常运行，指针参数的类型必须是对应格式代码的正确类型。函数无法验证它们的指针参数是否为正确的类型，所以函数就假定它们是正确的，于是继续执行并使用它们。如果指针参数的类型是不正确的，那么结果值就会是垃圾，而邻近的变量有可能在处理过程中被改写。

### 2). scanf格式代码
`scanf`函数家族中的`format`字符串参数可能包含下列内容：
- 空白字符：它们与输入中的零个或多个空白字符匹配，在处理过程中将被忽略
- 格式代码：他们指定函数如何解释接下来的输入字符
- 其他字符：当任何其他字符出现在格式字符串时，下一个输入字符必须与它匹配。如果匹配，该输入字符随后就被丢弃。如果不匹配，函数就不再读取而是直接返回。

`scanf`家族的格式代码都以一个百分号开头，后面按顺序是一个星号（可选）、一个宽度（可选）、一个限定符（可选）、格式代码。

#### 星号
星号将使转换后的值被丢弃而不是被存储。
这个技巧可以用于跳过不需要的输入字符
**注意**：有星号的格式代码虽然进行了转换但未进行任何其他操作，返回值不会增加

#### 宽度
宽度为一个非负的整数，用于限制将被读取用于转换的输入字符的个数。
如果未给出宽度，函数就连续读入字符，直到遇见输入中的下一个空白字符

#### 限定符
限定符用于修改有些格式代码的含义，具体的限定符如下：

|格式代码|`h`|`l`|`L`|
|:-:|:-:|:-:|:-:|
|`d`、`i`、`n`|`short`|`long`||
|`o`、`u`、`x`|`unsigned short`|`unsigned long`||
|`e`、`f`、`g`||`double`|`long double`|

**注意**：
1. 限定符的目的是为了指定参数的长度。如果整形参数比缺省的整型值更短或更长，在格式代码中省略限定符就是一个常见的错误。浮点类型也是如此。如果省略限定符，可能会导致一个较长的变量只有部分被初始化，或者一个较短变量的邻近变量也被修改，这些都取决于这些类型的相对长度。
2. 如果在转换所有的`short`、`long`型整数值和`long double`型变量时都使用适当的限定符，可以使程序更具可移植性

#### 格式代码
格式代码就是一个单字符，用于指定如何解释输入字符

|代码|参数|含义|
|:-:|:-:|:-:|
|`c`|`char *`|读取和存储单个字符。前导的空白字符并不跳过。如果给出宽度，就读取和存储这个数目的字符。字符后面不会添加一个NUL字节。参数必须指向一个足够大的字符数组。|
|`i`、`d`|`int *`|一个可选的有符号整数被转换。`d`把输入解释为十进制数；`i`根据它的第一个字符决定值的基数，就像整型字面值常量的表示形式一样，能够读取有前缀的八进制和十六进制值|
|`u`、`o`、`x`|`unsigned *`|一个可选的有符号整数被转换，但它按照无符号数存储。如果使用`u`，值被解释为十进制数；如果使用`o`，值被解释为八进制数；如果使用`x`，值被解释为十六进制数（X和x同义）|
|`e`、`f`、`g`|`float *`|期待一个浮点值。它的形式必须像一个浮点型字面值常量，但小数点并非必需的（E和e同义；G和g同义）|
|`s`|`char *`|读取一串非空白字符。参数必须指向一个足够大的字符数组。当发现空白时输入就停止，字符串后面会自动加上NUL终止符|
|`[xxx]`|`char *`|根据给定组合的字符从输入中读取一串字符。参数必须指向一个足够大的字符数组。当遇到第一个不在给定组合中出现的字符时，输入就停止。字符串后面会自动加上NUL终止符。如果列表中以一个`^`字符开头，表示字符组合是所列出的字符的补给，即除了字符列表之外的其他字符。右方括号也可以出现在字符列表中，但它必须是列表的第1个字符。根据编译器不同，横杠可以指定某个范围的 字符|
|`p`|`void *`|输入预期为一串字符，跟使用`printf`函数打印`%p`格式代码所产生的输出类似。它的转换方式因编译器而异，但转换结果将和按照上面描述的进行打印所产生的的字符的值相同|
|`n`|`int *`|到目前为止（`%n`）通过调用`scanf`函数从输入读取的字符数被返回。`%n`转换的字符并不计算在`scanf`函数的返回值内，它本身并不消耗任何输入|
|`%`|（无）|这个代码与输入中的一个%相匹配，该%符号将被丢弃|

## 2. printf家族

### 1). 相关函数
```c
int fprintf(FILE *stream, char const *format, ...);
int printf(char const *format, ...);
int sprintf(char *buffer, char const *format, ...);
```
- 参数
    - `fprintf`：`stream`是输出流，`format`是格式化字符串，然后是一个可变长度的值列表
    - `printf`：同上，使用标准输出流
    - `sprintf`：`buffer`是将要输出到的缓冲区来代替标准输出流
- 操作
    - `fprintf`：将格式化字符串中格式代码替换为后面的值后输出到指定输出流中
    - `printf`：将格式化字符串中格式代码替换为后面的值后输出到标准输出流中
    - `sprintf`：将格式化字符串中格式代码替换为后面的之后输出到缓冲区中
- 返回值：实际打印或存储的字符数
- **注意**
    1. `sprintf`的缓冲区大小并不是函数的一个参数，所以如果输出结果会溢出缓冲区时，就可能改写缓冲区后面内存位置中的数据。要杜绝这个问题，可以采取两种策略。第一种是声明一个非常巨大的缓冲区，但这个方案很浪费内存，而且再大的缓冲区都有溢出的可能。第二种方法是对格式进行分析，看看最大可能出现的值被转换后的结果输出将有多长。
    2. 另一个错误的来源是函数的参数类型与对应的格式代码不匹配。通常这个错误将导致输出结果成为垃圾，但这种不匹配也可能导致程序失败。

### 2). printf格式代码
`printf`函数原型中的`format`字符串可能包含格式代码，它使参数列表的下一个值根据指定的方式进行格式化，至于其他的字符则原样逐字打印。
格式代码由一个百分号开头，后面按顺序是：零个或多个标志字符、一个最小字段宽度（可选）、一个精度（可选）、一个修改符（可选）、转换类型

#### 标志字符
用于修改有些转换的执行方式，下面是标志字符表：

|标志|含义|
|:-:|:-:|
|`-`|值在字段中左对齐，缺省情况下是右对齐|
|`0`|当数值为右对齐时，缺省情况下是使用空格填充值左边未使用的列。这个标志表示用0来填充，它可用于`d`、`i`、`u`、`o`、`x`、`X`、`e`、`E`、`f`、`g`、`G`代码。使用`d`、`i`、`u`、`o`、`x`、`X`代码时，如果给出了精度字段，零标志就被忽略。如果格式代码中出现了负号标志，`0`也没有效果
|`+`|当用于一个格式化某个有符号值的代码时，如果值为非负，正号标志就会给它加上一个正号。如果值为负，负号照常显示。在缺省条件下，正号并不会显示|
|`空格`|只用于转换有符号值的代码。当值非负时，这个标志把一个空格添加到它的开始位置。如果和`+`标志同时给出，空格标志将被忽略|
|`#`|选择某些代码的另一种转换形式|

当`#`号值用于不同的格式代码时，会将其转换成不同的形式：

|当`#`用于······|效果|
|:-:|:-:|
|`o`|保证产生的值以一个零开头|
|`x`、`X`|在非零值前面加`0x`前缀（`%#X`则为`0X`）|
|`e`、`E`、`f`|确保结果始终包含一个小数点，即使它后面没有数字|
|`g`、`G`|与上面的`e`、`E`、`f`代码相同。另外，缀尾的0不从小数中去除|

#### 字段宽度
字段宽度是一个十进制整数，用于指定将出现在结果中的最小字符数。如果值的字符数少于字段宽度，就对它进行填充以增加长度。标志决定填充是用空白还是0，以及它出现在值的左边还是右边

#### 精度
对于`d`、`i`、`u`、`o`、`x`、`X`类型的转换，精度字段指定将出现在结果中的最小的数字个数并覆盖0标志。如果转换后的值的位数小于宽度，就在它的前面插入零。如果值为0且精度也为0，则转换结果就不会产生数字。对于`e`、`E`、`f`类型的转换，精度决定将出现在小数点之后的数字位数。对于`g`和`G`类型的转换，精度指定将出现在结果中的最大有效位数。当使用`s`类型的转换时，精度指定将被转换的最多字符数。精度以一个句点开头，后面跟一个可选的十进制整数。如果为给出整数，精度的缺省值为零

#### 星号
如果用于表示字段宽度和/或精度的十进制整数由一个星号代替，那么`printf`的下一个参数（必须是个整数）就提供宽度和/或精度。因此，这些值可以通过计算获得而不必预先指定。

#### 修改符
通过修改符可以指定整数和浮点数参数的准确长度

|修改符|用于······时|表示参数是······|
|:-:|:-:|:-:|
|`h`|`d`、`i`、`u`、`o`、`x`、`X`|一个（可能是无符号的）`short`型整数|
|`h`|`n`|一个指向`short`型整数的指针|
|`l`|`d`、`i`、`u`、`o`、`x`、`X`|一个（可能是无符号的）`long`型整数|
|`l`|`n`|一个指向`long`型整数的指针|
|`L`|`e`、`E`、`f`、`g`、`G`|一个`long double`型值|

#### 格式代码

|代码|参数|含义|
|:-:|:-:|:-:|
|`c`|`int`|参数被裁剪为`unsigned char`并作为字符打印|
|`d`、`i`|`int`|参数作为一个十进制整数打印。如果给出了精度而且值的位数少于精度位度，前面就用0填充|
|`u`、`o`、`x`、`X`|`unsigned int`|参数作为一个无符号值打印。`u`使用十进制；`o`使用八进制；`x`或`X`使用十六进制|
|`e`、`E`|`double`|参数根据指数形式打印。小数点后面的位数由精度字段决定，缺省值是6|
|`f`|`double`|参数按照常规的浮点格式打印。精度字段缺省值是6|
|`g`、`G`|`double`|参数以`%f`、`%e`或`%E`的格式打印，取决于它的值。如果指数大于等于-4但小于精度字段，就用`%f`格式，否则使用指数格式|
|`s`|`char *`|打印一个字符串|
|`p`|`void *`|指针值被转换为一串因编译器而异的可打印字符。这个代码主要是和`scanf`中的`%p`代码组合使用|
|`n`|`int *`|这个代码是独特的，因为它并不产生任何输出。相反，到目前为止函数所产生的的输出字符数目将被保存到对应的参数中|
|`%`|（无）|打印一个`%`字符|