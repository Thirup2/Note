# 一. 参数传递
## 1. 参数传递
C函数的所有参数均以"传值调用"的方式进行传递, 即函数将获得参数值的一份拷贝而不是其本身.
## 2. 具体情况
1. 普通变量: 函数创建一个新的变量, 其位置与参数的位置不同, 但内容和参数相同, 函数中的所有对该变量的操作都是在操作其副本而不是其本身.
2. 指针变量: 当传递的参数是一个指针时, 函数同样先创建一个与该指针变量自身位置不同的另一个指针变量, 但其内容与参数的内容相同, 即都指向同一个地址, 如果更改函数中指针的指向, 原本的指针的指向并不会改变, 但如果更改函数中指针指向的内容, 则原指针指向的内容也会改变
3. 数组指针: 当传递的参数是一个数组名时, 实际上传递的是一个指针, 其指向为数组的第一个元素的开始位置, 其他操作与传递指针相同. 另外, 如果函数需要数组的长度这个值, 它必须作为参数显式地传递给函数.

- **注: 当传递的参数是一个指针时, 实参应该传入一个指针变量或者指针常量(即一个地址, 通过取址符获取).**
> - **K&R C**：在标准中， 函数的参数是像下面这样声明的：
>     ```c
>     int func(a, b, c)
>     int a;
>     char b;
>     float c;
>     {
>     ...
>     }
>     ```
>     使用这种旧风格的函数声明的时候，在参数传递之前，char和short类型的参数被提升为int类型，float类型的参数被提升为double类型。这种转换被称为缺省参数提升。
> - **ANSI C**：为了保持兼容性，ANSI编译器也会为旧式风格声明的函数执行这类转换。但是，使用原型的函数并不执行这类转换，所以混用这两种风格可能导致错误。

# 二. 可变参数列表
## 1. stdarg宏
该文件声明了一个类型:
- va_list

以及三个宏:
- va_start
- va_arg
- va_end

可以声明一个类型为va_list的变量, 与这几个宏配合使用, 访问参数的值

## 2. 使用方法
- va_start
    - 第一个参数是va_list类型变量的名字; 第二个参数是省略号前最后一个有名字的参数
    - 操作: 把第一个参数的变量设置为指向可变参数部分的第一个参数
- va_arg
    - 第一个参数是va_list类型变量的名字; 第二个参数是参数列表中下一个参数的类型
    - 操作: 返回变量的值, 然后使变量指向下一个可变参数
- va_end
    - 接受一个参数: va_list类型变量的名字
    - 当访问完最后一个可变参数之后, 需要调用va_end

## 3. 例
```c
// 计算指定数量的值的平均值

#include <stdarg.h>
float average(int n_values, ...)
{
    va_list var_arg;
    int count;
    float sum = 0;
    
    // 准备访问可变参数
    va_start(var_arg, n_values);
    
    // 添加取自可变参数列表的值
    for(count = 0; count < n_values; count += 1)
    {
        sum += va_arg(var_arg, int);
    }

    // 完成处理可变参数
    va_end(var_arg);
    
    return sum / n_values;
}
```
- 注意参数列表中的省略号: 它提示此处可能传递数量和类型未确定的参数. 在编写这个函数的原型时, 也要使用相同的记法.

## 4. 限制
- 这些宏无法判断实际存在的参数的数量
- 这些宏无法判断每个参数的类型