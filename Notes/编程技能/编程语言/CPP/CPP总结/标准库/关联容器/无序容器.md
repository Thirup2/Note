# 一. 简介

对于关联容器中的 4 个**无序关联容器**（unordered associative container）来说，这些容器并不是使用比较运算符来组织元素，而是使用一个**哈希函数**（hash function）和关键字类型的`==`运算符。在关键字类型的元素没有明显的序关系的情况下，无序容器是非常有用的。在某些应用中，维护元素的序的代价非常高昂，此时无序容器也很有用。



# 二. 使用方法

除了使用哈希管理操作之外，无序容器还提供了与有序容器相同的操作（`find`、`insert`等）。这意味着我们曾用于`map`和`set`的操作也能用于`unordered_map`和`unordered_set`。类似的，无序容器也有允许重复关键字的版本。

**无序容器在存储上组织为一组桶**，每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶。

为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。容器将具有一个特定哈希值的所有元素都保存在相同的桶中。如果容器允许重复关键字，所有具有相同关键字的元素也都会在同一个桶中。因此，无序容器的性能依赖于哈希函数的质量和桶的数量和大小。

对于相同的参数，哈希函数必须总是产生相同的结果。理想情况下，哈希函数还能将每个特定的值映射到唯一的桶。但是，将不同关键字的元素映射到相同的桶也是允许的。当一个桶保存多个元素时，需要顺序搜索这些元素来查找我们想要的那个。计算一个元素的哈希值和在桶中搜索通常都是很快的操作。但是，如果一个桶中保存了很多元素，那么查找一个特定元素就需要大量比较操作。

无序容器提供了一组管理桶的函数，具体如下表所示：

****

**桶接口**：

| 操作                   | 描述                        |
| ---------------------- | --------------------------- |
| `c.bucket_count()`     | 正在使用的桶的数目          |
| `c.max_bucket_count()` | 容器能容纳的最多的桶的数量  |
| `c.bucket_size(n)`     | 第`n`个桶中有多少个元素     |
| `c.bucket(k)`          | 关键字为`k`的元素在哪个桶中 |

****

**桶迭代**：

| 类型                   | 描述                             |
| ---------------------- | -------------------------------- |
| `local_iterator`       | 可以用来访问桶中元素的迭代器类型 |
| `const_local_iterator` | 桶迭代器的`const`版本            |

| 操作                           | 描述                                           |
| ------------------------------ | ---------------------------------------------- |
| `c.begin(n)`<br />`c.end(n)`   | 桶`n`的首元素迭代器和尾后迭代器                |
| `c.cbegin(n)`<br />`c.cend(n)` | 与前两个函数类似，但返回`const_local_iterator` |

****

**哈希策略**：

| 操作                  | 描述                                                         |
| --------------------- | ------------------------------------------------------------ |
| `c.load_factor()`     | 每个桶的平均元素数量，返回`float`值                          |
| `c.max_load_factor()` | `c`试图维护的平均桶大小，返回`float`值。<br />`c`会在需要时添加新的桶，以使得`load_factor <= max_load_factor` |
| `c.rehash(n)`         | 重组存储，使得`bucket_count >= n`且`bucket_count > size/max_load_factor` |
| `c.reserve(n)`        | 重组存储，使得`c`可以保存`n`个元素不必`rehash`               |



# 三. 无序容器对关键字类型的要求

默认情况下，无序容器使用关键字类型的`==`运算符来比较元素，它们还使用一个`hash<key_type>`类型的对象来生成每个元素的哈希值。标准库为内置类型（包括指针）提供了`hash`模板。还为一些标准库类型，包括`string`和智能指针定义了`hash`。因此，我们可以直接定义关键字是内置类型（包括指针类型）、`string`还有智能指针类型的无序容器。

但是，我们不能直接定义关键字类型为自定义类类型的无序容器。与容器不同，不能直接使用哈希模板，而必须提供我们自己的`hash`模板版本。

除了定义默认的`hash`，还可以使用另一种方法，类似于为有序容器重载关键字类型的默认比较操作。例如，为了能将`Sales_data`用作关键字，我们需要提供函数来替代`==`运算符和哈希值计算函数：

```c++
size_t hasher(const Sales_data &sd)
{
    return hash<string>() (sd.isbn());
}
```

```c++
bool eqOp(const Sales_data &lhs, const Sales_data &rhs)
{
    return lhs.isbn() == rhs.isbn();
}
```

我们的`hasher`函数使用一个标准库`hash`类型对象来计算`ISBN`成员的哈希值，该`hash`类型建立在`string`类型之上。类似的，`eqOp`函数通过比较`ISBN`号来比较两个`Sales_data`。

我们使用这些函数来定义一个`unordered_multiset`：

```c++
using SD_multiset = unordered_multiset<Sales_data, decltype(hasher)*, decltype(eqOp)*>;
SD_multiset bookstore(42, hasher, eqOp);
```

如果我们的类定义了`==`运算符，则可以只重载哈希函数：

```c++
unordered_set<Foo, decltype(FooHash)*> fooSet(10, FooHash);
```

