# 一. 容器类型成员

| 类型                     | 描述                                                         |
| ------------------------ | ------------------------------------------------------------ |
| `iterator`               | 此容器类型的迭代器类型                                       |
| `const_iterator`         | 可以读取元素，但不能修改元素的迭代器类型                     |
| `size_type`              | 无符号整数类型，足够保存此种容器类型最大可能容器的大小       |
| `difference_type`        | 带符号整数类型，足够保存两个迭代器之间的距离                 |
| `value_type`             | 元素类型<br />**（对于 set，与`key_type`相同；<br />对于 map，为`pair<const key_type, mapped_type>`）** |
| `reference`              | 元素的左值类型；与`value_type &`含义相同                     |
| `const_reference`        | 元素的`const`左值类型（即`const value_type &`）              |
| `reverse_iterator`       | 按逆序寻址元素的迭代器                                       |
| `const_reverse_iterator` | 不能修改元素的逆序迭代器                                     |
| `key_type`               | 此容器类型的关键字类型                                       |
| `mapped_type`            | 每个关键字关联的类型**（只适用于 map）**                     |

****

**注**：

只有`map`类型才定义了`mapped_type`；

一个`map`的`value_type`是一个`pair`，我们可以改变`pair`的值，但是不能改变关键字成员的值。

****



# 二. 构造函数

| 操作                | 描述                                                 |
| ------------------- | ---------------------------------------------------- |
| `C c`               | 默认构造函数，构造空容器                             |
| `C c1(c2)`          | 构造`c2`的拷贝`c1`                                   |
| `C c(b, e)`         | 构造`c`，将迭代器`b`和`e`指定的范围内的元素拷贝到`c` |
| `C c{a, b, c, ...}` | 列表初始化`c`                                        |

****

**注**：

- 使用列表初始化一个`map`时，提供的初始值应该是一个键值对，这个键值对如下所示：

  ```c++
  {key, value}
  ```

  即，如下例所示：

  ```c++
  map<string, string> authors = { {"Joyce", "James"},
                                  {"Austen", "Jane"},
                                  {"Dickens", "Charles"} };
  ```

- 对于`map`或`set`中的关键字必须是唯一的。但是`multimap`和`multiset`没有此限制，它们都允许多个元素具有相同的关键字。例如，一个词典中，一个特定单词可以有多个与之关联的词义。

****



# 三. 赋值与 swap

| 操作                  | 描述                           |
| --------------------- | ------------------------------ |
| `c1 = c2`             | 将`c1`中的元素替换为`c2`中元素 |
| `c1 = {a, b, c, ...}` | 将`c1`中的元素替换为列表中元素 |
| `a.swap(b)`           | 交换容器`a`和`b`的元素         |
| `swap(a, b)`          | 与`a.swap(b)`等价              |



# 四. 大小

| 操作           | 描述                                           |
| -------------- | ---------------------------------------------- |
| `c.size()`     | `c`中元素的数目                                |
| `c.max_size()` | `c`可保存的最大元素数目                        |
| `c.empty()`    | 若`c`中存储了元素，返回`false`，否则返回`true` |



# 五. 添加/删除元素

| 操作                                       | 描述                                                         |
| ------------------------------------------ | ------------------------------------------------------------ |
| `c.insert(v)`<br />`c.emplace(args)`       | `v`是`value_type`类型的对象；`args`用来构造一个元素<br />对于`map`和`set`，只有当元素的关键字不在`c`中时才插入（或构造）元素。<br />函数返回一个`pair`，包含一个迭代器，指向具有指定关键字的元素，以及一个值是插入是否成功的`bool`值<br />对于`multimap`和`multiset`，总会插入（或构造）给定元素，并返回一个指向新元素的迭代器 |
| `c.insert(b, e)`<br />`c.insert(il)`       | `b`和`e`是迭代器，表示一个`c::value_type`类型值的范围；`il`是这种值的花括号列表。函数返回`void`<br />对于`map`和`set`，只插入关键字不在`c`中的元素。<br />对于`multimap`和`multiset`，则会插入范围中的每个元素 |
| `c.insert(p, v)`<br />`c.emplace(p, args)` | 类似`insert(v)`（或`emplace(args)`），但将迭代器`p`作为一个提示，指出从哪里开始搜索新元素应该存储的位置。<br />返回一个迭代器，指向具有给定关键字的元素 |
| `c.erase(k)`                               | 从`c`中删除每个关键字为`k`的元素。<br />返回一个`size_type`值，指出删除的元素的数量 |
| `c.erase(p)`                               | 从`c`中删除迭代器`p`指定的元素。<br />`p`必须指向`c`中一个真实元素，不能等于`c.end()`。<br />返回一个指向`p`之后元素的迭代器，若`p`指向`c`中的尾元素，则返回`c.end()` |
| `c.erase(b, e)`                            | 删除迭代器对`b`和`e`所表示的范围中的元素。返回`e`            |



# 六. 关系运算符

| 操作                 | 描述                                 |
| -------------------- | ------------------------------------ |
| `==`、`!=`           | 相等性（不等性）运算符               |
| `<`、`<=`、`>`、`>=` | 关系运算符**（无序关联容器不支持）** |



# 七. 获取迭代器

| 操作                           | 描述                                        |
| ------------------------------ | ------------------------------------------- |
| `c.begin()`<br />`c.end()`     | 返回指向`c`的首元素和尾元素之后位置的迭代器 |
| `c.cbegin()`<br />`c.cend()`   | 返回`const_iterator`                        |
| `c.rbegin()`<br />`c.rend()`   | 返回指向`c`的尾元素和首元素之前位置的迭代器 |
| `c.crbegin()`<br />`c.crend()` | 返回`const_reverse_iterator`                |

****

**注**：

- 对一个关联容器的迭代器进行解引用操作将得到一个类型为容器的`value_type`的值的引用，对于`map`来说，`value_type`是一个`pair`类型，其`first`成员保存`const`的关键字，`second`成员保存值
- `set`的迭代器是`const`的。虽然`set`类型同时定义了`iterator`和`const_iterator`类型，但两种类型都只允许只读访问`set`中的元素。

****



# 八. 下标

**下标操作只适用于 map 和 unordered_map 类型**：

| 操作      | 描述                                                         |
| --------- | ------------------------------------------------------------ |
| `c[k]`    | 返回关键字为`k`的元素；<br />如果`k`不在`c`中，添加一个关键字为`k`的元素，对其进行值初始化 |
| `c.at(k)` | 访问关键字为`k`的元素，带参数检查；<br />若`k`不在`c`中，抛出一个`out_of_range`异常 |

****

**注**：

由于下标运算符可能插入一个新元素，我们只可以对非`const`的`map`使用下标操作。

****



# 九. 访问元素

| 操作               | 描述                                                         |
| ------------------ | ------------------------------------------------------------ |
| `c.find(k)`        | 返回一个迭代器，指向第一个关键字为`k`的元素，若`k`不在容器中，则返回尾后迭代器 |
| `c.count(k)`       | 返回关键字等于`k`的元素的数量。对于不允许重复关键字的容器，返回值永远是 0 或 1 |
| `c.lower_bound(k)` | 返回一个迭代器，指向第一个关键字不小于`k`的元素**（不适用于无序容器）** |
| `c.upper_bound(k)` | 返回一个迭代器，指向第一个关键字大于`k`的元素**（不适用于无序容器）** |
| `c.equal_range(k)` | 返回一个迭代器`pair`，表示关键字等于`k`的元素的范围。<br />若`k`不存在，`pair`的两个成员均等于`c.end()` |

****

**注**：

- 如果对`map`和`unordered_map`使用下标访问操作，那么会有一个严重的副作用，就是会插入关键字不在容器中的元素。如果不想访问操作有这个副作用，我们就可以使用`find`来代替下标访问。
