# 一. 简介

关联容器对其关键字有一些限制，本节主要是关于有序容器对于关键字的要求。

对于`map`、`multimap`、`set`以及`multiset`，关键字类型**必须定义元素比较的方法**。默认情况下，标准库使用关键字类型的`<`运算符来比较两个关键字。

在集合类型中，关键字类型就是元素类型；在映射类型中，关键字类型是元素的第一部分的类型。



# 二. 严格弱序

可以向一个算法提供我们自己定义的比较操作，与之类似，也可以提供自己定义的操作来代替关键字上的`<`运算符。所提供的操作必须在关键字类型上定义一个**严格弱序**（strict weak ordering）。可以将严格弱序看作 “小于等于”，虽然实际定义的操作可能是一个复杂的函数。无论我们怎么定义比较函数，它必须具备如下基本性质：

- 两个关键字不能同时 “小于等于” 对方；如果 `k1` “小于等于” `k2`，那么`k2`绝不能 “小于等于” `k1`
- 如果`k1` “小于等于” `k2`，且 `k2` “小于等于” `k3`，那么`k1`必须 “小于等于” `k3`
- 如果存在两个关键字，任何一个都不 “小于等于” 另一个，那么我们称这两个关键字是 “等价” 的。如果`k1` “等价于” `k2`，且`k2` “等价于” `k3`，那么`k1`必须 “等价于” `k3`

如果存在两个关键字是等价的，那么容器将它们视作相等来处理。当用作`map`的关键字时，只能有一个元素与这两个关键字关联，我们可以用两者中任意一个来访问对应的值。



# 三. 关键字类型的比较函数

用来组织一个容器中元素的操作的类型也是该容器类型的一部分。为了指定使用自定义的操作，必须在定义关联容器类型时提供此操作的类型。

如前所述，用尖括号指定要定义哪种类型的容器，自定义的操作类型必须在尖括号中紧跟着元素类型给出。

在**尖括号中出现的每个类型，就仅仅是一个类型而已**。当我们创建一个容器（对象）时，才会以构造函数参数的形式提供真正的比较操作（其类型比较与在尖括号中指定的类型相吻合）。

我们首先需要定义一个严格弱序：

```c++
bool compareIsbin(const Sales_data &lhs, const Sales_data &rhs)
{
    return lhs.isbn() < rhs.isbn();
}
```

如果要使用自己定义的操作，在定义时提供关键字类型后就需要同时指出这个操作的类型（这个操作类型通常是一个函数指针类型，可以指向这个操作）。当定义此容器类型的对象时，需要提供想要使用的操作的指针。

在本例中，我们可以提供一个指向`compareIsbn`的指针：

```c++
multiset<Sales_data, decltype(compareIsbn)*>
    bookstore(compareIsbn);
```

此处，我们使用`decltype`来指出自定义操作的类型，由于其严格返回表达式的类型，所以我们后面需要添加一个`*`来表示这是一个指针。

当我们声明该类型后，该类型的对象在初始化时必须提供第二个类型的对象作为初始值，即`bookstore(compareIsbn)`。

然后该类型就会将初始化提供的函数作为比较函数来代替关键字类型的`<`运算符。