# 一. 简介

关联容器支持高效的关键字查找和访问。两个主要的**关联容器**（associative-container）类型是`map`和`set`。

`map`中的元素是一些**关键字-值**（key-value）对：关键字起到索引的作用，值则表示与索引相关联的数据。

`set`中每个元素只包含一个关键字；`set`支持高效的关键字查询操作——检查一个给定关键字是否在`set`中。例如，在某些文本处理过程中，可以用一个`set`来保存想要忽略的单词。

字典则是一个很好的使用`map`的例子：可以将单词作为关键字，将单词释义作为值。



# 二. 类型

标准库提供 8 个关联容器。这 8 个容器间的不同体现在三个维度上：

- 每个容器或者是一个`set`，或者是一个`map`。
- 每个容器或者要求不重复的关键字，或者允许重复的关键字。允许重复关键字的容器的名字中都包含单词`multi`
- 每个容器或者按顺序保存元素，或者无序保存。不保持关键字按顺序存储的容器的名字都以单词`unordered_`开头。对于无序容器来说，其使用哈希函数来组织元素。

具体的类型如下表所示：

****

**按关键字有序保存元素**：`map`和`multimap`定义在头文件`<map>`中；`set`和`multiset`定义在头文件`set`中

| 类型       | 描述                             |
| ---------- | -------------------------------- |
| `map`      | 关联数组：保存关键字-值对        |
| `set`      | 关键字即值，即只保存关键字的容器 |
| `multimap` | 关键字可重复出现的`map`          |
| `multiset` | 关键字可重复出现的`set`          |

****

**无序集合**：`unordered_map`和`unordered_multimap`定义在头文件`<unordered_map>`中；`unordered_set`和`unordered_multiset`定义在头文件`<unordered_set>`中

| 类型                 | 描述                              |
| -------------------- | --------------------------------- |
| `unordered_map`      | 用哈希函数组织的`map`             |
| `unordered_set`      | 用哈希函数组织的`set`             |
| `unordered_multimap` | 哈希组织的`map`；关键字可重复出现 |
| `unordered_multiset` | 哈希组织的`set`；关键字可重复出现 |



# 三. 使用关联容器

## 1. 使用 map

`map`是关键字-值对的集合。例如，可以将一个人的名字作为关键字，将其电话号码作为值。我们称这样的数据结构为 “将名字映射到电话号码”。`map`类型通常被称为**关联数组**（associative array）。关联数组与 “正常” 数组类似，不同之处在于其下标不必是整数。我们通过一个关键字而不是位置来查找值。给定一个名字到电话号码的`map`，我们可以使用一个人的名字作为下标来获取此人的电话号码。

另一个经典的使用关联数组的例子是单词计数程序：

```c++
map<string, size_t> word_count;
string word;
while (cin >> word)
    ++word_count[word];
for (const auto &w : word_count)
    cout << w.first << " occurs " << w.second
    	 << ((w.second > 1) ? " times" : " time") << endl;
```

此程序读取输入，报告每个单词出现多少次。

关联容器也是模板，为了定义一个`map`，我们必须指定关键字和值的类型。在此程序中，`map`保存的每个元素中，关键字是`string`类型，值是`size_t`类型。当对`word_count`进行下标操作时，我们使用一个`string`（即关键字类型）作为下标，获得与此`string`相关联的`size_t`类型的计数器。



## 2. 使用 set

上一个示例程序的一个合理扩展是：忽略常见单词，如 "the"、"and"、"or" 等。我们可以使用`set`保存想忽略的单词，只对不在集合中的单词统计出现次数：

```c++
map<string, size_t> word_count;
set<string> exclude = {"The", "But", "And", "Or", "An", "A",
                      "the", "but", "and", "or", "an", "a"};
string word;
while (cin >> word)
    if (exclude.find(word) == exclude.end())
        ++word_count[word];
```

`set`也是类模板，为了定义一个`set`，必须指定其元素类型，本例中是`string`。与顺序容器类似，可以对一个关联容器的元素进行列表初始化。集合`exclude`中保存了 12 个我们想忽略的单词。

其中`if`语句的判断子句的语义是从`exclude`查找`word`，如果没有找到，才进入其主体。即如果`word`存在于`exclude`中，那它就是我们不需要统计的对象，我们就跳过这次`if`。