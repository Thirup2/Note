除了为每个容器定义的迭代器之外，标准库在头文件`iterator`中还定义了额外几种迭代器。这些迭代器包括以下几种：

- **插入迭代器**（insert iterator）：这些迭代器被绑定到一个容器上，可用来向容器插入元素
- **流迭代器**（stream iterator）：这些迭代器被绑定到输入或输出流上，可用来遍历所关联的 IO 流
- **反向迭代器**（reverse iterator）：这些迭代器向后而不是向前移动。除了`forward_list`之外的标准库容器都有反向迭代器
- **移动迭代器**（move iterator）：这些专用的迭代器不是拷贝其中的元素，而是移动它们。

# 一. 插入迭代器

插入器是一种迭代器适配器，它接受一个容器，生成一个迭代器，能实现向给定容器添加元素。当我们通过一个插入迭代器进行赋值时，该迭代器调用容器操作来想给定容器的指定位置插入一个元素。

## 1. 分类

插入器有三种类型，差异在与元素插入的位置：

- **back_inserter**：创建一个使用`push_back`的迭代器，返回的迭代器类型为`std::back_insert_iterator<container_class>`
- **front_inserter**：创建一个使用`push_front`的迭代器，返回的迭代器类型为`std::front_insert_iterator<container_class>`
- **inserter**：创建一个使用`insert`的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前，返回的迭代器类型为`std::insert_iterator<container_class>`

**需要注意的是**：只有在容器支持`push_front`的情况下，我们才可以使用`front_inserter`。类似的，只有在容器支持`push_back`的情况下，我们才能使用`back_inserter`。



## 2. 操作

其支持的操作如下：

| 操作                  | 描述                                                         |
| --------------------- | ------------------------------------------------------------ |
| `it = t`              | 在`it`指定的当前位置插入值`t`。<br />假定`c`是`it`绑定的容器，依赖于插入迭代器的不同种类<br />此赋值会分别调用`c.push_back(t)`、`c.push_front(t)`或`c.insert(t, p)`，<br />其中`p`为传递给`inserter`的迭代器位置 |
| `*it`，`++it`，`it++` | 这些操作虽然存在，但不会对`it`做任何事情，每个操作都返回`it` |



# 二. 流迭代器

虽然`iostream`类型不是容器，但标准库定义了可以用于这些 IO 类型对象的迭代器。`istream_iterator`读取输入流；`ostream_iterator`向一个输出流写数据。这些迭代器将它们对应的流当作一个特定类型的元素序列来处理。通过使用流迭代器，我们可以用泛型算法从流对象读取数据以及向其写入数据。

## 1. istream_iterator 操作

| 操作                           | 描述                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| `istream_iterator<T> in(is)`   | `in`从输入流`is`读取类型为`T`的值                            |
| `istream_iterator<T> end`      | 读取类型为`T`的值的`istream_iterator`迭代器，表示尾后位置    |
| `in1 == in2`<br />`in1 != in2` | `in1`和`in2`必须读取相同类型。如果它们都是尾后迭代器，或绑定到相同的输入，则两者相等 |
| `*in`                          | 返回从流中读取的值                                           |
| `in->mem`                      | 与`(*in).mem`的含义相同                                      |
| `++in`，`in++`                 | 使用元素类型所定义的`>>`运算符从输入流中读取下一个值。<br />与以往一样，前置版本返回一个指向递增后迭代器的引用，后置版本返回旧值 |

我们可以从一个`istream`获取迭代器来作为参数传递给其他函数：
```c++
istream_iterator<int> in_iter(cin), eof;
vector<int> vec(in_iter, eof);
```

在上例中，将从迭代器给出的范围构造`vec`。这个操作是从`cin`中读取数据，直至遇到文件尾或者遇到一个不是`int`的数据为止。从流中读取的数据被用来构造`vec`。

****

**使用算法操作流迭代器**：

由于算法使用迭代器操作来处理数据，而流迭代器又至少支持某些迭代器操作，因此我们至少可以用某些算法来操作流迭代器。

如下所示，我们可以用一对`istream_iterator`来调用`accumulate`：

```c++
istream_iterator<int> in(cin), eof;
cout << accumulate(in, eof, 0) << endl;
```

此调用会计算出从标准输入读取的值的和。

****

**istream_iterator 允许使用懒惰求值**：

当我们将`istream_iterator`绑定到一个流时，标准库并不保证迭代器立即从流中读取数据。具体实现可以推迟从流中读取数据，直到我们使用迭代器时才真正读取。标准库中的实现所保证的是，在我们第一次解引用迭代器之前，从流中读取数据的操作已经完成了。对于大多数程序来说，立即读取还是推迟读取没什么差别。但是，如果我们创建了一个`istream_iterator`，没有使用就销毁了，或者我们正在从两个不同的对象同步读取同一个流，那么何时读取可能就很重要了。



## 2. ostream_iterator 操作

| 操作                             | 描述                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| `ostream_iterator<T> out(os)`    | `out`将类型为`T`的值写到输出流`os`中                         |
| `ostream_iterator<T> out(os, d)` | `out`将类型为`T`的值写到输出流`os`中，每个值后面都输出一个`d`。`d`指向一个空字符结尾的字符数组 |
| `out = val`                      | 用`<<`运算符将`val`写入到`out`所绑定的`ostream`中。`val`的类型必须与`out`可写的类型兼容 |
| `*out`，`++out`，`out++`         | 这些运算符是存在的，但不对`out`做任何事情。每个运算符都返回`out` |

与`istream_iterator`操作不同的是，必须将`ostream_iterator`绑定到一个指定的流，不允许空的或表示尾后位置的`ostream_iterator`。

我们可以用`ostream_iterator`来输出值的序列：

```c++
ostream_iterator<int> out_iter(cout, " ");
for (auto e : vec)
    *out_iter++ = e;
cout << endl;
```

每一次执行`*out_iter++ = e`的时候，都可能直接将内容刷新到与`cout`关联的设备，也可能将其写入缓冲区，在最后添加一个`cout << endl`既可以添加一个换行，同时将缓冲区中的内容刷新出来。

****

**使用流迭代器处理类类型**：

我们可以为任何定义了输入运算符（`>>`）的类型创建`istream_iterator`对象。类似的，只要类型有输出运算符（`<<`），我们就可以为其定义`ostream_iterator`。

所以我们可以像下面这样使用：

```c++
istream_iterator<Sales_item> item_iter(cin), eof;
ostream_iterator<Sales_item> out_iter(cout, "\n");
Sales_data sum = *item_iter++;
while (item_iter != eof) {
    if (item_iter->isbn() == sum.isbn())
        sum += *item_iter++;
    else {
        out_iter = sum;
        sum = *item_iter++;
    }
}
out_iter = sum;
```



# 三. 反向迭代器

反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器，递增（以及递减）操作的含义会颠倒过来。

递增一个反向迭代器（`++iter`）会移动到前一个元素；递减一个迭代器（`--iter`）会移动到下一个元素。

除了`forward_list`之外，其他容器都支持反向迭代器。我们可以通过调用`rbegin`、`rend`、`crbegin`和`crend`成员函数来获得反向迭代器。这些成员函数返回指向容器尾元素和首元素之前一个位置的迭代器。与普通迭代器一样，反向迭代器也有`const`和非`const`版本。

下面的循环是一个使用反向迭代器的例子，它按逆序打印`vec`中的元素：

```c++
vector<int> vec = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
for (auto r_iter = vec.crbegin(); r_iter != vec.crend(); ++r_iter)
    cout << *r_iter << endl;
```

****

**反向迭代器与其他迭代器间的关系**：

假定有一个名为`line`的`string`，保存着一个逗号分隔的单词列表。

如果我们希望打印出`line`中的第一个单词，使用`find`可以很容易完成这一任务：

```c++
auto comma = find(line.cbegin(), line.cend(), ',');
cout << string(line.cbegin(), comma) << endl;
```

如果`line`中有逗号，那么`comma`将指向这个逗号；否则，它将等于`line.cend()`。当我们打印从`line.begin()`到`comma`之间的内容时，将打印到逗号为止的字符，或者打印整个`string`（如果其中不含逗号）。

而如果我们希望打印最后一个单词，可以改用反向迭代器：

```c++
auto rcomma = find(line.crbegin(), line.crend(), ',');
```

如果`line`中有逗号，则`rcomma`指向最后一个逗号，否则它将指向`line.crend()`。

找到这个逗号的位置之后，如果我们试图直接打印找到的单词，将会出现下面的情况：

```c++
cout << string(line.crbegin(), rcomma) << endl;
```

如果此时的输入如下：

```c++
FIRST, MIDDLE, LAST
```

则这条语句会打印`TSAL`。

这是因为我们使用的是反向迭代器，将从最后一个字符开始给临时量赋值。所以我们不能直接使用`rcomma`，我们需要做的是，**将`rcomma`转换为一个普通迭代器**，我们通过调用`reverse_iterator`的`base`成员函数来完成这一转换，此成员函数会返回其对应的普通迭代器：

```c++
cout << string(rcomma.base(), line.cend()) << endl;
```

**需要注意的是**：在`base`将反向迭代器转换为普通迭代器之后，所得到的普通迭代器相对于反向迭代器向后移动了一个位置，所以上例不会打印`, LAST`
