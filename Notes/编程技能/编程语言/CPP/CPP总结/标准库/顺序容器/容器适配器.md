# 一. 简介

**适配器**（adaptor）是标准库中的一个通用概念。它是一种机制，能使某种事物的行为看起来像另外一种事物一样。

如果不能理解，可以简单地把它们也当作一个类模板，在实例化时需要接受一个类型作为参数。但它不像`vector`、`list`这些类模板一样接受一个类型作为元素类型，而是接受一个类型将其当作自己的实现方法，如接受一个容器类型然后让其看起来像另一个容器类型。

在顺序容器中，标准库定义了三个顺序容器适配器：`stack`（栈）、`queue`（队列）和`priority_queue`（优先队列）。

向下，它们都接受一个已有的顺序容器类型（`array`和`forward_list`除外）作为它们实现的方法；向上，不论给予它们的类型参数是什么，它们一直提供不变的接口。



# 二. 定义一个适配器

## 1. 默认实现类型

默认情况下：

- `stack`：基于`deque`实现
- `queue`：基于`deque`实现
- `priority_queue`：基于`vector`实现

如：

假设`deq`是一个`deque<int>`类型，用`deq`初始化`stk`：

```c++
stack<int> stk(deq);
```

其中`stack`只提供一个元素类型参数来构建`stack`类型，所以`stack`是默认基于`deque`实现的。



## 2. 限制的类型

我们可以在创建一个适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型，其中每种适配器限制的底层容器类型如下：

- `stack`：可以用除`array`和`forward_list`之外的任何容器类型来构造`stack`
- `queue`：可以构造于`list`或`deque`之上，但不能基于`vector`构造
- `priority_queue`：可以构造于`vector`或`deque`之上，但不能基于`list`构造

重载一个适配器的默认类型的操作如下：

```c++
stack<string, vector<string>> str_stk;
```

直接在元素类型参数后面添加一个底层容器类型参数即可，需要注意的是提供的参数必须是一个实例化的类型，且元素类型应该和适配器的元素类型相同。



# 三. 适配器类型通用操作和类型

## 1. 类型

| 类型             | 描述                                       |
| ---------------- | ------------------------------------------ |
| `size_type`      | 一种类型，足以保存当前类型的最大对象的大小 |
| `value_type`     | 元素类型                                   |
| `container_type` | 实现适配器的底层容器类型                   |



## 2. 操作

| 操作                          | 描述                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| `A a`                         | 创建一个名为`a`的空适配器                                    |
| `A a(c)`                      | 创建一个名为`a`的适配器，带有容器`c`的一个拷贝               |
| 关系运算符                    | 每个适配器都支持所有关系运算符：`==`、`!=`、`<`、`<=`、`>`和`>=`<br />这些运算符返回底层容器的比较结果 |
| `a.empty()`                   | 若`a`包含任何元素，返回`false`，否则返回`true`               |
| `a.size()`                    | 返回`a`中的元素数目                                          |
| `swap(a, b)`<br />`a.swap(b)` | 交换`a`和`b`两个适配器的内容，`a`和`b`必须有相同类型，包括底层容器类型也必须相同 |



# 四. 独有操作

## 1. 栈适配器

`stack`类型定义在`<stack>`头文件中，其操作如下：

| 操作                                  | 描述                                                         |
| ------------------------------------- | ------------------------------------------------------------ |
| `s.pop()`                             | 删除栈顶元素，但不返回该元素值                               |
| `s.push(item)`<br />`s.emplace(args)` | 创建一个新元素压入栈顶，该元素通过拷贝或移动`item`而来，或者由`args`构造 |
| `s.top()`                             | 返回栈顶元素，但不将栈顶元素弹出栈                           |



## 2. 队列适配器

`queue`和`priority_queue`适配器定义在`<queue>`头文件中，其操作如下：

| 操作                                  | 描述                                                         |
| ------------------------------------- | ------------------------------------------------------------ |
| `q.pop()`                             | 返回`queue`的首元素或`priority_queue`的最高优先级的元素，但不返回此元素 |
| `q.front()`<br />`q.back()`           | 只返回首元素或尾元素，但不删除此元素<br />**（只适用于 queue）** |
| `q.top()`                             | 返回最高优先级元素，但不删除该元素<br />**（只适用于 priority_queue）** |
| `q.push(item)`<br />`q.emplace(args)` | 在`queue`的末尾或`priority_queue`中恰当的位置创建一个元素，其值为`item`，或者由`args`构造 |

****

**注**：

`priority_queue`允许我们为队列中的元素建立优先级。新加入的元素会排在所有优先级比它低的元素之前。

默认情况下，标准库在元素类型上使用`<`运算符来确定相对优先级。

****
