# 一. 简介

任何算法的最基本的特性是它要求其迭代器提供哪些操作。某些算法，如`find`，只要求通过迭代器访问元素、递增迭代器以及比较两个迭代器是否相等这些能力。其他一些算法，如`sort`还要求读、写和随机访问的能力。算法所要求的迭代器操作可以分为 5 个**迭代器类别**（iterator category）。

如下表所示，每个算法都会对它的每个迭代器参数指明须提供哪类迭代器：

| 类别           | 要求                                 |
| -------------- | ------------------------------------ |
| 输入迭代器     | 只读不写；单遍扫描；只能递增         |
| 输出迭代器     | 只写不读；单遍扫描；只能递增         |
| 前向迭代器     | 可读写；多遍扫描；只能递增           |
| 双向迭代器     | 可读写；多遍扫描；可递增递减         |
| 随机访问迭代器 | 可读写；多遍扫描；支持全部迭代器运算 |

除此之外，算法还共享一组参数传递规范和一组命名规范。



# 二. 5 类迭代器

迭代器是按照它们所提供的操作来分类的，这种分类形成了一种层次。除了输出迭代器之外，一个高层类别的迭代器支持低层类别迭代器的所有操作。

C++ 标准指明了范型和数值算法的每个迭代器参数的最小类别。例如，`find`算法在一个序列上进行一遍扫描，对元素进行只读操作，因此至少需要输入迭代器。`replace`函数需要一对迭代器，至少是前向迭代器。类似的，`replace_copy`的前两个迭代器参数也要求至少是前向迭代器。其第三个迭代器表示目的位置，必须至少是输出迭代器。其他的例子类似。对每个迭代器参数来说，其能力必须与规定的最小类别至少相当。向算法传递一个能力更差的迭代器会产生错误。

## 1. 输入迭代器

**输入迭代器**（input iterator）：可以读取序列中的元素。

一个输入迭代器必须支持：

- 用于比较两个迭代器的相等和不相等运算符（`==`、`!=`）
- 用于推进迭代器的前置和后置递增运算（`++`）
- 用于读取元素的解引用运算符（`*`）；解引用只会出现在赋值运算符的右侧
- 箭头运算符（`->`），等价于（`(*it).member`），即，解引用迭代器，并提取对象的成员

输入迭代器只用于顺序访问。对于一个输入迭代器，`*it++`保证是有效的，但递增它可能导致所有其他指向流的迭代器失效。因此，输入迭代器只能用于单遍扫描算法。

`istream_iterator`是一种输入迭代器。



## 2. 输出迭代器

**输出迭代器**（output iterator）：可以看作输入迭代器功能上的补集——只写而不读元素。输出迭代器必须支持：

- 用于推进迭代器的前置和后置递增运算（`++`）
- 解引用运算符（`*`），只出现在赋值运算符的左侧（向一个已经解引用的输出迭代器赋值，就是将值写入它所指向的元素）

我们只能像一个输出迭代器赋值一次。类似于输入迭代器，输出迭代器只能用于单遍扫描算法。用作目的位置的迭代器通常都是输出迭代器。

`ostream_iterator`也是输出迭代器



## 3. 前向迭代器

**前向迭代器**（`forward iterator`）：可以读写元素。这类迭代器只能在序列中沿一个方向移动。

前向迭代器支持所有输入和输出迭代器的操作，而且可以多次读写同一个元素。因此，我们可以保存前向迭代器的状态，使用前向迭代器的算法可以对序列进行多遍扫描。

`forward_list`上的迭代器是前向迭代器



## 4. 双向迭代器

**双向迭代器**（bidirectional iterator）：可以正向/反向读写序列中的元素。除了支持所有前向迭代器的操作之外，双向迭代器还支持前置和后置递减运算符（`--`）。

除了`forward_list`之外，其他标准库都提供符合双向迭代器要求的迭代器



## 5. 随机访问迭代器

**随机访问迭代器**（`random-access iterator`）：提供在常量时间内访问序列中任意元素的能力。

此类迭代器支持双向迭代器的所有功能，并支持以下操作：

- 用于比较两个迭代器相对位置的关系运算符（`<`、`<=`、`>`和`>=`）
- 迭代器和一个整数值的加减运算（`+`、`+=`、`-`和`-=`），计算结果是迭代器在序列中前进（或后退）给定整数个元素后的位置
- 用于两个迭代器上的减法运算符（`-`），得到两个迭代器的距离
- 下标运算符（`iter[n]`），与`*(iter[n])`等价

`array`、`deque`、`string`和`vector`的迭代器都是随机访问迭代器，用于访问内置数组元素的指针也是。



# 三. 算法形参模式

在任何其他算法分类之上，还有一组参数规范。

大多数算法具有如下 4 种形式之一：

```c++
alg(beg, end, other args);
alg(beg, end, dest, other args);
alg(beg, end, beg2, other args);
alg(beg, end, beg2, end2, other args);
```

其中`alg`是算法的名字，`beg`和`end`表示算法所操作的输入范围。几乎所有算法都接受一个输入范围，是否有其他参数依赖于要执行的操作。

## 1. 接受单个目标迭代器的算法

`dest`参数是一个表示算法可以写入的目的位置的迭代器。算法假定（`assume`）：按其需要写入数据，不管写入多少个元素都是安全的。

如果`dest`是一个直接指向容器的迭代器，那么算法将输出数据写到容器中已存在的元素内。更常见的情况是，`dest`被绑定到一个插入迭代器或是一个`ostream_iterator`。插入迭代器将新元素添加到容器中，因而保证空间是足够的。`ostream_iterator`会将数据写入到一个输出流，同样不管要写入多少个元素都没有问题。


## 2. 接受第二个输入序列的算法

接受单独的`beg2`或是接受`beg2`和`end2`的算法用这些迭代器表示第二个输入范围。这些算法通常使用第二个范围中的元素与第一个输入范围结合来进行一些运算。

如果一个算法接受`beg2`和`end2`，这两个迭代器表示第二个范围。这类算法接受两个完整指定的范围：$[beg,\ end)$ 表示的范围和 $[beg2,\ end2)$ 表示的第二个范围。

只接受单独的`beg2`（不接受`end2`）的算法将`beg2`作为第二个输入范围中的首元素。此范围的结束位置位指定，这些算法假定从`beg2`开始的范围与`beg`和`end`所表示的范围至少一样大。



# 四. 算法命名规范

除了参数规范，算法还遵循一套命名和重载规范。

## 1. 一些算法使用重载形式传递一个谓词

接受谓词参数来代替`<`或`==`运算符的算法，以及那些不接受额外参数的算法，通常都是重载的函数。函数的一个版本用元素类型的运算符来比较元素；另一个版本接受一个额外谓词参数，来代替`<`或`==`：

```c++
unique(beg, end);
unique(beg, end, comp);
```



## 2. _if 版本的算法

接受一个元素值的算法通常有另一个不同名的版本，该版本接受一个谓词代替元素值。接受谓词参数的算法都有附加的`_if`前缀：

```c++
find(beg, end, val);
find_if(beg, end, pred);		// 查找第一个令 pred 为真的元素
```



## 3. 拷贝元素的版本

默认情况下，重排元素的算法将重排后的元素写回给定的输入序列中。这些算法还提供另一个版本，将元素写到一个指定的输出目的位置。

写到额外目的空间的算法都在名字后面附加一个`_copy`：

```c++
reverse(beg, end);
reverse_copy(beg, end, dest);		// 将元素按逆序拷贝到 dest
```

一些算法同时提供`_copy`和`_if`版本。这些版本接受一个目的位置迭代器和一个谓词：

```c++
remove_if(v1.begin(), v1.end(),
         [](int i) { return i % 2; });
remove_copy_if(v1.begin(), v1.end(), back_inserter(v2),
              [](int i) { return i % 2; });
```

