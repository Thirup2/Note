# 一. 只读算法

一些算法只会读取其输入范围内的元素，而从不改变元素。

主要有`find`、`count`和`accumulate`等算法。其中`accumulate`定义在头文件`<numeric>`中，它接受三个参数，前两个指出了需要求和的元素的范围，第三个参数是和的初值。假定`vec`是一个整数序列，则：

```c++
int sum = accumulate(vec.cbegin(), vec.cend(), 0);
```

这条语句将`sum`设置为`vec`中元素的和，和的初值被设置为 0。

`accumulate`的第三个参数的类型决定了函数中使用哪个加法运算符以及返回值的类型。

## 1. 算法和元素类型

`accumulate`将第三个参数作为求和起点，这蕴含着一个编程假定：将元素类型加到和的类型上的操作必须是可行的。即序列中元素的类型必须与第三个参数匹配，或者能够转换为第三个参数的类型。

对于`string`来说，我们应该显式创建一个`string`，不能传入一个`const char *`，因为`const char *`并没有`+`运算符，此调用将产生编译错误。



## 2. 迭代器类型的选择

对于只读取而不改变元素的算法，通常最好使用`cbegin()`和`cend()`。但是，如果你计划使用算法返回的迭代器来改变元素的值，就需要使用`begin()`和`end()`的结果作为参数。



## 3. 操作两个序列的算法

另一个只读算法是`equal`，用于确定两个序列是否保存相同的值。它将第一个序列中的每个元素于第二个序列中的对应元素进行比较。如果所有对应元素都相等，则返回`true`，否则返回`false`。此算法接受三个迭代器：前两个表示第一个序列中的元素范围，第三个表示第二个序列的首元素：

```c++
equal(roster1.cbegin(), roster1.cend(), roster2.cbegin());
```

由于`equal`利用迭代器完成操作，因此我们可以通过调用`equal`来比较两个不同类型的容器中的元素。而且，元素类型也不必一样，只要我们能用`==`来比较两个元素类型即可。例如，在此例中，`roster1`可以是`vector<string>`，而`roster2`是`list<const char*>`

但是，`equal`基于一个非常重要的假设：它假定第二个序列至少于第一个序列一样长。此算法要处理第一个序列中的每个元素，它假定每个元素在第二个序列中都有一个与之对应的元素。

实际上，那些只接受一个但一迭代器来表示第二个序列的算法，都假定第二个序列至少于第一个序列一样长。



# 二. 写容器元素的算法

一些算法将新值赋予序列中的元素。当我们使用这类算法时，必须注意确保序列原大小至少不小于我们要求算法写入的元素数目。

即我们需要确保通过迭代器传入的范围其中不能有一个位置是无效的。

例如，算法`fill`接受一对迭代器表示一个范围，还接受一个值作为第三个参数。`fill`将给定的这个值赋予输入序列中的每个元素：

```c++
fill(vec.begin(), vec.end(), 0);
```

由于`fill`向给定输入序列中写入数据，因此，只要我们传递了一个有效的输入序列，写入操作就是安全的。



## 1. 算法不检查写操作

一些算法接受一个迭代器来指出一个单独的目的位置，这些算法将新值赋予一个序列中的元素，该序列从目的位置迭代器指向的元素开始。例如，函数`fill_n`接受一个单迭代器、一个计数值和一个值，它将给定值赋予迭代器指向的元素开始的指定个元素。我们可以用`fill_n`将一个新值赋予`vector`中的元素：

```c++
vector<int> vec;
fill_n(vec.begin(), vec.size(), 0);		// 将所有元素重置为 0
```

上面的调用相当于什么也没做，但它是安全的，不会产生什么问题。

而类似于下面的调用：

```c++
fill_n(dest, n, val);
```

如果`n`的值大于`vec.size()`，那么程序将会产生错误。



## 2. back_inserter

一种保证算法有足够元素空间来容纳输出数据的方法是使用**插入迭代器**（inserter）。插入迭代器是一种向容器中添加元素的迭代器。通常情况，当我们通过一个迭代器向容器元素赋值时，值被赋予迭代器指向的元素。而当我们通过一个插入迭代器赋值时，一个与赋值号右侧值相等的元素被添加到容器中。

可以像下面一样获取一个插入迭代器：

```c++
vector<int> vec;
auto it = back_inserter(vec);
*it = 42;
```

我们常常使用`back_inserter`来创建一个迭代器，作为算法的目的位置来使用。例如：

```c++
vector<int> vec;
fill_n(back_inserter(vec), 10, 0);
```

在每步迭代中，`fill_n`向给定序列的一个元素赋值。由于我们传递的参数是`back_inserter`返回的迭代器，因此每次赋值都会在`vec`上调用`push_back`。最终，这条`fill_n`调用语句向`vec`的末尾添加了 10 个元素，每个元素的值都是 0。



## 3. 拷贝算法

拷贝算法是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法。此算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置。此算法将输入范围中的元素拷贝到目的序列中。传递给`copy`的目的序列至少要包含与输入序列一样多的元素，这一点很重要。

如：

```c++
int a1[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
int a2[sizeof(a1)/sizeof(*a1)];
auto ret = copy(begin(a1), end(a1), a2);
```

`copy`返回的是其目的位置迭代器（递增后）的值。即`ret`恰好指向拷贝到`a2`的尾元素之后的位置。

多个算法都提供其自身的 “拷贝” 版本。这些算法本身的功能可能会更改原序列中的内容，但其 “拷贝” 版本在此基础上还会保存原序列的内容。

例如，`replace`算法读入一个序列，并将其所有等于给定值的元素都改为另一个值。此算法接受 4 个参数：前两个是迭代器，表示输入序列，后两个一个是要搜索的值，另一个是新值。它将所有等于第一个值的元素替换为第二个值：

```c++
replace(ilst.begin(), ilst.end(), 0, 42);
```

此调用将序列中所有的 0 都替换为 42。如果我们希望保留原序列不变，可以调用`replace_copy`。此算法接受额外第三个迭代器参数，指出调整后序列的保存位置：

```c++
replace_copy(ilst.cbegin(), ilst.cend(), back_inserter(ivec), 0, 42);
```

此调用后，原来的`ilst`不变，但是执行了`replace`操作之后的序列保存到`ivec`中了。



# 三. 排序算法

某些算法会重排容器中元素的顺序，一个明显的例子是`sort`。调用`sort`会重排输入序列中的元素，使之有序，它是利用元素类型的`<`运算符来实现排序的。

如：

```c++
sort(words.begin(), words.end());
```

这会将两个迭代器的范围内的元素按照顺序排好，如果有重复元素，那么它们应该是相邻的。



## 1. 使用 unique

`words`排序完毕后，如果我们需要每个单词只保存一次，使用`unique`算法重排输入序列，将相邻的重复项 “消除”，并返回一个指向不重复值范围末尾的迭代器。

如：

```c++
auto end_unique = unique(words.begin(), words.end());
```

需要注意的是，`words`的大小并未改变，但这些元素的顺序被改变了，多余的重复元素被移动到了序列的最后。

`unique`返回的迭代器指向最后一个不重复元素之后的位置。此位置之后的元素仍然存在，但我们不知道它们的值是什么。



## 2. 使用容器操作删除元素

为了真正地删除无用元素，我们必须使用容器操作。本例中使用`erase`。

我们删除从`end_unique`开始直至`words`末尾的范围内的所有元素，如：

```c++
words.erase(end_unique, words.end());
```

值得注意的是，即使`words`中没有重复单词，这样调用`erase`也是安全的。在此情况下，`unique`会返回`words.end()`。因此，传递给`erase`的两个参数具有相同的值：`words.end()`。迭代器相等意味着传递给`erase`的元素范围为空。删除一个空范围没有什么不良后果，因此程序即使在输入中无重复元素的情况下也是正确的。
