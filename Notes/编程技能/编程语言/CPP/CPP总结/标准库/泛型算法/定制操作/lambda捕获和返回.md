# 一. 简介

当定义一个`lambda`时，编译器生成一个与`lambda`对应的新的（未命名的）类类型。

当向一个函数传递一个`lambda`时，同时定义了一个新类型和该类型的一个对象：传递的参数就是此编译器生成的类类型的未命名对象。类似的，当使用`auto`定义一个用`lambda`初始化的变量时，定义了一个从`lambda`生成的类型的对象。

默认情况下，从`lambda`生成的类都包含一个对应该`lambda`所捕获的变量的数据成员。类似任何普通类的数据成员，`lambda`的数据成员也在`lambda`对象创建时被初始化。



# 二. 捕获方式

类似参数传递，变量的捕获方式也可以是值或引用。下表列出了几种不同的构造捕获列表的方式：

| 方式                   | 描述                                                         |
| ---------------------- | ------------------------------------------------------------ |
| `[]`                   | 空捕获列表。`lambda`不能使用所在函数中的变量。<br />一个`lambda`只有捕获变量后才能使用它们 |
| `[names]`              | `names`是一个逗号分隔的名字列表，这些名字都是`lambda`所在函数的局部变量。<br />默认情况下，捕获列表中的变量都被拷贝。名字前如果使用了`&`，则采用引用捕获方式 |
| `[&]`                  | 隐式捕获列表，采用引用捕获方式。<br />`lambda`体中所使用的来自所在函数的实体都采用引用方式使用 |
| `[=]`                  | 隐式捕获列表，采用值捕获方式。<br />`lambda`体将拷贝所使用的来自所在函数的实体的值 |
| `[&, identifier_list]` | `identifier_list`是一个逗号分隔的列表，包含 0 个或多个来自所在函数的变量。<br />这些变量采用值捕获方式，而任何隐式捕获的变量都采用引用方式捕获。<br />`identifier_list`中的名字前面不能使用`&` |
| `[=, identifier_list]` | `identifier_list`中的变量都采用引用方式捕获，而任何隐式捕获的变量都采用值方式捕获。<br />`identifier_list`中的名字不能包括`this`，且这些名字之前必须使用`&` |



## 1. 值捕获

与传值参数类似，采用值捕获的前提是变量可以拷贝。与参数不同，被捕获的变量的值是在`lambda`创建时拷贝，而不是调用时拷贝：

```c++
void fcn1()
{
    size_t v1 = 42;
    auto f = [v1] { return v1; };
    v1 = 0;
    auto j = f();
}
```

由于被捕获变量的值是在`lambda`创建时拷贝，因此随后对其修改不会影响到`lambda`内对应的值。



## 2. 引用捕获

我们定义`lambda`时可以采用引用方式捕获变量，例如：

```c++
void fcn2()
{
    size_t v1 = 42;
    auto f2 = [&v1] { return v1; };
    v1 = 0;
    auto j = f2();
}
```

`v1`之前的`&`指出`v1`应该以引用方式捕获。一个以引用方式捕获的变量与其他任何类型的引用的行为类似。

引用捕获与返回引用有着相同的问题和限制。如果我们采用引用的方式捕获一个变量，就必须确保被引用的对象在`lambda`执行的时候是存在的。`lambda`捕获的都是局部变量，这些变量在函数结束后就不复存在了。如果`lambda`可能在函数结束后执行，捕获的引用指向的局部变量已经消失。

引用捕获有时是必要的。例如，我们可能希望`biggies`函数接受一个`ostream`的引用，用来输出数据，并接受一个字符作为分隔符：

```c++
void biggies(vector<string> &words, vector<string>::size_type sz, ostream &os = cout, char c = ' ')
{
    for_each(words.begin(), words.end(),
            [&os, c](const string &s) { os << s << c; });
}
```

我们不能拷贝`ostream`对象，因此捕获`os`的唯一方法就是捕获其引用（或指向`os`的指针）。



## 3. 隐式捕获

除了显式列出我们希望使用的来自所在函数的变量之外，还可以让编译器根据`lambda`体中的代码来推断我们要使用哪些变量。为了指示编译器推断捕获列表，应在捕获列表中写一个`&`或`=`。`&`告诉编译器采用引用捕获方式，`=`表示采用值捕获方式。

如果我们希望对一部分变量采用值捕获，对其他变量采用引用捕获，可以混合使用隐式捕获和显式捕获：

```c++
void biggies(vector<string> &words, vector<string>::size_type sz, ostream &os = cout, char c = ' ')
{
    for_each(words.begin(), words.end(),
            [&, c](const string &s)
             { os << s << c; });
    for_each(words.begin(), words.end(),
            [=, c](const string &s)
             { os << s << c; });
}
```

当我们混合使用隐式捕获和显式捕获时，捕获列表中的第一个元素必须是一个`&`或`=`。此符号指定了默认捕获方式为引用或值。

当混合使用隐式捕获和显式捕获时，**显式捕获的变量必须使用与隐式捕获不同的方式**。



# 四. 可变lambda

默认情况下，对于一个值被拷贝的变量，`lambda`不会改变其值。如果我们希望能改变一个被捕获的变量的值，就必须在参数列表首加上关键字`mutable`。因此，可变`lambda`能省略参数列表：

```c++
void fcn3()
{
    size_t v1 = 42;
    auto f = [v1] () mutable { return ++v1; };
    v1 = 0;
    auto j = f();
}
```

一个引用捕获的变量是否（如往常一样）可以修改依赖于此引用指向的是一个`const`类型还是一个非`const`类型：

```c++
void fcn4()
{
    size_t v1 = 42;
    auto f2 = [&v1] { return ++v1; };
    v1 = 0;
    auto j = f2();
}
```



# 五. 指定 lambda 返回类型

默认情况下，如果一个`lambda`只包含一个`return`语句，则根据`return`的值判断返回类型；如果一个`lambda`体包含`return`之外的任何语句，则编译器假定此`lambda`返回`void`。与其他返回`void`的函数类似，被推断返回`void`的`lambda`不能返回值。

如，我们使用标准库`transform`算法和一个`lambda`来将一个序列中的每个负数替换为其绝对值：

```c++
transform(vi.begin(), vi.end(), vi.begin(),
         [](int i)
          { return i < 0 ? -i : i; });
```

函数`transform`接受三个迭代器和一个可调用对象。前两个迭代器表示输入序列，但三个迭代器表示目的位置。算法对输入序列中每个元素调用可调用对象，并将结果写入到目的位置。

目的位置迭代器与表示输入序列开始位置的迭代器可以是相同的。当输入迭代器和目的迭代器相同时，`transform`将输入序列中每个元素替换为可调用对象操作该元素得到的结果。

上例中，程序可以根据条件运算符的类型推断出返回类型，但是，如果我们将程序写为看起来是等价的`if`语句，就会产生编译错误：

```c++
transform(vi.begin(), vi.end(), vi.begin(),
         [](int i)
          { if (i < 0) return -i; else return i; });
```

编译器推断这个版本的`lambda`返回类型为`void`，但它返回了一个`int`值。

****

当我们需要为一个`lambda`定义返回类型时，必须使用尾置返回类型：

```c++
transform(vi.begin(), vi.end(), vi.begin(),
         [](int i) -> int
          { if (i < 0) return -i; else return i; });
```

在此例中，传递给`transform`的第四个参数是一个`lambda`，它的捕获列表是空的，接受单一的`int`参数，返回一个`int`值。它的函数体是一个返回其参数的绝对值的`if`语句。