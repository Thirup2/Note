# 一. 简介

对于那种只在以两个地方使用的简单操作，`lambda`表达式是最有用的。如果我们需要在很多地方使用相同的指针，通常应该定义一个函数，而不是多次编写相同的`lambda`表达式。类似的，如果一个操作需要很多语句才能完成，通常使用函数更好。

如果`lambda`的捕获列表为空，通常可以用函数来代替它。但是，对于捕获局部变量的`lambda`，用函数来替换它就不是那么容易了。例如，我们用在`find_if`调用中的`lambda`比较一个`string`和一个给定大小。我们可以很容易地编写一个完成同样工作的函数：

```c++
bool check_size(const string &s, string::size_type sz)
{
    return s.size() >= sz;
}
```

但是，我们不能用这个函数作为`find_if`的一个参数。如前文所示，`find_if`接受一个一元谓词，因此传递给`find_if`的可调用对象必须接受单一参数。`biggies`传递给`find_if`的`lambda`使用捕获列表来保存`sz`。为了用`check_size`来代替此`lambda`，必须解决如何向`sz`形参传递一个参数的问题。


# 二. bind 函数

我们可以解决向`check_size`传递一个长度参数的问题，方法是使用一个新的名为`bind`的标准库函数，它定义在头文件`<functional>`中。

可以将`bind`函数看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来 “适应” 原对象的参数列表。

调用`bind`的一般形式为：

```c++
auto newCallable = bind(callable, arg_list);
```

其中，`newCallable`本身是一个可调用对象，`arg_list`是一个逗号分隔的参数列表，对应给定的`callable`的参数。即，当我们调用`newCallable`时，`newCallable`会调用`callable`，并传递给它`arg_list`中的参数。

`arg_list`中的参数可能包含形如`_n`的名字，其中`n`是一个整数。这些参数是 “占位符”，表示调用`newCallable`**我们需要给出的参数**，它们占据了传递给`newCallable`的参数的 “位置”。数值`n`表示生成的可调用对象中参数的位置：`_1`为`newCallable`的我们需要给出的第一个参数，`_2`为第二个参数，以此类推。

而`arg_list`中其他的没有以`_n`形式给出的名字，就是调用后会默认传递给`callable`的参数，不需要由我们给出。

`arg_list`中所有的参数按照给出的顺序依次传递给`callable`。

****

**示例**：绑定 check_size 的 sz 参数

作为一个简单的例子，我们将使用`bind`生成一个调用`check_size`的对象，如下所示：

```c++
auto check6 = bind(check_size, _1, 6);
```

此`bind`调用只有一个占位符，表示`check6`只接受单一参数。占位符出现在`arg_list`的第一个位置，表示`check6`的此参数对应`check_size`的第一个参数。此参数是一个`const string &`。因此，调用`check6`必须传递给它一个`string`类型的参数，`check6`会将此参数传递给`check_size`

即如果我们调用`check6(s)`，那么实际上会调用`check_size(s, 6)`。

使用`bind`，我们可以将原来基于`lambda`的`find_if`调用替换为如下使用`check_size`的版本：

```c++
auto wc = find_if(words.begin(), words.end(),
                 bind(check_size, _1, sz));
```

此`bind`调用生成一个可调用对象，将`check_size`的第二个参数绑定到`sz`的值。当`find_if`对`words`中的`string`调用这个对象时，这些对象会调用`check_size`，将给定的`string`和`sz`传递给它。因此，`find_if`可以有效地对输入序列中每个`string`调用`check_size`，实现`string`的大小与`sz`的比较。



# 三. placeholders 名字

名字`_n`都定义在一个名为`placeholders`的命名空间中，而这个命名空间本身定义在`std`命名空间中。为了使用这些名字，两个命名空间都要写上：

```c++
using std::placeholders::_1;
```

对每个占位符的名字，我们都必须提供一个单独的`using`声明。可以使用另外一种不同形式的`using`语句，而不是分别声明每个占位符，如下所示：

```c++
using namespace namespace_name;
```

这种形式说明希望所有来自`namespace_name`的名字都可以在我们的程序中直接使用。



# 四. bind 的参数

我们可以用`bind`修正参数的值。更一般的，可以用`bind`绑定给定可调用对象中的参数或重新安排其顺序。例如，假定`f`是一个可调用对象，它有 5 个参数，则下面对`bind`的调用：

```c++
auto g = bind(f, a, b, _2, c, _1);
```

生成一个新的可调用对象，它有两个参数，分别用占位符`_2`和`_1`表示。这个新的可调用对象将它自己的参数作为第三个和第五个参数传递给`f`。`f`的第一个、第二个和第四个参数分别被绑定到给定的值`a`、`b`和`c`上。

传递给`g`的参数按位置绑定到占位符。即，第一个参数绑定到`_1`，第二个参数绑定到`_2`。因此，当我们调用`g`时，其第一个参数将被传递给`f`作为最后一个参数，第二个参数将被传递给`f`作为第三个参数。实际上，这个`bind`调用会将：

```c++
g(_1, _2)
```

映射为：

```c++
f(a, b, _2, c, _1)
```

即，对`g`的调用会调用`f`，用`g`的参数代替占位符，再加上绑定的参数`a`、`b`和`c`。例如，调用`g(X, Y)`会调用：

```c++
f(a, b, Y, c, X)
```



# 五. 绑定引用参数

默认情况下，`bind`的那些不是占位符的参数被拷贝到`bind`返回的可调用对象中。但是，与`lambda`类似，有时对有些绑定的参数我们希望以引用方式传递，或是要绑定参数的类型无法拷贝。

例如，为了替换一个引用方式捕获`ostream`的`lambda`：

```c++
for_each(words.begin(), words.end(),
        [&os, c](const string &s) { os << s << c; });
```

可以很容易地编写一个函数，完成相同的工作：

```c++
ostream &print(ostream &os, const string &s, char c)
{
    return os << s << c;
}
```

但是，不能直接用`bind`来代替对`os`的捕获：

```c++
for_each(words.begin(), words.end(), bind(print, os, _1, ' '));
```

原因在与`bind`拷贝其参数，而我们不能拷贝一个`ostream`。如果我们希望传递给`bind`一个对象而又不拷贝它，就必须使用标准库`ref`函数：

```c++
for_each(words.begin(), words.end(), 
        bind(print, ref(os), _1, ' '));
```

函数`ref`返回一个对象，包含给定的引用，此对象是可以拷贝的。标准库中还有一个`cref`函数，生成一个保存`const`引用的类。与`bind`一样，函数`ref`和`cref`也定义在头文件`<functional>`中。