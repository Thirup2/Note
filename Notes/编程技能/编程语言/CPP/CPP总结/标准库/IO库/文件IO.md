# 一. 文件流特有的操作

我们只能对`fstream`、`ifstream`、`ofstream`类型的对象（以及宽字符版本）调用下面的操作，但不能对其他 IO 类型调用这些操作（`fstrm`表示一个文件流类型，不一定是`fstream`类型，`f`表示一个文件流对象）：

| 操作               | 描述                                                         |
| ------------------ | ------------------------------------------------------------ |
| `fstrm f`          | 创建一个未绑定的文件流。此时`f`不可用                        |
| `fstrm f(s)`       | 创建一个文件流类型的对象，打开并为`f`绑定名为`s`的文件。`s`可以是`string`类型，或者是一个指向 C 风格字符串的指针。<br />这些构造函数都是`explicit`的，即不允许隐式转换。<br />默认的文件模式`mode`依赖于`fstrm`的具体选择 |
| `fstrm f(s, mode)` | 与前一个构造函数类似，但按指定`mode`打开文件                 |
| `f.open(s)`        | 打开并为`f`绑定名为`s`的文件。<br />`s`可以是一个`string`或一个指向 C 风格字符串的指针。<br />默认的文件`mode`依赖于`f`的具体类型 |
| `f.close()`        | 关闭与`f`绑定的文件。返回`void`                              |
| `f.is_open()`      | 返回一个`bool`值。<br />指出与`f`关联的文件是否成功打开且尚未关闭 |



# 二. 文件模式

每个文件流都有一个关联的**文件模式**（file mode），用来指出如何使用文件。所有的文件模式和它们的含义如下表所示：

| 文件模式 | 含义                                                         |
| -------- | ------------------------------------------------------------ |
| `in`     | 以读方式打开                                                 |
| `out`    | 以写方式打开，之前的内容会被丢弃；<br />阻止该行为的方式是同时指定`app`模式，或同时指定`in`模式（仅`fstream`对象） |
| `app`    | 每次写操作前均定位到文件末尾                                 |
| `ate`    | 打开文件后立即定位到文件末尾                                 |
| `trunc`  | 截断文件                                                     |
| `binary` | 以二进制方式进行 IO                                          |

## 1. 文件模式的限制

指定文件模式有如下限制：

- 只可以对`ofstream`或`fstream`对象设定`out`模式
- 只可以对`ifstream`或`fstream`对象设定`in`模式
- 只有当`out`也被设定时才可设定`trunc`模式
- 只要`trunc`没被设定，就可以设定`app`模式。设定为`app`模式后，文件默认指定`out`模式
- `ate`和`binary`模式可用于任何类型的文件流对象，且可以与其他任何文件模式组合使用



## 2. 流的默认文件模式

对于输入流（`ifstream`）：默认以`in`文件模式打开；

对于输出流（`ofstream`）：默认以`out`文件模式打开

对于读写流（`fstream`）：默认以`in`和`out`文件模式打开，即`fstream::in | fstream::out`



## 3. 同时指定多个文件模式

同时指定多个文件模式的方法是使用位或（`|`）运算符：

```c++
ofstream out("file1", ofstream::out | ofstream::trunc);
```



# 三. 使用文件流对象

## 1. 基本使用

在创建文件流对象时需要为该对象打开并绑定文件，通过提供待打开的文件名参数（有时还需要文件模式）即可。

如果在创建时不为文件流提供需要绑定的文件，那么该文件流对象暂时是无效的，需要使用`open`函数为对象打开并绑定文件。之后对象变为有效的。

其中文件名可以是一个`string`类型的对象，也可以是 C 风格字符串，如：

```c++
string ifile("file1");

ifstream in(ifile);
ofstream out("file2");
```

下面这两个初始化语句都是正确的。



## 2. 继承的用途

由于`iostream`是`fstream`的基类，`ostream`是`ofstream`的基类，`istream`是`ifstream`的基类，所以在函数中如果出现了`iostream &`、`ostream &`、`istream &`的参数，可以传递该类型对应的派生类（即`fstream`、`ofstream`、`ifstream`类型）作为参数。



## 3. open和close

如果我们定义了一个空文件流对象，可以随后调用`open`来将它与文件关联起来：

```c++
ofstream out;
out.open(ifile + ".copy");		// ifile是一个string对象
```

****

调用`open`失败可能会失败，如：

- 当对一个已经打开的文件流调用`open`会失败，所以为了将文件流关联到另外一个文件，必须首先关闭已经关联的文件。
- 当对一个`ifstream`或`fstream`打开一个不存在的文件时会失败，所以在为这类文件流打开文件时需要确保文件已存在

****

如果调用`open`失败，`failbit`将会被置位，所以我们在调用`open`之后可以检查一下其是否成功：

```c++
ofstream out;
out.open("file");

if(!out) {
    cerr << "打开文件失败" << std::endl;
}
```

****

对于一个循环处理大批文件的程序来说，可以将文件流的创建及初始化放在循环体内：

```c++
for (auto p = argv + 1; p != argv + argc; ++p) {
    ifstream input(*p);
    if (input) {
        process(input);
    } else
        cerr << "couldn't open: " + string(*p);
}
```

这样虽然没有显式调用`close`，但是`input`在后续打开文件时却并不会出错。

因为在块结束时将自动销毁`input`，在块创建时再重新创建`input`。而一个文件流对象被销毁时，会自动调用`close`。