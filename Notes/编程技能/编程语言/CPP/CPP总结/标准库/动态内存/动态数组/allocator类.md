# 一. 简介

`new`有一些灵活性上的局限，其中一方面表现在它将内存分配和对象构造组合在了一起。类似的，`delete`将对象析构和内存释放组合在了一起。我们分配单个对象时，通常希望将内存分配和对象初始化组合在一起。因为在这种情况下，我们几乎肯定知道对象应该有什么值。

当分配一大块内存时，我们通常计划在这块内存上按需构造对象。在此情况下，我们希望将内存分配和对象构造分离。这意味着我们可以分配大块内存，但只有在真正需要时才真正执行对象创建操作（同时付出一定开销）。

一般情况下，将内存分配和对象构造组合在一起可能会导致不必要的浪费，例如：

```c++
string *const p = new string[n];
string s;
string *q = p;
while(cin >> s && q != p + n)
    *q++ = s;
const size_t size = q - p;
delete[] p;
```

`new`表达式分配并初始化了`n`个`string`。但是，我们可能不需要`n`个`string`，少量`string`可能就足够了。这样，我们就可能创建了一些永远也用不到的对象。而且，对于那些确实要使用的对象，我们也在初始化后立即赋予了它们新值。每个使用到的元素都被赋值了两次：第一次是在默认初始化时，随后是在赋值时。

更重要的是，那些没有默认构造函数的类就不能动态分配数组了。



# 二. allocator 类

标准库`allocator`类定义在头文件`<memory>`种，它帮助我们将内存分配和对象构造分离开来。它提供一种类型感知的内存分配方法，它分配的内存是原始的、未构造的。

其操作如下表所示：

| 操作                   | 描述                                                         |
| ---------------------- | ------------------------------------------------------------ |
| `allocator<T> a`       | 定义了一个名为`a`的`allocator`对象，它可以为类型为`T`的对象分配内存 |
| `a.allocate(n)`        | 分配一段原始的、未构造的内存，保存`n`个类型为`T`的对象       |
| `a.deallocate(p, n)`   | 释放从`T*`指针`p`中地址开始的内存，这块内存保存了`n`个类型为`T`的对象；<br />`p`必须是一个先前由`allocate`返回的指针，且`n`必须是`p`创建时所要求的大小。<br />在调用`deallocate`之前，用户必须对每个在这块内存中创建的对象调用`destroy` |
| `a.construct(p, args)` | `p`必须是一个类型为`T*`的指针，指向一块原始内存；<br />`args`被传递给类型为`T`的构造函数，用来在`p`指向的内存中构造一个对象 |
| `a.destroy(p)`         | `p`为`T*`类型的指针，此算法对`p`指向的对象执行析构函数       |

## 1. 创建分配器与分配内存

为了定义一个`allocator`对象，我们必须指明这个`allocator`可以分配的对象类型。当一个`allocator`对象分配内存时，它会根据给定的对象类型来确定恰当的内存大小和对齐位置：

```c++
allocator<string> alloc;
auto const p = alloc.allocate(n);
```

这个`allocate`调用为`n`个`string`分配了内存，这块内存是**未构造的**（unconstructed）。我们按需要在此内存中构造对象。



## 2. 构造

我们通过`construct`成员函数对内存进行构造。它接受一个指针和零个或多个额外参数，在给定位置构造一个元素。

额外参数用来初始化构造的对象。类似`make_shared`的参数，这些额外参数必须是与构造的对象的类型像匹配的合法的初始化器：

```c++
auto q = p;
alloc.construct(q++);
alloc.construct(q++, 10, 'c');
alloc.construct(q++, "hi");
```

在早期版本的标准库中，`construct`只接受两个参数：指向创建对象位置的指针和一个元素类型的值。因此，我们只能将一个元素拷贝到未构造空间中，而不能用元素类型的任何其他构造函数来构造一个元素。



## 3. 使用

还未构造对象的情况下就使用原始内存是错误的。为了使用`allocate`返回的内存，我们必须用`construct`构造对象。使用未构造的内存，其行为是未定义的。



## 4. 销毁

当我们用完对象后，必须对**每个构造的元素**调用`destroy`来销毁它们。函数`destroy`接受一个指针，对指向的对象执行析构函数：

```c++
while (q != p)
    alloc.destroy(--q);
```

我们只能对真正构造了的元素进行`destroy`操作。

一旦元素被销毁后，就可以重新使用这部分内存来保存其他`string`，也可以将其归还给系统。释放内存通过调用`deallocate`来完成：

```c++
alloc.deallocate(p, n);
```

我们传递给`deallocate`的指针不能为空，它必须指向由`allocate`分配的内存。而且，传递给`deallocate`的大小参数必须与调用`allocated`分配内存时提供的大小参数具有一样的值。



# 三. 相关算法

标准库还为`allocator`类定义了两个伴随算法，可以在未初始化内存中创建对象。它们都定义在头文件`<memory>`中，如下表所示：

| 操作                             | 描述                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| `uninitialized_copy(b, e, b2)`   | 从迭代器`b`和`e`指出的输入范围中拷贝元素到迭代器`b2`指定的未构造的原始内存中<br />`b2`指向的内存必须足够大，能容纳输入序列中元素的拷贝 |
| `uninitialized_copy_n(b, n, b2)` | 从迭代器`b`指向的元素开始，拷贝`n`个元素到`b2`开始的内存中   |
| `uninitialized_fill(b, e, t)`    | 在迭代器`b`和`e`指定的原始内存范围中创建对象，对象的值均为`t`的拷贝 |
| `uninitialized_fill_n(b, n, t)`  | 从迭代器`b`指向的内存地址开始创建`n`个对象。<br />`b`必须指向足够大的未构造的原始内存，能够容纳给定数量的对象 |

