# 一. 相同类型不同数量

如果想要传递相同类型不同数量的实参，可以使用`std::initializer_list`的标准库类型，它定义在`<initializer_list>`头文件中，具体细节如下：

## 1. initializer_list类

`initializer_list`是一种标准库类模板，用于表示某种特定类型的值的数组，其操作如下表所示：

| 操作                                    | 描述                                                         |
| --------------------------------------- | ------------------------------------------------------------ |
| `initializer_list<T> lst`               | 默认初始化；`T`类型元素的空列表                              |
| `initializer_list<T> lst{a, b, c, ...}` | `lst`的元素数量和初始值一样多；`lst`的元素是对应初始值的副本；列表中的元素是`const` |
| `lst2(lst)`<br />`lst2 = lst`           | 拷贝或赋值一个`initializer_list`对象**不会拷贝列表中的元素**；<br />拷贝后，原始列表和副本**共享元素** |
| `lst.size()`                            | 列表中的元素数量                                             |
| `lst.begin()`                           | 返回指向`lst`中首元素的指针                                  |
| `lst.end()`                             | 返回指向`lst`中尾元素下一位置的指针                          |



## 2. 用例

```c++
void error_msg(initializer_list<string> il)
{
    for (auto beg = il.begin();beg != il.end(); ++beg)
        cout << *beg << " ";
    cout << endl;
}
```

如果不传递参数，`il`被默认初始化，如果想传递参数，则把需要传递的参数**放在一对花括号中**。

****

除了只传递`initializer_list`形参之外，也可以额外传递其他形参，如：

```c++
void error_msg(ErrCode e, initializer_list<string> il)
{
    cout << e.msg() << ": ";
    for (const auto &elem : il)
        cout << elem << " ";
    cout << endl;
}
```



## 3. 注意

- `initializer_list`是一种模板类型，定义对象时必须说明列表中所含元素的类型
- `initializer_list`对象中的元素永远是常量值，我们无法改变`initializer_list`对象中元素的值
- 当拷贝`initializer_list`对象时，不会拷贝另一个对象的元素，而是和原始列表共享元素，相当于为每个元素定义了一个引用（需要注意不存在引用的数组）



# 二. 省略符形参

省略符形参应该仅仅用于 C 和 C++ 通用的类型，在 C 语言中，使用它之前应该包含`<stdarg.h>`头文件，而 C++ 使用它之前应该包含`<cstdarg>`。

它的使用形式如下：

```c++
void foo(...);
```

如果需要有其他形参，那么省略符形参只能出现在形参列表中的最后一个位置：

```c++
void foo(parm_list, ...);
```

其他的用法请查阅相关的 C 语言文档