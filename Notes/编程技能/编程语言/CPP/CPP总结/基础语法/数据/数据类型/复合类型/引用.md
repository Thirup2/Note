# 一. 简介

**引用**（reference）为对象起了另外一个名字，我们可以把那个名字当作被引用对象本身一样使用，需要注意的是：**引用类型没有实体对象，它仅仅只是一个名字**。

引用类型引用另外一种类型，被引用的类型需要满足一些条件，大部分的类型都是可以被引用的。

引用相当于对指针的封装，可以更方便地操作引用来完成以前花费经历操作指针才能完成的操作。但在学习语言阶段最好不要把引用和指针相互混淆，它们的概念是独立的。引用另外一个优点是可以使函数返回一个左值，也就是在表达式中，函数调用可以放在赋值符的左侧。



# 二. 引用的定义

我们通过`数据类型说明符 + 声明符列表`来声明一个或多个变量，引用也类似，但引用的声明符一定由：`&`符和引用名组成，如：

```c++
int ival = 1024;
int &refVal = ival;
```

中`refVal`就是一个引用，它的声明符由`&`和`refVal`组成。换句话说，每个引用声明符都应该由`&`和引用名组成，如果是一条声明符列表，那么每一个声明符都应该由`&`和引用名组成。如果某个声明符没有`&`符，那么该名字应该是数据类型说明符所表示的类型，而非对数据类型说明符的引用。

另外，由于引用没有实体，在定义引用时，程序把引用和它的初始值**绑定**（bind）在一起，而不是将初始值拷贝给引用。而且一旦初始化完成，引用将和它的初始值对象一直绑定在一起。所以，由于无法令引用重新绑定到另外一个对象，因此**引用必须初始化**。下面这条语句就是一条错误的语句：

```c++
int &refVal;		// 错误：没有初始化引用
```



# 三. 使用引用

定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的：

```c++
refVal = 2;			// refVal 绑定在 ival 上，该语句将 2 赋值给 ival
int ii = refVal;	// 等价于 int ii = ival;
```

由于引用本身不是一个对象，所以**不能定义引用的引用**。如果一个引用对象的初始值也是一个引用，那它们将与同一个对象绑定在一起，如：

```c++
int i = 42;
int &ri = i;
int &rri = ri;
```

其中`ri`和`rri`都将与`i`绑定。

另外，**引用类型只能绑定在与该引用类型的数据类型说明符相同的类型的对象上**。



# 四. 复杂引用类型

## 1. 指向指针的引用

引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用：

```c++
int i = 42;
int *p;
int *&r = p;
```

`r`就是一个对指针的引用，在第 3 行的定义中，`int *`用于指定引用的对象类型，`&`表示`r`是一个引用，所以`r`必须与一个`int *`类型绑定，而`p`是一个`int *`类型。