# 一. 简介

编程时常常需要把表达式的值赋给变量，这就要求在声明变量的时候清楚地知道表达式的类型。然而要做到这一点并非那么容易，有时根本做不到。为了解决这个问题，可以使用`auto`类型说明符，用它就能让编译器替我们去分析表达式所属的类型。

由于`auto`类型需要根据初始值推算变量的类型，所以`auto`**定义的变量必须有初始值**。示例如下：

```c++
auto item = val1 + val2;
```

其中`auto`首先根据`val1 + val2`的计算结果的类型决定`auto`的类型，如果`val1`和`val2`是类`Sales_item`的对象，则`auto`就是`Sales_item`；如果这两个变量的类型是`double`，则`item`的类型就是`double`，以此类推。然后创建对应类型的实体`item`，并用`val1 + val2`的结果为`item`赋值。

**使用**`auto`**也能在一条语句中声明多个变量**，但需要注意，因为一条声明语句只能由一个基本数据类型，所以该语句中**所有变量的初始基本数据类型都必须一样**。



# 二. 复合类型与 auto

## 1. 引用

因为`auto`是根据初始化的表达式的值的类型来推断类型，所以对于引用来说，当引用作为初始值时，实际上真正参与初始化的是引用对象的值，所以如果初始值是一个引用，那么编译器将以引用对象的类型作为`auto`的类型：

```c++
int r = 0;
int &r = i;
auto a = r;			// a 是一个整数，而非整数引用
```

当然，如果我们实在需要一个`auto`推断的引用，那我们可以在声明符前添加一个`&`符号：

```c++
int r = 0;
auto &a = r;		// a 是一个整数引用
```

需要注意的是，如果这里`r`也是一个引用，那么`a`和`r`将与同一个对象绑定在一起。



## 2. 指针

对于指针来说，类型推断就比较简单，如果初始值是一个指针类型，或者是指针字面值以及某个对象的地址，那么此时`auto`就将被推断为指针类型，如：

```c++
int i = 42;
auto p = &i;		// p 是一个整型指针
```

另外，下面这种形式并不会创建一个指向指针的指针：

```c++
int i = 42;
auto *p = &i;		// p 是一个整型指针
```



# 三. 常量与 auto

`auto`一般会忽略掉顶层`const`，同时底层`const`则会保留。

**一般算术类型**：

对于一般的算术类型来说，如果初始值具有`const`属性，则必然是顶层`const`属性，所以`auto`不会保留，即`auto`将不含`const`，如：

```c++
const int ci = 42;
auto i = ci;		// i 是 int 类型，而不是 const int 类型
```

**指针**：

对于指针来说，如果是指针具有顶层`const`属性，则丢弃，如果具有底层`const`属性，则保留，如：

```c++
const int *const pi;
auto p = pi;		// p 是 const int * 类型，而不是 const int *const 或 int *const 类型
```

**引用**：

对于引用，它只可能具有底层`const`属性，且一个顶层`const`的算术类型或指针只能赋给`const`的引用，所以如果初始值具有顶层`const`，则`auto`的引用必须具有底层`const`属性，如：

```c++
const int ci = 42;
const int *const pi = &ci;

auto &rci = ci;		// rci 是一个 const int & 类型
auto &rpi = pi;		// rpi 是一个 const int *const & 类型
```

> 上例中第二个`auto`推断出的类型很难理解，我们来具体分析一下这个类型。首先我们搞清楚初始值的类型：
>
> ```c++
> const int *const pi = &ci;
> ```
>
> 其中第一个`const`赋予`pi`底层`const`属性，第二个`const`赋予`pi`顶层`const`属性。为了方便后续的理解，我们可以这样理解这个指针：
>
> ```c++
> using PCI = const int *;		// PCI 是一个指向常量对象的非常量指针类型
> 
> const PCI pi = &ci;			// pi 原本应该是一个指向常量对象的非常量指针，但 const 赋予了 pi 顶层 const 属性，使其成为了常量指针
> ```
>
> 当我们用`auto`定义一个引用时：
>
> ```c++
> auto &rpi = pi;
> ```
>
> 首先根据规则，一个拥有顶层`const`的初始值需要一个底层`const`的引用进行绑定，同时由于引用不关注初始值的底层`const`属性（或者说在引用的层面初始值只有顶层`const`是对引用可见的，而初始值的底层`const`属性被封装起来了）。所以`auto`应该是一个具有底层`const`属性的引用，其引用的类型是`PCI`类型，即：
>
> ```c++
> const PCI &rpi = pi;
> ```
>
> 注意在这里的`const`是修饰的引用。
>
> 然后我们将`PCI`展开（注意展开后的`PCI`类型和修饰引用的`const`交换了位置），就能得到`rpi`的类型了：
>
> ```c++
> const int *const &rpi = pi;
> ```
>
> 其中第一个`const`是指针本身的底层`const`，第二个`const`是修饰引用的底层`const`。不存在任何顶层`const`属性。

**强制 const**：

可以在`auto`前显式添加`const`来影响类型：

对于一般算术类型和指针等有实体的类型来说，显式添加`const`将为创建的对象添加顶层`const`；对于引用类型来说，显式添加`const`将为创建的对象添加底层`const`属性，如：

```c++
int i = 42;
const auto pi = &i;		// pi 是一个 int *const 类型
const auto &ri = i;		// ri 是一个 const int & 类型
```

