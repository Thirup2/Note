# 一. 简介

有时我们希望定义这样一种变量，它的值不能被改变。例如，用一个变量来表示缓冲区的大小。使用变量的好处是当我们觉得缓冲区大小不再合适时，很容易对其进行调整。。另一方面，也应随时警惕防止程序一不小心改变了这个值。为了满足这一要求，可以用关键字`const`对变量的类型加以限定：

```c++
const int bufSize = 512;
```

这样就把`bufSize`定义成了一个常量，任何试图为`bufSize`赋值的行为都将引发错误。

因为`const`对象一旦创建后其值就不能再改变，所以`const`对象必须初始化。初始值可以是任意复杂的表达式：

```c++
const int i = get_size();
const int j = 42;
```

当以编译时初始化的方式定义一个`const`对象时，编译器将在编译过程中把用到该变量的地方都替换成对应的值，这一操作与宏定义类似。

另外，在默认状态下，`const`**对象仅在文件内有效，即不具有外部链接属性**。如果希望`const`对象拥有外部链接属性，能够被其他文件访问，解决办法是对于`const`变量不管是声明还是定义都添加`extern`关键字，包含初始化的那条声明是定义，在定义语句中的`extern`表示为对象添加外部链接属性，在声明语句中的`extern`表示使用其他文件定义的实体。



# 二. 引用与 const

## 1. 基本形式

可以把引用绑定到`const`对象上，就像绑定到其他对象上一样，我们称之为**对常量的引用**。如：

```c++
const int ci = 1024;
const int &r1 = ci;
```

由于引用实际上是为一个对象取了另外一个名字，所以我们不能通过引用修改被引用对象的值。



## 2. 引用可绑定的对象

另外，在一个引用初始化以及赋值时涉及到引用类型和被引用对象的类型，二者都可能是`const`类型，所以一条初始化有 4 种可能的形式：

```c++
int ival = 24;
const int ci = 1024;

int &ri = ival;		// 1
int &ri = ci;		// 2
const int &rci = ival;	// 3
const int &rci = ci;	// 4
```

其中可行的只有其中 3 种：1、3、4

即：

- 非常量引用只能绑定非常量对象
- 常量引用可以绑定任意对象



## 3. 引用绑定一般表达式

对于一个`const`引用来说，可以将一个一般表达式甚至一个其他类型的对象绑定，如：

```c++
int i = 42;
const int &r1 = i;			// 其他类型对象
const int &r2 = 42;			// 一般表达式
const int &r3 = r1 * 2;			// 一般表达式

double dval = 3.14;
const int &ri = dval;			// 其他类型对象
```

这二者实际是相同的原理：编译器在编译时会添加一个临时的中间量，以`const int &ri = dval;`为例：

```c++
const int temp = dval;		// 首先由双精度浮点数生成一个临时的整型常量
const int &ri = temp;		// 将 ri 与相同类型的 temp 相绑定
```

至于为常量引用绑定一般表达式或其他类型的意义在于函数传递参数时的一些提升。



# 三. 指针与 const

## 1. 基本形式

指针本身是一个对象，所以指针本身也可能存在`const`属性，而指针所指的对象也是实体，所以也可能存在`const`属性。所以一个指针可能有下面 4 种类型：

```c++
int *pi;		// 指向非常量对象的非常量指针
const int *cpi;		// 指向常量对象的非常量指针
int *const pci;		// 指向非常量对象的常量指针
const int *const cpci;	// 指向常量对象的常量指针
```

指向常量对象的指针无法通过指针修改所指对象的值，而常量指针无法修改其指向。如果二者兼具，则两个特性都应该具备。



## 2. 顶层与底层 const

指针本身是一个对象，它又可以指向另外一个对象。这二者都可以有常量类型修饰，我们用下面的概念来区分二者：

- **顶层 const**：表示指针本身是个常量
- **底层 const**：表示指针所指的对象是一个常量

这两个概念可以扩展到更一般的场景，顶层 const 可以表示任意的对象是常量，这一点对任何具有实体的数据类型都适用，如算术类型、类、指针等。底层 const 则与指针和引用等复合类型的基本类型部分有关。

当执行对象的拷贝操作时，常量是顶层 const 还是底层 const 区别明显。其中，顶层 const 不受什么影响，因为执行拷贝操作并不会改变被拷贝对象的值，因此，拷入和拷出的对象是否是常量都没什么影响。另一方面，底层 const 的限制却不能忽略。当执行对象的拷贝操作时，考入和拷出的对象必须具有相同的底层 const 资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换为常量，反之则不行。

**注意**：上述拷贝操作的限制**不适用于引用类型**，请不要在理解引用的拷贝操作上浪费时间。原因是**引用的初始化并非拷贝操作**。也就是说，存在底层 const 限制的拷贝操作只有指针的拷贝操作。



# 四. constexpr 和常量表达式

## 1. 简介

**常量表达式**（const expression）是指值不会改变并且在编译过程就能得到计算结果的表达式。显然，字面值属于常量表达式，用常量表达式初始化的`const`对象也是常量表达式。

需要深入理解常量表达式的定义，否则可能会无法理解下面这个例子：

```c++
const int max_files = 20;		// 是常量表达式
const int limit = max_files + 1;	// 是常量表达式

int dynamic_num;
std::cin >> dynamic_num;
const int some = dynamic_num;		// 不是常量表达式
```

可能会误以为只要是`const`对象就是常量表达式，实际上是否是常量表达式在于一个对象的值是否能在编译过程得到结果，可以思考一下下面的例子是否会得到编译错误：

```c++
int dynamic_num = 4;
const int some = dynamic_num;
constexpr int conex = some;
```

结论是会，因为`some`不是一个常量表达式，它无法在编译时就得到计算结果，这是因为`dynamic_num`无法在编译时就得到计算结果。

从结论上来说，我们可以将常量表达式就当作一个宏定义，它会在编译期就将该表达式替换为其对应的值。

C++ 在某些情况下是要用到常量表达式的，但在一个复杂系统中，很难（几乎肯定不能）分辨一个初始值到底是不是常量表达式。所以 C++ 规定，允许将变量声明为`constexpr`类型以便由编译器来验证变量的值是否是一个常量表达式。声明为`constexpr`的变量一定是一个常量，而且必须用常量表达式初始化，否则将会得到一个编译错误。



## 2. 字面值类型

能够用`constexpr`限定符修饰的类型只能是**字面值类型**（literal type），这些类型一般比较简单，值也显而易见、容易得到。

算术类型、引用和指针都属于字面值类型；而一些自定义类型、IO 库、string 类型则不属于字面值类型，也就不能被定义成`constexpr`。



## 3. 指针和 constexpr

对于指针来说，一个`constexpr`指针的初始值必须是`nullptr`或者 0，或者是存储于某个固定地址中的对象。通常函数体内定义的变量并非存放在固定地址中，因此`constexpr`指针不能指向这样的变量。而定义在所有函数体之外的对象其地址固定不变，能用来初始化`constexpr`指针。另外，函数还能定义一类有效范围超出函数本身的变量，这类变量和定义在函数体之外的变量一样也有固定地址，因此`constexpr`引用能绑定到这样的变量上，`constexpr`指针也能指向只羊的变量。

另外，如果在`constexpr`声明中定义了一个指针，限定符`constexpr`仅对指针本身有效，与指针所指的对象无关，如：

```c++
const int *p = nullptr;		// p 是一个指向常量对象的非常量指针
constexpr int *q = nullptr;	// q 是一个指向非常量对象的常量指针
```

