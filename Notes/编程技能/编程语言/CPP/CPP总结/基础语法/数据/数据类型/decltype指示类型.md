# 一. 简介

有时会遇到这种情况：希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。`decltype`这个类型说明符就能满足这一要求。它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值：

```c++
decltype(f()) sum = x;
```

在上例中，`decltype`分析`f()`这个表达式的类型，这是一个函数，编译器在分析时并不实际调用函数`f()`，而是使用当调用发生时`f()`的返回值类型作为`sum`的类型。`f()`函数的类型就是其返回值类型，如果`f()`的返回类型是`int`，则`decltype`返回`int`类型。



# 二. 常量与 decltype

`decltype`和`auto`不同，它不会忽略顶层`const`，如：

```c++
int i = 42;
const int ci = i;

int *const cpi = &i;
const int *pci = &ci;
const int *const cpci = &ci;
const int &cj = ci;

decltype(ci) some = ci;		// some 的类型是 const int 类型
decltype(cpi) x = cpi;		// x 的类型是 int *const 类型
decltype(pci) y = pci;		// y 的类型是 const int * 类型
decltype(cpci) z = cpci;	// z 的类型是 const int *const 类型
```

可以看到`decltype`和用于推断的变量类型完全相同。



# 三. 引用与 decltype

如果用于推断的是一个引用，那么得到的类型也将是一个引用类型，如：

```c++
const int ci = 0;
const int &cj = ci;
decltype(cj) rci = ci;		// rci 是一个 const int & 类型，与 ci 绑定
```

如果`decltype`使用的表达式**不是一个变量**，则`decltype`返回表达式结果对应的类型。比较特殊的是有些表达式将向`decltype`返回一个引用类型，这种情况表明用于判断的表达式的结果对象能作为一条赋值语句的**左值**：

```c++
int i = 42;
int *p = &i;
int &r = i;

decltype(r + 0) b;		// r + 0 返回一个右值，且 r + 0 的结果是 int，因此 b 是一个 int
decltype(*p) c;			// 错误，*p 为非变量表达式，且 *p 返回一个 int 类型左值，所以 c 是一个 int &，应该初始化
```

另外，对于`decltype`用于推断的表达式来说，如果**变量**名加上了一对括号，将永远得到引用类型：

```c++
int i = 42;
decltype((i)) d = i;	// (i) 是一个非变量表达式且返回一个 int 类型左值，所以 decltype 将返回 int & 类型
```

实际上，这只是一个特例，它仍然满足上述的定义：如果`decltype`用于判断的表达式不是变量，则`decltype`返回表达式结果对应的类型，如果该表达式的结果对象是一个左值，那么将返回对应类型的引用。

在这个例子中，虽然看上去是一个变量，但是由于添加了`()`，所以它成了一个非变量表达式。



# 四. 总结

从上述的所有情况来看，`decltype`做的就只有一件事：严格返回用于判断的表达式的类型。

它所有使用上的区别主要在于用于判断的表达式的不同而不同：

- 如果该表达式是一个变量，那么严格返回该变量的类型，包括引用和任何`const`属性
- 如果该表达式是一个非变量的表达式，那么返回表达式的结果的类型。特殊的，如果表达式的结果是一个左值，那么将返回表达式结果类型的引用类型。

我们需要做的只有**分清表达式是否是一个变量表达式，以及如果是一个非变量表达式那么它是否是一个左值**。