# 一. 简介

在 C++ 中，当我们使用基类的引用或指针调用一个虚成员函数时会执行动态绑定。因为我们直到运行时才能直到到底调用了哪个版本的虚函数，所以所有虚函数都必须有定义。通常情况下，如果我们不使用某个函数，则无须为该函数提供定义，但是我们必须为每一个虚函数都提供定义，而不管它是否被用到了，这是因为连编译器也无法确定到底会使用哪个虚函数。

****

当某个虚函数通过指针或引用调用时，编译器产生的代码直到运行时才能确定应该调用哪个版本的函数。被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的那个。

需要注意的是：当且仅当对通过**指针或引用**调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。



# 二. 派生类中的虚函数

当我们在派生类中覆盖了某个虚函数时，可以再一次使用`virtual`关键字指出该函数的性质，然而这么做并非必须，因为一旦某一个函数被声明成虚函数，则在所有派生类中它都是虚函数。

一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的**形参类型**必须与被它覆盖的基类函数完全一致。同样，派生类中虚函数的**返回类型**也必须与基类函数匹配。该规则存在一个**例外**，当类的虚函数返回类型是类本身的指针或引用时，上述规则无效，即如果`D`有`B`派生得到，则基类的虚函数可以返回`B*`而派生类的对应函数可以返回`D*`，只不过这样的返回类型要求从`D`到`B`的类型转换是可访问的。

****

**override**：

派生类如果定义了一个函数与基类中虚函数的名字相同但是形参列表不同，这仍然是合法的行为。编译器将认为新定义的这个函数与基类中原有的函数是相互独立的。这是，派生类的函数并没有覆盖掉基类中的版本。就实际的编程习惯而言，这种声明往往意味着发生了错误，因为我们可能原本希望派生类能覆盖掉基类中的虚函数，但是一不小心把形参列表弄错了。

要想调试并发现这样的错误显然非常困难。在 C++11 标准中我们可以使用`override`关键字来说明派生类中的虚函数。这么做的好处是在使得程序员的意图更加清晰的同时让编译器可以为我们发现一些错误，后者在编程实践中显得更加重要。如果我们使用`override`标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器将报错：

```c++
struct B {
    virtual void f1(int) const;
    virtual void f2();
    void f3();
};
struct D1 : B {
    void f1(int) const override;		// 正确：f1 与基类中的 f1 匹配
    void f2(int) override;			// 错误：B 没有形如 f2(int) 的函数
    void f3() override;				// 错误：f3 不是虚函数
    void f4() override;				// 错误：B 没有名为 f4 的函数
};
```

****

**final**：

添加`final`和`override`的意图类似。将某个函数指定为`final`，表示不允许后续的任何其他类覆盖该函数。`final`和`override`说明符出现在形参列表（包括任何`const`或引用修饰符）以及尾置返回类型之后：

```c++
struct D2 : B {
    void f1(int) const final;		// 不允许后续的其他类覆盖 f1(int)
};
struct D3 : D2 {
    void f2();
    void f1(int) const;		// 错误：D2 已经将 f2 声明成 final
};
```



# 三. 虚函数与默认实参

虚函数也可以拥有默认实参。如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定。

换句话说，如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即是实际运行的是派生类中的函数版本也是如此。此时，传入派生类函数的将是基类函数定义的默认实参。如果派生类函数依赖不同的实参，则程序结果将与我们的预期不符。

所以，如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。



# 四. 回避动态绑定

在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本。

我们通过作用域运算符可以实现这一目的，例如：

```c++
double undiscounted = baseP->Quote::net_price(42);
```

该代码强行调用`Quote`的`net_price`函数，而不管`baseP`实际指向的对象类型到底是什么。该调用将在编译时完成解析。

通常当一个派生类的虚函数调用它覆盖的基类的虚函数版本时，我们可能会需要回避动态绑定的机制。

****

需要注意，如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本自身的调用，从而导致无限递归。