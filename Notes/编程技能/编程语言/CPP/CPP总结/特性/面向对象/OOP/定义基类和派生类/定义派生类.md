# 一. 基本格式

派生类必须通过使用**类派生列表**（class derivation list）明确指出它是从哪个（哪些）基类继承而来的。类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有以下三种访问说明符中的一个：`public`、`protected`或者`private`

派生类必须将其继承而来的成员函数中需要覆盖的那些重新声明，因此，我们的`Bulk_quote`类必须包含一个`net_price`成员：

```c++
class Bulk_quote : public Quote {
public:
    Bulk_quote() = default;
    Bulk_quote(const std::string &, double, std::size_t, double);
    
    double net_price(std::size_t) const override;
private:
    std::size_t min_qty = 0;
    double discount = 0.0;
};
```

我们的`Bulk_quote`类从它的基类`Quote`那里继承了`isbn`函数和`bookNo`、`price`等数据成员。此外，它还定义了`net_price`的新版本，同时拥有两个新增加的数据成员`min_qty`和`discount`。

对基类的访问控制符的作用是控制派生类从基类继承而来的成员是否对派生类的用户可见。如果一个派生是公有的，则基类的公有成员也是派生类接口的组成部分。此外，我们能将公有派生类型对象绑定到基类的引用或指针上。因为我们在派生列表中使用了`public`，所以`Bulk_quote`的接口隐式地包含`isbn`函数，同时在任何需要`Quote`的引用或指针的地方我们都能使用`Bulk_quote`的对象。

大多数类都只继承自一个类，这种形式的继承被称作 “单继承”，此处主要讨论该情况。



# 二. 派生类中的虚函数

派生类经常（但不总是）覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。

派生类可以在它覆盖的函数前使用`virtual`关键字，但不是非得这么做。C++11 标准允许派生类显式地注明它使用某个成员函数覆盖了它继承的虚函数。具体做法是在形参列表后面、或者在`const`成员函数的`const`关键字后面、或者在引用成员函数的引用限定符后面添加一个关键字`override`



# 三. 派生类对象及派生类向基类的类型转换

一个派生类对象包含多个组成部分：

- 一个含有派生类自己定义的（非静态）成员的子对象，
- 一个与该派生类继承的基类对应的子对象，如果有多个基类，那么这样的子对象也有多个

因此，一个`Bulk_quote`对象将包含四个数据元素：

- 它从`Quote`继承而来的`bookNo`和`price`数据成员
- 以及`Bulk_quote`自己定义的`min_qty`和`discount`成员

C++标准并没有明确规定派生类的对象在内存中如何分布，但是我们可以认为基类中的数据成员为一个整体，派生类自己的数据成员为一个整体，在一个对象中，继承自基类的部分和派生类自定义的部分不一定是连续存储的。

出于这个原因，我们能把派生类的对象当成基类对象来使用，因为派生类有基类的成员，而且我们也能将基类的指针或引用绑定到派生类对象的基类部分上：

```c++
Quote item;
Bulk_quote bulk;
Quote *p = &item;		// p 指向 Quote 对象
p = &bulk;			// p 指向 bulk 的 Quote 部分
Quote &r = bulk;		// r 绑定到 bulk 的 Quote 部分
```

这种转换通常称为**派生类到基类的**（derived-to-base）类型转换。和其他类型转换一样，编译器会隐式地执行派生类到基类的转换。

这意味着我们可以把派生类对象或者派生类对象的引用用在需要基类引用的地方；同样的，我们也可以把派生类对象的指针用在需要基类指针的地方。



# 四. 派生类构造函数

尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。和其他创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它的积累部分。

派生类对象的基类部分与派生类对象自己的数据成员都是在构造函数的初始化阶段执行初始化操作的。类似于我们初始化成员的过程，派生类构造函数同样是通过构造函数初始化列表来将实参传递给基类构造函数的。例如，接受四个参数的`Bulk_quote`构造函数如下所示：

```c++
Bulk_quote(const std::string &book, double p, std::size_t qty, double disc)
    : Quote(book, p), min_qty(qty), discount(disc) { }
```

该函数将它的前两个参数传递给`Quote`的构造函数，由`Quote`的构造函数负责初始化`Bulk_quote`的积累部分。当`Quote`构造函数体结束后，我们构建的对象的积累部分也就完成初始化了。接下来初始化由派生类直接定义的`min_qty`和`discount`成员。最后运行`Bulk_quote`构造函数的函数体。

除非我们特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化。如果想使用其他的基类构造函数，我们需要以类名加圆括号内的实参列表的形式为构造函数提供初始值。



# 五. 派生类使用基类的成员

派生类可以访问基类的公有成员和受保护成员：

```c++
double Bulk_quote::net_price(size_t cnt) const
{
    if (cnt >= min_qty)
        return cnt * (1 - discount) * price;
    else
        return cnt * price;
}
```

这和使用它自己的成员的方式没有什么不同。

虽然我们可以这么做，但是必须明确一点：每个类负责定义各自的接口，要想与类的对象交互必须使用该类的接口，即使这个对象是派生类的基类部分也是如此。

因此，派生类对象不能直接初始化基类的成员，尽管从语法上来说我们可以在派生类构造函数体内给它的`public`或`protected`的基类成员赋值，但是最好不要这么做。和使用基类的其他场合一样，派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始化那些从基类中继承而来的成员。



# 六. 继承与静态成员

如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例。

```c++
class Base {
public:
    static void statmem();
};
class Derived : public Base {
    void f(const Derived&);
};
```

静态成员遵循通用的访问控制规则，如果基类中的成员是`private`的，则派生类无权访问它。假设某静态成员是可访问的，则我们既能通过基类使用它也能通过派生类使用它：

```c++
void Derived::f(const Derived &derived_obj)
{
    Base::statmem();		// 通过作用域运算符访问：Base 定义了 statmem()
    Derived::statmem();		// 通过作用于运算符访问：Derived 继承了 statmem()
    derived_obj.statmem();	// 通过 Derived 对象访问
    statmem();			// 通过 this 对象访问
}
```

上面的每一种调用方式都是可行的，而且它们所访问的成员都是同一个成员。



# 七. 派生类的声明

派生类的声明与其他类差别不大，声明中包含类名但是不包含它的派生列表：

```c++
class Bulk_quote : public Quote;	// 错误：派生列表不能出现在这里
class Bulk_quote;			// 正确
```

一条声明语句的目的是令程序知晓某个名字的存在以及该名字表示一个什么样的实体，如一个类、一个函数或一个变量等。派生列表以及与定义有关的其他细节必须与类的主体一起出现。



# 八. 被用作基类的类

如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明：

```c++
class Quote;
class Bulk_quote : public Quote {...};	// 错误，Quote 必须被定义
```

这一规定的原因显而易见：派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类当然要知道它们是什么。因此该规定还有一层隐含的意思，即一个类不能派生它本身。

一个类是基类，同时它也可以是一个派生类：

```c++
class Base { /* ... */ };
class D1 : public Base { /* ... */ };
class D2 : public D1 { /* ... */ };
```

在这个继承关系中，`Base`是`D1`的**直接基类**（direct base），同时是`D2`的**间接基类**（indirect base）。直接基类出现在派生列表中，而间接基类由派生类通过其直接基类继承而来。

每个类都会继承直接基类的所有成员。对于一个最终的派生类来说，它会继承其直接基类的成员；该直接基类的成员又含有其基类的成员；以此类推直至继承链的顶端。因此，最终的派生类将包含它的直接基类的子对象以及每个间接基类的子对象。



# 九. 防止基类的发生

有时我们会定义这样一种类，我们不希望类继承它，或者不想考虑它是否适合作为一个基类。为了实现这一目的，C++11 标准提供了一种防止继承发生的方法，即在类名后跟一个关键字`final`：

```c++
class NoDerived final { /* ... */ };
class Base { /* ... */ };
class Last final : Base { /* ... */ };

class Bad : NoDerived { /* ... */ };		// 错误
class Bad2 : Last { /* ... */ };		// 错误
```

