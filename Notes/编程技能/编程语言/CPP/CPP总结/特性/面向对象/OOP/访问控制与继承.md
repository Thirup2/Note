# 一. protected 成员

如前所述，一个类使用`protected`关键字来声明那些它希望与派生类分享但是不想被其他公共访问的成员。`protected`可以看做是`public`和`private`中和后的产物：

- 和私有成员类似，受保护的成员对于类的用户来说是不可访问的
- 和共有成员类似，受保护的成员对于派生类的友元来说是可访问的

此外，`protected`还有另外一条重要的性质：

- 派生类的成员或友元只能通过**派生类对象**来访问基类的受保护成员。派生类对于一个**基类对象**中的受保护成员没有任何访问特权



# 二. 继承访问控制

访问控制符除了可以限制成员的权限之外，还可以限制基类整体的权限。

对于一个派生类来说，该类对其继承而来的成员的访问权限受到两个因素影响：一是在基类中该成员的访问说明符，二是在派生类的派生列表中的访问说明符。

我们以下面的代码为例：

```c++
class Base {
public:
    int pub_mem;
protected:
    double prot_mem;
private:
    char priv_mem;
};

struct Pub_Derv : public Base {
    int f1() { return pub_mem; }
    double g1() { return prot_mem; }
    char h1() { return priv_mem; }
};

struct Prot_Derv : protected Base {
    int f2() { return pub_mem; }
    double g2() { return prot_mem; }
    char h2() { return priv_mem; }
};

struct Priv_Derv : private Base {
    int f3() { return pub_mem; }
    double g3() { return prot_mem; }
    char h3() { return priv_mem; }
};
```

首先我们定义了一个基类，包含三个不同访问权限的成员。然后我们定义了三个派生类，分别用不同的权限控制符继承了基类，然后我们在每个派生类中尝试访问基类中的每个成员。

****

先说结论，对于派生类来说，不论继承时的访问控制符是什么，都不会影响该派生类对基类成员的访问权限，即**每个派生类都能访问基类的`public`和`protected`成员，但是不能访问`private`成员**。

实际上在继承时的访问控制符是控制所有**派生类用户**（包括该派生类的派生类）对于**基类成员**的访问权限。

在理解这点之前我们需要清楚一个**类成员的访问控制符控制了什么权限**：

- 对于该类的对象而言，它只能访问该类的`public`成员，而不能访问`protected`和`private`成员
- 对于该类的派生类而言，它只能访问该类的`public`和`protected`成员，而不能访问`private`成员。

****

而继承时的访问控制符控制的是派生类中基类成员的访问权限：

- 对于`public`继承，基类中的成员将保持它们的访问权限。就相当于把所有基类成员包括访问控制符全部抄写了一遍到派生类中（当然派生类仍然不具有访问基类中`private`成员的能力）。
- 对于`private`继承，基类中的所有成员在派生类中都将变为`private`的
- 对于`protected`继承，基类中的所有`public`成员在派生类中都将变为`protected`的



# 三. 派生类向基类转换的可访问性

派生类向基类的转换实际上是指针或引用的转换，而并非真正地将一个派生类对象转换为基类对象。而要把一个指向派生类对象的指针或引用转换成指向基类对象的指针或引用，则要求该派生类中基类部分的访问权限没有发生改变。也就是说：**只有当派生类`public`继承基类时，用户代码才能使用派生类向基类的转换**。

实际上，派生类向基类的转换是否可访问由使用该转换的代码决定，同时派生类的派生访问说明符也会有影响。假设`D`继承自`B`：

- 只有当`D`公有地继承`B`时，**用户代码**才能使用派生类向基类的转换；如果`D`继承`B`的方式是受保护的或者私有的，则用户代码不能使用该转换。
- 不论`D`以什么方式继承`B`，`D`的**成员函数和友元**都能使用派生类向基类的转换；派生类向其直接基类的类型转换对于派生类的成员和友元来说永远是可访问的
- 如果`D`继承`B`的方式是公有的或者受保护的，则`D`的**派生类的成员和友元**可以使用`D`向`B`的类型转换；反之，如果`D`继承`B`的方式是私有的，则不能使用。



# 四. 友元与继承

前面我们知道友元关系不能传递，同样友元关系也不能继承。基类的友元在访问派生类成员时不具有特殊性，类似的，派生类的友元也不能随意访问基类的成员：

```c++
class Base {
public:
    int pub_mem;
protected:
    double prot_mem;
private:
    char priv_mem;
    
    friend class Pal;
};
class Sneaky : public Base {
public:
    int j;
};
class Pal {
public:
    double f(Base b) { return b.prot_mem; }
    int f2(Sneaky s) { return s.j; }
    int f3(Sneaky s) { return s.prot_mem; }
};
```

因为`Pal`是`Base`的友元，所以`Pal`可以访问`Base`中的成员，故`f`函数正确；

而虽然`Sneaky`是`Base`的派生类，但是友元关系并不继承，所以`Pal`不能访问`Sneaky`的成员，故`f2`错误；

比较奇怪的是第三个函数`f3`，它访问的是派生类中基类的成员，但这种方法却是正确的。`Pal`对`Base`的可访问性包括了`Base`对象内嵌在其派生类对象中的情况。

****

另外，当一个类将另一个类声明为友元时，这种友元关系只对作出声明的类有效。对于原来那个类来说，其友元的基类或者派生类不具有特殊的访问能力：

```c++
class D2 : public Pal {
public:
    double mem(Base b) { return b.prot_mem; }		// 错误
};
```

虽然`Pal`是`Base`的友元，但是`D2`并不是`Base`的友元，所以即使是`Pal`的派生类，也无法访问`Base`的成员。

****

实际上可以总结如下：这种友元关系不可继承是两方面的，对于包含友元的类来说，其派生类不会继承该类的友元；对于被声明为友元的类来说，它的派生类也不是包含该友元声明的友元。



# 五. 改变个别成员的可访问性

当我们继承时使用`public`、`protected`和`private`来修饰继承时，它影响的是一部分的成员的可访问性，如`protected`将所有`public`成员变成`protected`的，而`private`将所有`public`和`protected`成员变成`private`的。它们都无法做到只改变某一个成员的可访问性。

我们可以在派生类中使用`using`关键字对基类成员进行再声明（注意是声明而不是定义）：

```c++
class Base {
public:
    std::size_t size() const { return n; }
protected:
    std::size_t n;
};

class Derived : private Base {
public:
    using Base::size;
protected:
    using Base::n;
};
```

如果我们不使用`using`声明，那么由于`Derived`类使用`private`继承，所以基类中所有成员都将变成`private`的。而实际上我们在派生类中使用`using`声明将基类中的`size`成员声明成了`public`，而`n`成员声明成了`protected`。需要注意的是，在`using`声明中，必须指明声明的成员所属的类

****

**注意**：派生类只能为那些它**可以访问**的名字提供`using`声明



# 六. 默认的继承保护级别

声明类有两个关键字，一是使用`struct`，二是`class`。

我们知道当使用`struct`时，没有特殊说明的成员默认为`public`；而使用`class`时，没有特殊说明的成员默认为`private`。

实际上，除了这个区别之外，还有一个区别：

当使用`struct`关键字定义派生类时，该派生类默认对基类进行`public`继承；而使用`class`关键字定义的派生类是`private`继承。