# 一. 简介

**面向对象程序设计**（object-oriented programming）的核心思想是**数据抽象**（封装）、**继承**和**动态绑定**（多态）。

通过使用数据抽象，我们可以将类的接口和实现分离；使用继承，可以定义相似的类型并对其相似关系建模；使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。



# 二. 继承

通过**继承**（inheritance）联系在一起的类构成一种层次关系。通常在层次关系的根部有一个**基类**（base class），其他类则直接或间接地从基类继承而来，这些继承得到的类成为**派生类**（derived class）。基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。

在 C++ 中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成**虚函数**（virtual function）。声明虚函数的方法就是在普通函数声明前添加一个`virtual`关键字即可：

```c++
class Quote {
public:
    std::string isbn() const;
    virtual double net_price(std::size_t n) const;
};
```

派生类必须通过使用**类派生列表**（class derivation list）明确指出它是从哪个或哪些基类继承而来的。类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有访问说明符：

```c++
class Bulk_quote : public Quote {
public:
    double net_price(std::size_t) const override;
};
```

派生类必须在其内部对所有重新定义的虚函数进行声明。派生类可以在这样的函数之前加上`virtual`关键字，但是并不是非得这么做。C++11 标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，具体措施是在该函数的形参列表之后增加一个`override`关键字。



# 三. 动态绑定

通过使用**动态绑定**（dynamic binding），我们能用统一段代码分别处理`Quote`和`Bulk_quote`的对象，如：

```c++
double print_total(ostream &os, const Quote &item, size_t n)
{
    // 根据传入 item 形参的对象类型调用 Quote::net_price 或者 Bulk_quote::net_price
    double ret = item.net_price(n);
    os << "ISBN: " << item.isbn()		// 调用 Quote::isbn()
        << " # sold: " << n << " total due: " << ret << endl;
    return ret;
}
```

该函数非常简单：它返回调用`net_price()`的结果，并将该结果连同调用`isbn()`的结果一起打印出来。

而函数`print_total`的`item`的形参是基类`Quote`的一个引用，但实际上我们既能用基类的对象调用该函数，也能用派生类的对象调用它。同时又因为`print_total`是通过引用类型调用`net_price`的，所以实际传入`print_total`的对象类型将决定到底执行`net_price`的哪个版本：

```c++
// basic 的类型是 Quote；bulk 的类型是 Bulk_quote
print_total(cout, basic, 20);		// 调用 Quote::net_price()
print_total(cout, bulk, 20);		// 调用 Bulk_quote::net_price()
```

因为在上述过程中函数的运行版本由实参决定，即在运行时选择函数的版本，所以动态绑定有时又被成为**运行时绑定**（run-time binding）。