# 一. 基本格式

我们首先完成`Quote`类的定义：

```c++
class Quote {
public:
    Quote() = default;
    Quote(const std::string &book, double sales_price): bookNo(book), price(sales_price) { }

    std::string isbn() const { return bookNo; }  
    virtual double net_price(std::size_t n) const { return n * price; }
    virtual ~Quote() = default;
private:
    std::string bookNo;
protected:
    double price = 0.0;
};
```

上面的代码中除了`~Quote()`这个虚析构函数之外，其他的内容此节都会介绍到，关于虚析构函数的知识，此处只需记住作为继承关系中根节点的类通常都会定义一个虚析构函数，即使该函数不执行任何实际操作。



# 二. 解释

## 1. 虚函数

派生类可以继承其基类的成员，然而当遇到如`net_price`这样的类型相关的操作时，派生类必须对其重新定义。换句话说，派生类需要对这些操作提供自己的新定义以**覆盖**（override）从基类继承而来的旧定义。

在 C++ 中，基类必须将它的两种成员函数区分开来：一种是基类希望其派生类进行覆盖的函数；另一种是基类希望派生类直接继承而不要改变的函数。对于前者，基类通常将其定义为**虚函数**（virtual）。当我们**使用指针或引用**调用虚函数时，该调用将被动态绑定。根据引用或指针所绑定的对象不同，该调用可能执行基类的版本，也可能执行某个派生类的版本。

基类通过在其成员函数的声明语句加上关键字`virtual`使得该函数执行动态绑定。任何构造函数之外的非静态函数都可以是虚函数。关键字`virtual`只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。

成员函数如果没被声明为虚函数，则其解析过程发生在编译时而非运行时。对于`isbn`成员来说这正是我们希望看到的结果。它的执行与派生类的细节无关，不管作用于`Quote`对象还是`Bulk_quote`对象，`isbn`函数的行为都一样。在我们的继承层次关系中只有一个`isbn`函数，因此也就不存在调用`isbn()`时到底执行哪个版本的疑问。



## 2. 访问控制与继承

派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。和其他使用基类的代码一样，派生类能访问共有成员，而不能访问私有成员。不过在某些时候基类中还有这样一种成员，基类希望它的派生类有权访问该成员，同时禁止其他用户访问。我们用**受保护的**（protected）访问运算符说明这样的成员。

我们的`Quote`类希望它的派生类定义各自的`net_price`函数，因此派生类需要访问`Quote`的`price`成员。此时我们将`price`定义成受保护的。与之相反，派生类访问`bookNo`成员的方式与其他用户是一样的，都是通过调用`isbn`函数，因此`bookNo`被定义成私有的，即使是`Quote`派生出来的类也不能直接访问它。