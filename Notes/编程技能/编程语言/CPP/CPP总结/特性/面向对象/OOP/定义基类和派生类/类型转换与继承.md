# 一. 简介

通常情况下，如果我们想把引用或指针绑定到一个对象上，则引用或指针的类型应该与对象的类型一致，或者对象的类型含有一个可接受的`const`类型转换规则。存在继承关系的类是一个例外：我们可以将基类的指针或引用绑定到派生类对象上。例如，我们可以用`Quote&`指向一个`Bulk_quote`对象，也可以把一个`Bulk_quote`对象的地址赋给一个`Quote*`。

可以将基类的指针或引用绑定到派生类对象上有一层极为重要的含义：当使用基类的引用（或指针）时，实际上我们并不清楚该引用（或指针）所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象。

****

和内置指针一样，智能指针类也支持派生类向基类的类型转换，这意味着我们可以将一个派生类对象的指针存储在一个基类的智能指针内。



# 二. 静态类型与动态类型

当我们使用存在继承关系的类型时，必须将一个变量或其他表达式的**静态类型**（static type）与该表达式表示对象的**动态类型**（dynamic type）区分开来。我们可以这样理解这两个类型。我们在定义一个函数的时候，它的参数列表必须要写下一个真正的类型，哪怕最后调用这个函数的参数实际上是这个类型的派生类也是如此，然后在函数的表达式中使用到这些参数的时候，我们将按照参数列表中写下的类型对其进行编译，这就是**静态类型**。而由于实际上我们可以用派生类对象调用基类类型形参的函数，这个类型直到运行时才可能知道，这个类型就是**动态类型**。

表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型；动态类型则是变量或表达式表示的内存中的对象的类型。动态类型直到运行时才可知。

****

如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。例如，`Quote`类型的变量永远是一个`Quote`对象，我们无论如何都不能改变该变量对应的对象的类型。



# 三. 不存在基类向派生类的隐式类型转换

之所以存在派生类向基类的类型转换是因为每个派生类对象都包含一个基类部分，而基类的引用和指针可以绑定到该基类部分上。一个基类的对象既可以独立的存在，也可以作为派生类对象的一部分存在。如果基类对象不是派生类对象的一部分，则它只含有基类定义的成员，而不含有派生类定义的成员。

因为一个基类的对象可能是派生类对象的一部分，也可能不是。所以不存在从基类向派生类的类型转换。

编译器在编译时无法确定某个特定的转换在运行时是否安全，这是因为编译器只能通过检查指针或引用的静态类型来推断该转换是否合法。如果在基类中含有一个或多个虚函数，我们可以用`dynamic_cast`请求一个类型转换，该转换的安全检查将在运行时执行。同样，如果我们已知某个基类向派生类的转换是安全的，则我们可以使用`static_cast`来强制覆盖掉编译器的检查工作。



# 四. 对象之间不存在类型转换

派生类向基类的自动转换只对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换。

有时我们可能会看到在基类和派生类之间使用`=`运算符，看上去像是把一个派生类转换成了基类，但实际上这是由于基类中定义的`operator=`函数接受一个基类类型的引用，所以传递派生类引用也是合法的。