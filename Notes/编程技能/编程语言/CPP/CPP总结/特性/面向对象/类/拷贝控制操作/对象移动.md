# 一. 简介

C++ 的一个特性是可以移动而非拷贝对象。在某些情况下，旧对象刚拷贝给新对象旧对象就被销毁了。在这些情况下，移动而非拷贝对象会大幅度提升性能。

同时另外一个原因是 IO 类或`unique_ptr`这样的类，这些类都包含不能被共享的资源（如指针或 IO 缓冲）。因此，这些类型的对象不能拷贝但可以移动。



# 二. 右值引用

为了支持移动操作，新标准引入了一种新的引用类型——**右值引用**（rvalue reference）。它必须绑定到右值，这种引用通过`&&`而不是`&`来获得右值引用。它有一个重要的性质——只能绑定到一个将要销毁的对象。因此，我们可以自由地将一个右值引用的资源 “移动” 到另一个对象中。

类似于其他任何引用，一个右值引用也只是某个对象的另一个名字而已。我们在此可以将常规引用称为**左值引用**（lvalue reference）。我们不能将一个左值引用绑定到要求转换的表达式、字面常量或是返回右值的表达式。而右值引用有着完全相反的绑定特性：我们可以将一个右值引用绑定到这类表达式上，但不能将一个右值引用直接绑定到一个左值上：

```c++
int i = 42;
int &r = i;			// 正确
int &&rr = i;			// 错误：不能将一个右值引用绑定到一个左值上
int &r2 = i * 42;		// 错误： i * 42 是一个右值
const int &r3 = i * 42;		// 正确：我们可以将一个 const 的引用绑定到一个右值上
int &&rr2 = i * 42;		// 正确：将 rr2 绑定到乘法结果上
```

返回作之引用的函数，连同赋值、下标、解引用和前置递增/递减运算符，都是返回左值的表达式的例子。我们可以将一个左值引用绑定到这类表达式的结果上。

返回非引用类型的函数，连同算术、关系、位以及后置递增/递减运算符，都生成右值。我们不能将一个左值引用绑定到这类表达式上，但我们可以将一个`const`的左值引用或者一个右值引用绑定到这类表达式上。

****

我们需要注意到的一个关键点是：**左值持久，右值短暂**。右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。

由于右值引用只能绑定到临时对象，所以：

- 所引用的对象将要被销毁
- 该对象没有其他用户

这两个特性意味着：使用右值引用的代码可以自由地接管所引用的对象的资源

****

另外一个需要注意的点是：**变量是左值**。变量可以看作只有一个运算对象而没有运算符的表达式，类似其他任何表达式，变量表达式也有左值/右值属性，而变量表达式都是左值。也就是说，我们不能将一个右值引用绑定到一个右值引用类型的变量上，如：

```c++
int &&rr1 = 42;
int &&rr2 = rr1;		// 错误：表达式 rr1 是左值
```

****

我们虽然不能将一个右值引用直接绑定到一个左值上，但我们可以显式地将一个左值转换为对应的右值引用类型。我们还可以通过调用一个名为`move`的标准库函数来获得绑定到左值上的右值引用，此函数定义在头文件`<utility>`中，其使用方法如下：

```c++
int &&rr3 = std::move(rr1)；
```

`move`调用告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它。必须注意的是，一旦调用了`move`就意味着：除了对`rr1`赋值或销毁它外，我们将不再使用它。在调用`move`之后，我们不能对移后源对象的值做任何假设。



# 三. 移动构造函数和移动赋值运算符

## 1. 移动构造函数

类似于拷贝构造函数，移动构造函数的第一个参数是该类类型的一个引用。不同于拷贝构造函数的是，这个引用参数在移动构造函数中是一个右值引用。与拷贝构造函数一样，任何额外的参数都必须有默认实参。

除了完成资源移动，移动构造函数还必须确保移后源对象处于这样的状态——销毁它是无害的。特别是，一旦资源完成移动，源对象必须不再指向被移动的资源——这些资源的所有权已经归属新创建的对象。

下面是一个使用移动构造函数的例子：

```c++
StrVec::StrVec(StrVec &&s) noexcept	// 移动操作不应抛出任何异常
    : elements(s.elements), first_free(s.firstfree), cap(s.cap)	// 成员初始化器接管 s 中的资源
{
	s.elements = s.first_free = s.cap = nullptr;	// 令 s 进入对其运行析构函数安全的状态
}
```

其中`StrVec`是一个类似于智能指针的类，如果对其对象执行析构函数将会影响到底层对象的生存期，所以在新对象接管内存之后，需要将原对象的指针都置为空。

****

由于移动操作 “窃取” 资源，它通常不分配任何资源。因此，移动操作通常不会抛出任何异常。当编写一个不抛出异常的移动操作时，我们应该将此事通知标准库。除非标准库知道我们的移动构造函数不会抛出异常，否则它会认为移动我们的类对象时可能会抛出异常，并且为了处理这种可能性而做一些额外的工作。

一种通知标准库的方法是在构造函数中指明`noexcept`，其位置在一个函数的参数列表后。在一个构造函数中，`noexcept`出现在参数列表和初始化列表开始的冒号之间，如上例所示。

另外，我们必须在类头文件的声明中和定义中（如果定义在类外的话）都指定`noexcept`



## 2. 移动赋值运算符

移动赋值运算符执行与析构函数和移动构造函数相同的工作。与移动构造函数一样，如果我们的移动赋值运算符不抛出任何异常，我们就应该将它标记为`noexcept`。类似拷贝赋值运算符，移动赋值运算符必须正确处理自赋值：

```c++
StrVec &StrVec::operator=(StrVec &&rhs) noexcept
{
    // 直接检测自赋值
    if (this != &rhs) {
        free();
        elements = rhs.elements;
        first_free = rhs.first_free;
        cap = rhs.cap;
        // 将 rhs 置于可析构状态
        rhs.elements = rhs.first_free = rhs.cap = nullptr;
    }
    return *this;
}
```

我们检查自赋值情况的原因是此右值可能是`move`调用的返回结果。与其他任何赋值运算符一样，关键点是我们不能在使用右侧运算对象之前就释放左侧运算对象的资源（可能是相同的资源）



# 四. 合成的移动操作

与处理拷贝构造函数和拷贝赋值运算符一样，编译器也会合成移动构造函数和移动赋值运算符。但是，合成移动操作的条件与合成拷贝操作的条件大不相同。

如果我们不声明自己的拷贝构造函数或拷贝赋值运算符，编译器总会为我们合成这些操作。拷贝操作要么被定义为逐成员拷贝，要么被定义为对象赋值，要么被定义为删除的函数。

****

**合成条件**：

与拷贝操作不同，编译器根本不会为某些类合成移动操作。特别是，如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数或移动赋值运算符。如果一个类没有移动操作，通过正常的函数匹配，类会使用对应的拷贝操作来代替移动操作。

只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非`static`数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。编译器可以移动内置类型的成员。如果一个成员是类类型，且该类有对应的移动操作，编译器也能移动这个成员。

****

**何时合成为删除**：

与拷贝操作不同，移动操作永远不会隐式定义为删除的函数。但是，如果我们显式地要求编译器生成`=default`的移动操作，且编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数。

除了这个重要例外之外，什么时候将合成的移动操作定义为删除的函数遵循与定义删除的合成拷贝操作类似的原则：

- 有类成员定义了自己的拷贝构造函数且未定义移动构造函数，或者是有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数。移动赋值运算符的情况类似。
- 如果有类成员的移动构造函数或移动赋值运算符被定义为删除的或是不可访问的，则类的移动构造函数或移动赋值运算符被定义为删除的
- 如果类的析构函数被定义为删除的或不可访问的，则类的移动构造函数被定义为删除的
- 如果有类成员是`const`的或是引用，则类的移动赋值运算符被定义为删除的

****

**对拷贝操作的影响**：

如果一个类定义了自己的移动构造函数和/或一个移动赋值运算符，则该类的合成拷贝构造函数和拷贝赋值运算符会被定义为删除的。



# 五. 使用移动操作的时机

如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个构造函数。赋值操作的情况类似。

简单来说，当构造函数或赋值运算符的右侧运算对象是一个右值时，将会调用移动构造函数或移动赋值运算符，否则调用拷贝构造函数或拷贝赋值运算符。

如果没有移动操作，那么当构造函数或赋值运算符的右侧运算对象即使是一个右值时，也将使用拷贝构造函数或拷贝赋值运算符

****

**非 const 右值**：

一般来说，我们只需要移动操作接受非 const 的右值，因为我们在移动完成后需要对被移动的对象进行一些修改以使其能被安全析构，而拷贝操作则通常接受一个const 的值。

所以，如果有一个 const 右值，即使它是右值，它也应该是和拷贝操作进行匹配。