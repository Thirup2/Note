# 一. this指针

在访问某对象的成员函数或数据成员时，需要用到成员访问运算符：`.`或`->`，如：

```c++
total.isbn();
```

也就是说当我们在调用成员函数时，实际上是在替某个对象调用它。如果`isbn`指向`Sales_data`的成员，那么也就说明它指向的是调用该函数的对象的成员而不是任何其他对象的成员。

但是在定义成员函数时，却不需要这么做：

```c++
std::string isbn() const { return bookNo; }
```

主要有两方面原因：

****

**其一**：

在类定义的时候，有一个名为**this**的指针，在定义时它未被初始化。

对于我们来说，`this`形参是隐式定义的，在定义成员函数的时候，其实就默认传入了一个指向该类类型对象的指针`this`；

而之所以可以直接写`bookNo`，是因为**任何对类成员的直接访问都被看作`this`的隐式引用**

****

**其二**：

当我们调用一个成员函数时，`this`指针会被调用对象的地址初始化。例如，如果调用：

```c++
total.isbn();
```

则编译器负责把`total`的地址传递给`isbn`的隐式形参`this`，可以等价地认为编译器将该调用重写成了如下的形式：

```c++
Sales_data::isbn(&total);	// 伪代码
```

其中，调用`Sales_data`的`isbn`成员时传入了`total`的地址。

****

**注意**：

1. **任何自定义名为`this`的参数或变量的行为都是非法的**。我们可以在成员函数体内部显式使用`this`，因此尽管没有必要，但我们还是能把`isbn`定义成如下的形式：

   ```c++
   std::string isbn() const { return this->bookNo; }
   ```

2. `this`始终是一个常量指针（顶层`const`），我们不允许改变`this`中保存的地址。



# 二. const成员函数

上一节提到`this`始终是一个常量指针，即具有顶层`const`性质，不允许改变`this`中保存的地址。

但它并不具有底层`const`性质，即可以通过`this`改变成员的值。

那么如果想要对`this`添加底层`const`性质，就需要使用`const`成员函数，也就是上一节所看到的那种函数：

```c++
std::string isbn() const { return bookNo; }
```

其中位于形参列表右括号（`)`）和函数体的左括号（`{`）之间的`const`就表明这是一个`const`成员函数。

`const`成员函数意味着默认传入的`this`指针将是一个指向常量对象的成员函数。

声明为`const`成员函数有几点好处：

1. 确保使用该函数不会修改对象的值
2. 常量对象也可以调用该成员函数

而如果确实需要修改对象的值，则不用声明为`const`成员函数。

****

**返回`*this`对象的const成员函数**：

如果不是`const`成员函数，那么`*this`对象是一个非常量引用；如果是`const`成员函数，那么`*this`对象是一个常量引用。

如果我们想在接受非常量对象时返回的也是非常量引用，接受常量对象时返回的也是常量引用。那么此时都需要重载一个函数。

虽然`const`成员函数既能接受非常量对象也能接受常量对象，但由于返回值的固定，所以没办法兼顾两种可能。



# 三. 在类外定义成员函数

和其他函数一样，当我们在类的外部定义成员函数时，成员函数的定义必须与它的声明匹配，同时，类外部定义的成员的名字必须包含它所属的类名：

```c++
double Sales_data::avg_price() const {
    if (units_sold)
        return revenue/units_sold;
    else
        return 0;
}
```

由于`avg_price`是声明在`Sales_data`类中的，所以在类外的定义必须显式说明这是`Sales_data`类内定义在外的成员函数，它使用作用域运算符（`::`）连接。

另外，由于在函数名处已经说明了函数的位置，所以在函数体内就不再需要表明所属类了。