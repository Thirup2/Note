# 一. 简介

当定义一个类时，我们显式地或隐式地指定在此类型的对象拷贝、移动、赋值和销毁时做什么。

一个类通过定义五种特殊的成员函数来控制这些操作，包括：**拷贝构造函数**（copy constructor）、**拷贝赋值运算符**（copy-assignment operator）、**移动构造函数**（move constructor）、**移动赋值运算符**（move-assignment operator）和**析构函数**（destructor）。

拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么。拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么。而析构函数定义了当此类型对象销毁时做什么。我们称这些操作为**拷贝控制操作**（copy control）。

****

**合成的拷贝控制操作**：

如果一个类没有定义所有这些拷贝控制成员，编译器会自动为它定义缺失的操作。因此，很多类会忽略这些拷贝控制操作。但是，对一些类来说，依赖这些操作的默认定义会导致灾难。通常，实现拷贝控制操作最困难的地方是首先认识到什么时候需要定义这些操作。



# 二. 拷贝构造函数

如果一个构造函数的**第一个参数**是**自身类类型**的**引用**，且**任何额外参数都有默认值**，则此构造函数是拷贝构造函数：
```c++
class Foo {
public:
    Foo();
    Foo(const Foo&);
    // ...
};
```

拷贝构造函数的第一个参数必须是一个引用类型，这是因为拷贝构造函数被用来初始化非引用类类型参数，如果一个类类型的拷贝构造函数不是引用类型，那么拷贝永远不会成功，因为拷贝构造函数会被无穷次调用。

虽然我们可以定义一个接受非`const`引用的拷贝构造函数，但此参数几乎总是一个`const`的引用。

拷贝构造函数在几种情况下都会被隐式地使用，因此，拷贝构造函数通常不应该是`explicit`的。

另外，在某些时候，编译器可以绕过拷贝构造函数，如：

```c++
string null_book = "9-99-99999-9";
```

按照我们的流程，首先 C 风格字符串会自动调用接受一个 C 风格字符串的`string`构造函数，将这个 C 风格字符串转换为一个`string`对象；然后再调用拷贝赋值运算符将右侧的`string`对象拷贝给左侧的`null_book`。但实际上编译器被允许将上面的代码改写为下面的代码：

```c++
string null_book("9-999-99999-9");
```

但是，编译器跳过拷贝/移动构造函数或它们的赋值运算符版本是有要求的，即拷贝/移动构造函数必须是存在且可访问的（例如，不能是`private`的）。



## 1. 合成的拷贝构造函数

如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。与合成默认构造函数不同，即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。

一般情况下，合成的拷贝构造函数会将其参数的成员**逐个**拷贝到正在创建的对象中。编译器从给定对象中依次将每个非`static`成员拷贝到正在创建的对象中。

而每个成员的类型决定了它如何拷贝：

- 对类类型的成员，会使用其拷贝构造函数来拷贝
- 内置类型的成员则直接拷贝
- 对于数组来说，合成的拷贝构造函数会逐元素地拷贝一个数组类型的成员
- 如果数组元素是类类型，则使用元素的拷贝构造函数来进行拷贝



# 三. 拷贝赋值运算符

与类控制其对象如何初始化一样，类也可以控制其对象如何赋值：

```c++
Sales_data trans, accum;
trans = accum;
```

与拷贝构造函数一样，如果类未定义自己的拷贝赋值运算符，编译器会为它合成一个。



## 1. 合成的拷贝赋值运算符

与处理拷贝构造函数一样，如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个**合成拷贝赋值运算符**（synthesized copy-assignment operator）。

一个合成拷贝赋值运算符和一个合成的拷贝构造函数执行的操作相同，即将右侧运算对象的每个非`static`成员赋予左侧运算对象的对应成员。

且每个成员的拷贝方式和拷贝构造函数的相同：

- 对类类型的成员，会使用其拷贝构造函数来拷贝
- 内置类型的成员则直接拷贝
- 对于数组来说，合成的拷贝构造函数会逐元素地拷贝一个数组类型的成员
- 如果数组元素是类类型，则使用元素的拷贝构造函数来进行拷贝



## 2. 自定义拷贝赋值运算符

自定义一个拷贝赋值运算符需要注意以下几点：

- 接受一个与其所在类相同类型的`const`引用参数，且该参数必须作为显式参数传递
- 其返回类型通常返回一个该类类型的引用
- 一个拷贝赋值运算符应该是一个成员函数，其返回值应该总是返回其左侧运算对象的引用，即`*this`



# 四. 析构函数

析构函数执行与构造函数相反的操作：

构造函数初始化对象的非`static`数据成员，还可能做一些其他工作；

析构函数释放对象使用的资源，并销毁对象的非`static`数据成员。

析构函数是类的一个成员函数，名字由波浪号`~`接类名构成。它没有返回值，也不接受参数：

```c++
class Foo {
public:
    ~Foo();
    // ...
};
```

## 1. 完成的工作

如同构造函数有一个初始化部分和一个函数体，析构函数也有一个函数体和一个析构部分。

在一个构造函数中，成员的初始化是在函数体执行之前完成的，且按照它们在类中出现的顺序进行初始化。

在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化顺序的逆序销毁。

在对象最后一次使用之后，析构函数的函数体可执行类设计者希望执行的任何收尾工作。通常，析构函数释放对象在生存期分配的所有资源。

在一个析构函数中，不存在类似构造函数中初始化列表的东西来控制成员如何销毁，析构部分是隐式的。成员销毁时发生什么完全依赖于成员的类型：

- 销毁类类型的成员需要执行成员自己的析构函数
- 内置类型没有析构函数，因此销毁内置类型成员什么也不需要做



## 2. 被调用的时机

无论何时一个对象被销毁，就会自动调用其析构函数：

- 变量在离开其作用域时被销毁
- 当一个对象被销毁时，其成员被销毁
- 容器（无论是标准库容器还是数组）被销毁时，其元素被销毁
- 对于动态分配的对象，当对指向它的指针应用`delete`运算符时被销毁
- 对于临时对象，当创建它的完整表达式结束时被销毁



## 3. 合成析构函数

当一个类未定义自己的析构函数时，编译器会为它定义一个**合成析构函数**（synthesized destructor）。

合成析构函数的函数体实际上为空，它的析构部分（类似于初始化部分独立于函数体之外）是隐式的，在析构函数的函数体执行完后（合成的析构函数什么都不用执行），执行它的析构部分，默认的析构部分将所有非`static`成员销毁。



# 五. 移动拷贝函数和移动赋值运算符

见 “**对象移动**” 部分。



# 六. 三五法则

C++ 并不要求我们定义这五种拷贝控制操作的所有操作：可以只定义其中一个或两个，而不必定义所有。但是这些操作通常应该被看作一个整体。通常，只需要其中一个操作，而不需要定义所有操作的情况是很少见的。

我们可以根据所谓的 “三五法则” 来决定类中需要定义哪些拷贝控制操作，其中的 “三” 表示拷贝构造函数、拷贝赋值运算符和析构函数的关系，而 “五” 表示所有拷贝控制操作之间的关系。

其中 “三” 这个部分有下面两个原则：

- **需要自定义析构函数的类也需要拷贝和赋值操作**。因为如果需要自定义析构函数，那么这个类很有可能使用了动态内存，所以在这种情况下使用合成的拷贝和赋值操作很可能会出错。但是如果一个类需要拷贝和赋值操作，并不意味着这个类一定需要析构函数。
- **需要拷贝操作的类也需要赋值操作，反之亦然**。当我们自定义了拷贝构造函数的操作如只拷贝部分成员的值，其他成员通过其他方式生成，那么从自然语言的语义上来说，拷贝和赋值的语义相同或相近，所以为了使用时的自然性，我们通常都还需要自定义一个赋值操作。事实上也确实如此，在这个例子中，我们的赋值操作也不能改变非拷贝部分成员的值。

而 “五” 有一点：

- **所有五个拷贝控制成员应该看作一个整体**：一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。某些类必须定义拷贝构造函数、拷贝赋值运算符和析构函数才能正确工作。这些类通常拥有一个资源，而拷贝成员必须拷贝此资源。一般来说，拷贝一个资源会导致一些额外开销。在这种拷贝并非必要的情况下，定义了移动构造函数和移动赋值运算符的类就可以避免此类问题。



# 七. 使用 =default

我们可以通过将拷贝控制成员定义为`=default`来显式地要求编译器生成合成的版本，如：

```c++
class Sales_data
{
public:
    Sales_data() = default;
    Sales_data(const Sales_data&) = default;
    Sales_data& operator=(const Sales_data&) = default;
    ~Sales_data() = default;
    // ...
};
```

当我们在类内用`=default`修饰成员的声明时，合成的函数将隐式地声明为内联的（就像任何其他类内声明的成员函数一样）。如果我们不希望合成的成员是内联函数，应该只对成员的类外定义使用`=default`。



# 八. 阻止拷贝控制

如果我们不主动定义一个拷贝控制函数，那么它会有一个合成的拷贝控制函数，那么似乎无论怎样这些拷贝控制函数都是可以访问的状态。

而我们之前接触的一些类却无法使用它们的拷贝控制函数如拷贝和赋值等操作，实现这一点主要可以有两种方法：

- 一是可以定义一个删除的函数
- 二是可以将拷贝控制函数定义在`private`下

## 1. 定义删除的函数

我们可以通过将拷贝构造函数和拷贝赋值运算符定义为**删除的函数**（deleted function）来阻止拷贝。删除的函数是这样一种函数：我们虽然声明了它们，但不能以任何方式使用它们。在函数的参数列表后面加上`=delete`来指出我们希望将它定义为删除的：

```c++
struct NoCopy
{
    NoCopy() = default;
    NoCopy(const NoCopy&) = delete;
    NoCopy &operator=(const NoCopy&) = delete;
    ~NoCopy() = default;
    // ...
};
```

`=delete`通知编译器以及代码的读者，我们不希望定义这些成员。

与`=default`不同，`=delete`必须出现在函数第一次声明的时候。

另外，我们可以对任何函数指定`=delete`（和`=default`不同，我们只能对编译器可以合成的默认构造函数或拷贝控制成员使用`=default`）。虽然删除函数的主要用途是禁止拷贝控制成员，但当我们希望**引导函数匹配过程**时，删除函数有时也是有用的。

****

**析构函数不能是删除的成员**：

需要注意的是，我们不能删除析构函数。如果析构函数被删除，就无法销毁此类型的对象了。对于一个删除了析构函数的类型，编译器将不允许定义该类型的变量或创建该类型的临时对象。因为如果一个成员的类型删除了析构函数，则该成员无法被销毁。而如果一个成员无法被销毁，则对象整体也就无法被销毁了。

对于删除了析构函数的类型，虽然我们不能定义这种类型的变量或成员，但可以动态分配这种类型的对象。但是不能释放这些对象。

****

**合成的拷贝控制成员可能是删除的**：

如果我们未定义拷贝控制成员，编译器会为我们定义合成的版本。类似的，如果一个类未定义构造函数，编译器会为其合成一个默认构造函数。

对某些类来说，编译器将这些合成的成员定义为删除的函数：

- 如果类的**某个成员**的析构函数是删除的或不可访问的，则类的合成析构函数被定义为删除的
- 如果类的**某个成员**的拷贝构造函数或析构函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的。
- 如果类的**某个成员**的拷贝赋值运算符是删除的或不可访问的，或是类有一个`const`成员或引用成员，则类的合成拷贝赋值运算符被定义为删除的
- 如果类的**某个成员**的析构函数是删除的或不可访问的，或是类有一个引用成员，它没有类内初始化器，或是类有一个`const`成员，它没有类内初始化器且其类型未显式定义默认构造函数，则该类的默认构造函数被定义为删除的。

从本质上来说，如果一个类有数据成员不能默认构造、拷贝、赋值或销毁，则对应的成员函数将被定义为删除的。



## 2. private 拷贝控制

我们可以将拷贝控制操作声明为`private`的来阻止拷贝。

声明为`private`的函数只有类内可以访问，而任何使用类的用户无法访问。

如果我们希望任何用户都无法访问这些函数，就仅将其声明而不定义。这样的话，如果类内的成员试图访问这些函数，则会导致编译错误以及链接错误。

