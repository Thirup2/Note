# 一. 简介

除了构造函数和赋值运算符之外，如果一个成员函数同时提供拷贝版本和移动版本，它也能从中受益。这种允许移动的成员函数通常使用与拷贝/移动构造函数和赋值运算符相同的参数模式——一个版本接受一个指向 const 的左值引用，第二个版本接受一个指向非 const 的右值引用。

例如，定义了`push_back`的标准库容器提供两个版本，假设`X`是元素类型，那么这些容器就会定义以下两个`push_back`版本：

```c++
void push_back(const X&);
void push_back(X&&);
```



# 二. 右值和左值引用成员函数

通常情况下，我们通过对象调用成员函数，而不管该对象是一个左值还是一个右值，如：

```c++
string s1 = "a value", s2 = "another";
auto n = (s1 + s2).find('a');
```

此处，`s1 + s2`得到一个右值，但它是一个`string`对象，我们仍然能够在这个右值上调用`find`成员。

****

**问题**：

这种特性有时可能使得某些令人惊讶的使用方式也成为可能，如：

```c++
s1 + s2 = "wow!";
```

我们对左边的右值进行了赋值。

由于在旧标准中，没有办法阻止这种使用方式，所以在后来的标准中，为了维持向后兼容性，新标准库类仍然允许向右值赋值。

但是，我们可能希望在自己的类中阻止这种用法，我们现在可以使用下面的解决方案。

****

**解决方案**：

在这种情况下，我们希望强制左侧运算对象（即，this 指向的对象）是一个左值。

我们可以在参数列表后放置一个**引用限定符**（reference qualifier）：

```c++
class Foo {
public:
    Foo &operator=(const Foo&) &;	// 只能向可修改的左值赋值
    // Foo 的其他内容
};
Foo &Foo::operator=(const Foo &rhs) &
{
    // 执行将 rhs 赋予本对象所需的工作
    return *this;
}
```

引用限定符可以是`&`或`&&`，分别指出`this`可以指向一个左值或右值。和`const`限定符一样，引用限定符只能用于（非 static）成员函数，且必须同时出现在函数的声明和定义中。

一个函数可以同时用`const`和引用限定，在此情况下，引用限定符必须跟随在`const`限定符之后：

```c++
class Foo {
public:
    Foo someMem() const &;
};
```

****

**重载和引用函数**：

就像一个成员函数可以根据是否有`const`来区分其重载版本一样，引用限定符也可以区分重载版本。而且，我们可以综合引用限定符和`const`来区分一个成员函数的重载版本。也就是说，下面这些函数都是可以进行重载而不发生歧义的：

```c++
class Foo {
public:
    Foo someMem();
    Foo someMem() const;
    Foo someMem() &;
    Foo someMem() &&;
    Foo someMem() const &;
    Foo someMem() const &&;
};
```



