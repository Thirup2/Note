# 一. 简介

在使用访问说明符对类成员进行访问控制后，将会引发一个问题：定义在类外的非成员函数可能会因为无法访问`private`成员而导致编译失败。

如：

```c++
std::istream &read(std::istream &is, Sales_data &item)
{
    double price = 0;
    is >> item.bookNo >> item.units_sold >> price;
    item.revenue = price * item.units_sold;
    return is;
}
```

在此例中，由于`bookNo`、`units_sold`、`revenue`都是`private`的，所以对于一个类外的非成员函数来说无访问权限，将导致编译失败。



# 二. 声明友元

解决上面问题的方法就是添加友元，向一个类中将非成员函数添加为**友元**（friend），被添加为友元的函数就能正常访问类的任何成员了。

主要的方法是往类中添加一条以`friend`关键字开始的函数声明语句即可：

```c++
class Sales_data
{
    friend Sales_data add(const Sales_data&, const Sales_data&);
    friend std::istream &read(std::istream&, Sales_data&);
    friend std::ostream &print(std::ostream&, const Sales_data&);
    /* ... */
};
```

****

**注意**：

友元只能出现在类定义的内部，但是在类内出现的具体位置不限，不论是在`private`区域还是`public`区域，其并不会限制友元的访问权限。

首先是因为友元函数本身是声明在类外的，其访问权限本身就是公开的，而类内的友元声明并非函数声明（所以如果希望类的用户能够调用某个友元函数，我们就必须另外在类外再专门对函数进行一次声明），无法限制函数的可见性；

另外一点是友元声明仅仅是为了让类外函数能够访问类内的成员，并无其他作用。



# 三. 友元声明和作用域

一个函数的作用域是从它被声明之后才开始拥有，而友元声明并不是一个函数声明，所以在友元声明之后，如果之前没有该函数的真正声明，那么该函数在真正声明之前仍然是不可见的，如：

```c++
struct X
{
    friend void f();
 	X() { f(); }			// 错误：f()并未声明
    void g();
    void h();
};
void X::g() { return f(); }		// 错误：f()并未声明
void f();
void X::h() { return f(); }		// 正确
```



# 四. 友元函数的内联性

友元函数可以在友元声明处定义，如果一个友元函数定义在类的内部，这样的函数是隐式内联的。

但是在类外还需要对已定义的友元函数进行声明，确保包含该类文件的程序能看到该函数：

```c++
struct X
{
    friend void f() { /* 定义在类内 */ }
    /* ... */
};
void f();		// 声明该函数
```

除了使用这种方式定义友元函数以得到内联性，也可以将其显式`inline`定义在函数声明之后。



# 五. 重载函数与友元

重载函数的名字相同，但是它们是不同的函数。因此，如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明：

```c++
extern std::ostream &storeOn(std::ostream &, Screen &);
extern BitMap &storeOn(BitMap &, Screen &);
class Scree
{
    friend std::ostream &storeOn(std::ostream &, Screen &);
    friend BitMap &storeOn(BitMap &, Screen &);
    /* ... */
};
```

如果只声明一个友元函数，那么将只有被声明的那个函数能够访问类的私有成员。