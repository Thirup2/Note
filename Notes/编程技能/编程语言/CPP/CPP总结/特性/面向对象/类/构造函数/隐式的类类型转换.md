# 一. 基本使用

C++ 语言在内置类型之间定义了几种自动转换规则。与此类似，我们也能为类定义隐式转换规则。

具体的实现方法是定义一种特殊的构造函数：**该构造函数只接受一个实参**，则它实际上定义了转换为次类类型的隐式转换机制。

这种函数称作**转换构造函数**（converting constructor）。

在`string`类中，我们可以将一个 C 风格字符串转换为`string`类型的对象，实际上就是`string`类定义了一个只接受 C 风格字符串的构造函数。

在有了这样一个构造函数之后，那么在程序中需要使用该类的地方，我们可以使用其他类型替代，如：

```c++
string i("string");
string s = i + " second";		// C 风格字符串将被隐式转换为 string 对象
```



# 二. 注意点

## 1. 只允许一步转换

这是一个需要注意的地方，编译器只会自动地执行一步类型转换：

假设有一个类`Sales_data`，其定义了`string`对象到该类的转换，而没有定义 C 风格字符串到该类型的转换。另外，它的一个成员函数`combine`只接受一个`Sales_data`对象的参数，则：

```c++
Sales_data item;
item.combine("9-999-99999-9");
```

将出现错误。

该例的意图是将 C 风格字符串`"9-999-99999-9"`转换成`string`对象，然后再将`string`对象转换成`Sales_data`，但是由于只允许一步转换的原则，该转换不能实现。



## 2. 类类型转换并非总有效

还是上一个例子，`Sales_data`还定义了一个从`istream`对象到`Sales_data`的转换（只接受`istream`参数的函数），那么：

```c++
Sales_data item;
item.combine(cin);
```

看上去它和将`istream`转换成`Sales_data`执行的操作相同，但是实际上，它并没有将`istream`转换成`Sales_data`。

它首先创建了一个`Sales_data`类型的临时对象，然后调用了使用`istream`为参数的构造函数，将输入的值用来初始化临时对象，然后用这个临时对象为参数来调用`combine`。



# 三. 抑制构造函数定义的隐式转换

## 1. 基本方法

有些时候我们不需要某个构造函数成为转换构造函数，此时我们可以在该构造函数前面添加`explicit`来抑制其由参数类型转换到类类型的行为。

如：

```c++
class Sales_data
{
public:
    Sales_data() = default;
    Sales_data(const std::string &s, unsigned n, double p)
        : bookNo(s), units_sold(n), revenue(p*n) { }
    explicit Sales_data(const std::string &s) : bookNo(s) { }
    explicit Sales_data(std::istream &);
    // ...
};
```

此时，没有任何构造函数能用于隐式地创建`Sales_data`对象。

****

关键字`explicit`只对一个实参的构造函数有效。需要多个实参的构造函数不能用于隐式转换，所以无须将这些构造函数指定为`explicit`的。

且只能在类内声明构造函数时使用`explicit`关键字，在类外部定义时不应重复：

```c++
explicit Sales_data:Sales_data(std::istream  &is)
{
    read(is, *this);
}
```

这个定义就是错误的。



## 2. 注意

**explicit构造函数只能用于直接初始化**：

发生隐式转换的一种情况是当我们执行拷贝形式的初始化**用一个类型的值初始化另一个类型的对象**时（使用`=`），它所执行的操作实际上是先将`=`后面的值隐式转换为对应的类型，然后再赋值给`=`左侧的对象。但由于我们将这种转换定义成了`explicit`构造函数，所以该转换不能发生，即初始化将出错，如：

```c++
string null_book;
Sales_data item1 = null_book;
```

我们只能使用直接初始化：

```c++
string null_book;
Sales_data item2(null_book);
```

当然，如果对于一个接受与类相同类型的参数的构造函数，那么这种初始化方式还是可行的：

```c++
string null_book;
Sales_data item1(null_book);
Sales_data item2 = item1;
```

****

**显式使用构造函数强制转换**：

尽管编译器不会将`explicit`的构造函数用于隐式转换过程，但是我们可以使用这样的构造函数显式地进行强制转换：

```c++
item.combine(Sales_data(null_book));
item.combine(static_cast<Sales_data>(cin));
```

实际上，这种强制转换都是通过临时量来进行的：先创建一个临时量，然后用对应的构造函数初始化这个临时量，然后再将临时量作为参数。