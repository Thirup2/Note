# 一. 简单程序的名字查找过程

在简单程序中的**名字查找**（name lookup）的过程比较直截了当：

- 首先，在名字所在的块中寻找其声明语句，只考虑在名字的使用之前出现的声明
- 如果没找到，继续查找外层作用域
- 如果最终没有找到匹配的声明，则程序报错



# 二. 类的编译过程

对于定义在类内部的成员函数来说，解析其中名字的方式与上述的查找规则有所区别：

- 首先，编译成员的声明
- 直到类全部可见后才编译函数体

即编译器处理完类中的全部声明后才会处理成员函数的定义

如果在类中未找到某个名字，将在类声明前的外层作用域继续查找。



# 三. 类中的类型名

在类中使用类型名需要注意两点：

- 只有当类型名被定义后，才能使用该类型名
- 如果在类定义的前面使用了外层作用域定义的类型名，则在其后面不能再重新定义该名字

如：

```c++
typedef double Money;
class Account
{
public:
    Money balance() { return bal; }		// 将使用第一行定义的 Money 类型
private:
    typedef double Money;			// 错误：不能重新定义
    Money bal;
};
```

因为这一点，所以类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义之后。



# 四. 成员定义中的普通块作用域的名字查找

成员函数中使用的名字按照如下方式解析：

- 首先，在**成员函数内**查找该名字的声明。和前面一样，只有在函数使用之前出现的声明才被考虑
- 如果再成员函数内没有找到，则在类内继续查找，这时类的所有成员都可以被考虑
- 如果类内也没有找到该名字的声明，在成员函数定义之前的作用域内继续查找

****

一般来说，不建议使用其他成员的名字作为某个成员函数的参数，这样会导致其覆盖某成员的名字。

如果我们导致了覆盖，也有其他办法能够访问到对应的成员，即使用作用域访问符或`this`指针：

```c++
<className>::member;
this->member;
```

同样的覆盖还可能导致覆盖掉外层作用域中的名字，如果导致了这种覆盖，同样可以使用作用域运算符访问：

```c++
::name;
```



# 五. 定义在类外的函数

当成员定义在类的外部时，名字查找的第三步不仅要考虑类定义之前的全局作用域中的声明，**还需要考虑在成员函数定义之前的全局作用域中的声明**。例如：

```c++
int height;
class Screen
{
public:
    typedef std::string::size_type pos;
    void setHeight(pos);
    pos height = 0;				// 隐藏了外层作用域中的 height
};
Screen::pos verify(Screen::pos);
void Screen::setHeight(pos var)
{
    height = verify(var);		// 其中 height 为类成员，var 为形参，verify 为全局函数
}
```

其中全局函数`verify`的声明在`Screen`类的定义之前是不可见的，所以`setHeight`成员函数不能定义在类内，只能在`verify`全局函数声明之后才能定义`setHeight`函数，因为此时可见的作用域增加了一块就是类定义结束到成员函数定义之间的区域。