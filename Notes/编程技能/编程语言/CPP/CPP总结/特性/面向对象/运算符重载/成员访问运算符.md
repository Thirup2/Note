# 一. 简介

在迭代器类及智能指针类中常常用到解引用运算符（`*`）和箭头运算符（`->`），因为这些类并不是单纯的指针，所以并没有现成的`*`和`->`运算符操作，需要自定义。

我们需要首先理解解引用运算符和箭头运算符的工作过程。对于内置类型的指针，如果我们使用`*`运算符，则会返回其指向的对象，所以这个运算符的重载比较简单，即返回其逻辑上指向的对象的引用即可。

而箭头运算符则比较复杂。对于内置类型的指针，如果它指向一个类，那么使用`->`运算符理论上还需要另一个运算对象，即要访问的成员，然后我们返回该成员的引用即可。但实际上重载的`->`运算符不接受任何参数，相当于这是一个一元的运算符，和`*`一样。

我们可以根据此时调用它所执行的操作来判断我们重载这个运算符时应该做什么：如果是一个内置指针调用`->`运算符，则直接返回该指针指向对象的成员的引用或是得到一个错误；而如果是一个定义了`operator->`类的对象调用`->`运算符，则是返回其逻辑上所指对象的指针，然后再用这个指针调用`->`运算符。

****

所以根据上面所讨论的内容，我们应该知道，重载的`*`运算符通常应该作为成员函数而且不接受其他参数，然后返回其（逻辑上）所指对象的引用。

而重载的`->`运算符必须是类的成员而且不接受其他参数，然后返回其（逻辑上）所指对象的指针，当然也可以返回一个自定义了`->`运算符的某个类的对象。

****

实际上，箭头运算符通常不执行任何自己的操作，而是调用解引用运算符并返回解引用结果元素的地址。

箭头运算符必须是**类的成员**。解引用运算符通常也是类的成员，尽管并非必须如此。

我们通常将这两个运算符定义成`const`成员，这是因为与递增和递减运算符不一样，获取一个元素并不会改变对象的状态。同时，它们的返回值应该是非常量的引用或指针。



# 二. 对箭头运算符返回值的限定

和大多数其他运算符一样，我们能令`operator*`完成任何我们指定的操作，如返回一个固定值 42，或者打印对象的内容，或者其他（虽然这样做不友好）。但箭头运算符则不是这样，它永远不能丢掉成员访问这个最基本的含义。当我们重载箭头时，可以改变的是箭头从哪个对象中获取成员，而箭头获取成员这一事实永远不会变。

对于形如`point->mem`的表达式来说，`point`必须是指向类对象的指针或者是一个重载了`operator->`的类的对象。根据`point`类型的不同，`point->mem`分别等价于：

```c++
(*point).mem;			// point 是一个内置的指针类型
point.operator->()->mem;	// point 是类的一个对象
```

除此之外，代码都将发生错误。`point->mem`的执行过程如下所示：

1. 如果`point`是指针，则我们应用内置的箭头运算符，表达式等价于`(*point).mem`。首先解引用该指针，然后从所得的对象中获取指定的成员。如果`point`所指的类型没有名为`mem`的成员，程序会发生错误。
2. 如果`point`是定义了`operator->`的类的一个对象，则我们使用`point.operator->()`的结果来获取`mem`，如果该结果是一个指针，则执行第一步；如果该结果本身含有重载的`oprator->()`，则重复调用当前步骤。最终，当这一过程结束时，程序或者返回了所需的内容，或者返回一些表示程序错误的信息。

所以重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象。

