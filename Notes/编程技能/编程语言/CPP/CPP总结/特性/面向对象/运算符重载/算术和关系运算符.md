# 一. 简介

通常情况下，我们把算术和关系运算符定义成**非成员函数**以允许对左侧或右侧的运算对象进行转换。因为这些运算符一般不需要改变运算对象的状态，所以形参都是**常量的引用**。

算术运算符通常会计算它的两个运算对象并得到一个新值，这个值有别于一个运算对象，常常位于一个局部变量之内，操作完成后返回该局部变量的副本作为其结果。如果类定义了算术运算符，则它一般也会定义一个对应的复合赋值运算符。此时，最有效的方式是使用复合赋值来定义算术运算符：

```c++
Sales_data operator+(const Sales_data &lhs, const Sales_data &rhs)
{
    Sales_data sum = lhs;
    sum += rhs;
    return sum;
}
```



# 二. 相等运算符

通常情况下，C++ 中的类通过定义相等运算符来检验两个对象是否相等。也就是说，它们会比较对象的每一个数据成员，只有当所有对应的成员都相等时才认为两个对象相等。

相等性运算符的设置准则如下：

- 如果一个类含有判断两个对象是否相等的操作，则它显然应该把函数定义为`operator==`而非一个普通的命名函数：因为用户肯定希望能使用`==`比较对象，所以提供了`==`也就意味着用户无须再费时费力地学习并记忆一个全新的函数名字。此外，类定义了`==`运算符之后也更容易使用标准库容器和算法
- 如果类定义了`operator==`，则该运算符应该能判断一组给定的对象中是否含有重复数据
- 通常情况下，相等运算符应该具有传递性，即如果`a==b`和`b==c`都为真，那么`a==c`也应该为真
- 如果类定义了`==`，则这个类也应该定义`!=`。对于用户来说，当它们使用`==`时肯定也希望能使用`!=`，反之亦然
- 相等运算符和不相等运算符中的一个应该把工作委托给另一个，这意味着其中一个运算符应该负责实际比较对象的工作，而另一个运算符则只是调用那个真正工作的运算符。



# 三. 关系运算符

定义了相等性运算符的类也常常（但不总是）包含关系运算符。特别是，因为关联容器和一些算法要用到小于运算符，所以定义`operator<`会比较有用。

通常情况下关系运算符应该：

- 定义顺序关系，令其与关联容器中对关键字的要求一致
- 如果类同时也含有`==`运算符的话，则定义一种关系令其与`==`保持一致。特别是，如果两个对象是`!=`的，那么一个对象应该`<`另外一个。