# 一. 简介

我们可能会想重载一个函数调用运算符的意义是什么。实际上，如果类重载了函数调用运算符，则我们可以像使用函数一样使用该类的对象。因为这样的类同时也能存储状态，所以与普通函数相比它们更加灵活。

举个简单的例子，下面这个名为`absInt`的`struct`含有一个调用运算符，该运算符负责返回其参数的绝对值：

```c++
struct absInt
{
    int operator()(int val) const {
        return val < 0 ? -val : val;
    }
};
```

这个类只定义了一种操作：函数调用运算符，它负责接受一个`int`类型的实参，然后返回该实参的绝对值。

我们使用调用运算符的方式是令一个`absInt`对象作用于一个实参列表，这一过程看起来非常像调用函数的过程：

```c++
int i = -42;
absInt absObj;
int ui = absObj(i);
```

即使`absObj`只是一个对象而非函数，我们也能 “调用” 该对象。调用对象实际上是在运行重载的调用运算符。在此例中，该运算符接受一个`int`值并返回其绝对值。

****

函数调用运算符必须是**成员函数**，一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别。

如果类定义了调用运算符，则该类的对象称作**函数对象**（function object）。



# 二. 含有状态的函数对象类

和其他类一样，函数对象类除了`operator()`之外也可以包含其他成员。函数对象类通常含有一些数据成员，这些成员被用于定制调用运算符中的操作。

举个例子，我们将定义一个打印`string`实参内容的类。默认情况下，我们的类会将内容写入到`cout`中，每个`string`之间以空格隔开。同时也允许类的用户提供其他可写入的流及其他分隔符。类的定义如下：

```c++
class PrintString {
public:
    PrintString(ostream &o = cout, char c = ' ')
        :os(o), sep(c) { }
    void operator()(const string &s) const { os << s << sep; }
private:
    ostream &os;
    char sep;
};
```

当定义`PrintString`的对象时，对于分隔符及输出流既可以使用默认值也可以提供我们自己的值：

```c++
PrintString printer;
printer(s);			// 在 cout 中打印 s，后面跟一个空格
PrintString errors(cerr, '\n');
errors(s);			// 在 cerr 中打印 s，后面跟一个换行符
```

函数对象常常作为泛型算法的实参。例如，可以使用标准库`for_each`算法和我们自己的`PrintString`类来打印容器的内容：

```c++
for_each(vs.begin(), vs.end(), PrintString(cerr, '\n'));
```

`for_each`的第三个实参是类型`PrintString`的一个临时对象，其中我们用`cerr`和换行符初始化了该对象。当程序调用`for_each`时，将会把`vs`中的每个元素依次打印到`cerr`中，元素之间以换行符分隔。



# 三. lambda 是函数对象

实际上，当我们编写了一个`lambda`后，编译器将该表达式翻译成一个未命名类的未命名对象。在`lambda`表达式产生的类中含有一个重载的函数调用运算符，例如，下面的这个`lambda`表达式：

```c++
[](const string &a, const string &b) {
    return a.size() < b.size();
}
```

其行为类似于下面这个类的一个未命名对象：

```c++
class ShorterString {
public:
    bool operator() (const string &s1, const string &s2) const
    { return s1.size() < s2.size(); }
};
```

产生的类只有一个函数调用运算符成员，它负责接受两个`string`并比较它们的长度，它的形参列表和函数体与`lambda`表达式完全一样。且和我们所知道的一样，在默认情况下`lambda`不能改变它捕获的变量，所以在默认情况下，由`lambda`产生的类当中的函数调用运算符是一个`const`成员函数。如果`lambda`被声明为可变的，则调用运算符就不是`const`的了。

如果创建了这个类，我们就能直接将`ShorterString()`表达式替换掉整个`lambda`表达式了。需要注意的是，这里`ShorterString()`并不是一个函数调用，而是创建一个临时对象。

****

另外，`lambda`可以通过引用捕获变量，并由程序负责确保`lambda`执行时引用所引的对象确实存在。因此，编译器可以直接使用该引用而无须在`lambda`产生的类中将其存储为数据成员。

相反，通过值捕获的变量被拷贝到`lambda`中。因此，这种`lambda`产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数，令其使用捕获的变量的值来初始化数据成员。

如，下面的`lambda`表达式：

```c++
[sz](const string &a) {
    return a.size() >= sz;
}
```

该`lambda`表达式产生的类将形如：

```c++
class SizeComp {
    SizeComp(size_t n): sz(n) { }
    bool operator()(const string &s) const
    {return s.size() >= sz; }
private:
    size_t sz;
};
```

这个类具有了一个数据成员，并且不包含有默认构造函数，因此要想使用这个类必须提供一个实参：

```c++
auto wc = find_if(words.begin(), words.end(), SizeComp(sz));
```

`lambda`表达式产生的类不含默认构造函数、赋值运算符及默认析构函数；它是否含有默认的拷贝/移动构造函数则通常要视捕获的数据成员类型而定。



# 四. 标准库定义的函数对象

标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符。例如，`plus`类定义了一个函数调用运算符用于对一对运算对象执行`+`的操作；`modulus`类定义了一个调用运算符执行二元的`%`操作；`equal_to`类执行`==`，等等。

这些类都被定义成模板的形式，我们可以为其指定具体的应用类型，这里的类型即调用运算符的形参类型。例如，`plus<string>`令`string`加法运算符作用于`string`对象；`plus<int>`的运算对象是`int`；`plus<Sales_data>`对`Sales_data`对象执行加法运算，以此类推。

在头文件`<functional>`中定义了所有这些模板：

| 算术               | 关系                  | 逻辑                |
| ------------------ | --------------------- | ------------------- |
| `plus<Type>`       | `equal_to<Type>`      | `logical_and<Type>` |
| `minus<Type>`      | `not_equal_to<Type>`  | `logical_or<Type>`  |
| `multiplies<Type>` | `greater<Type>`       | `logical_not<Type>` |
| `divides<Type>`    | `greater_equal<Type>` |                     |
| `modulus<Type>`    | `less<Type>`          |                     |
| `negate<Type>`     | `less_equal<Type>`    |                     |

****

说实话刚看到这些类的时候，很难让人不去想实现这些东西的意义在哪。但仔细一想，实际上它在标准库算法中似乎能很有用。

表示运算符的函数对象类常用来替换算法中的默认运算符。在默认情况下排序算法使用`operator<`将序列按照升序排列。如果要执行降序排列的话，我们可以传入一个`greater`类型的对象。该类将产生一个调用运算符并负责执行待排序类型的大于运算。

需要特别注意的是，标准库规定其函数对象对于指针同样适用。一般来说比较两个无关指针将产生为定义的行为，然而我们可能会希望通过比较指针的内存地址来`sort`指针的`vector`。直接这么做将产生未定义的行为，因此我们可以使用一个标准库函数对象来实现该目的：

```c++
vector<string *> nameTable;
sort(nameTable.begin(), nameTable.end(), less<string*>());
```



# 五. 可调用对象与 function

C++ 语言中有几种可调用的对象：函数、函数指针、lambda 表达式、bind 创建的对象以及重载了函数调用运算符的类。

和其他对象一样，可调用的对象也有类型。每个`lambda`有它自己唯一的（未命名）类类型；函数及函数指针的类型则由其返回值类型和实参类型决定，等等。

两种不同类型的可调用对象可能共享同一种**调用形式**（call signature），但是在明确要求为一种类型的可调用对象的地方不能使用其他的类型的可调用对象，即使它们的调用形式相同。例如一个声明为`map<string, int(*)(int, int)> binops;`的`map`对象只能接受同类型的函数和函数指针，而不能使用调用形式相同的`lambda`表达式或者重载了调用运算符的类，因为它们的类型不是声明的类型。

有时我们只需要一个地方有相同调用形式的可调用对象，而不关心它是何种类型的可调用对象，我们可以使用一个名为 **function** 的新的标准库类型解决上述问题，`function`定义在`<functional>`头文件中，下表列出了`function`定义的成员类型以及操作：

| 定义为`function<T>`的成员的类型                              | 描述                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| `result_type`                                                | 该`function`类型的可调用对象返回的类型                       |
| `argument_type`<br />`first_argument_type`<br />`second_argument_type` | 当`T`有一个或两个实参时定义的类型。<br />如果`T`只有一个实参，则`argument_type`是该类型的同义词；<br />如果`T`有两个实参，则`first_argument_type`和`second_argument_type`分别代表两个实参的类型 |

| 操作                     | 描述                                                         |
| ------------------------ | ------------------------------------------------------------ |
| `function<T> f`          | `f`是一个用来存储可调用对象的空`function`，<br />这些可调用对象的调用形式应该与函数类型`T`相同（即`T`是`retType(args)`） |
| `function<T> f(nullptr)` | 显式地构造一个空`function`                                   |
| `function<T> f(obj)`     | 在`f`中存储可调用对象`obj`的副本                             |
| `f`                      | 将`f`作为条件：当`f`含有一个可调用对象时为真；否则为假       |
| `f(args)`                | 调用`f`中的对象，参数是`args`                                |

****

`function`是一个模板，和我们使用过的其他模板一样，当创建一个具体的`function`类型时我们必须提供额外的信息。在此例中，所谓额外的信息是指该`function`类型能够表示的对象的调用形式。参考其他模板，我们在一对尖括号内指定类型：

```c++
function<int(int, int)>
```

在这里我们声明了一个`function`类型，它可以表示接受两个`int`，返回一个`int`的可调用对象。因此，我们可以用这个新声明的类型表示任意一种相同调用形式的可调用对象的类型；

```c++
function<int(int, int)> f1 = add;		// 函数指针
function<int(int, int)> f2 = divide();		// 函数对象类的对象
function<int(int, int)> f3 = [](int i, int j)	// lambda
							 { return i * j; }
cout << f1(4, 2) << endl;
cout << f2(4, 2) << endl;
cout << f3(4, 2) << endl;
```

****

**重载的函数与 function**：

我们不能（直接）将重载函数的名字存入`function`类型的对象中：

```c++
int add(int i, int j) { return i + j; }
Sales_data add(const Sales_data&, const Sales_data&);
map<string, function<int(int, int)>> binops;
binops.insert( {"+", add});
```

由于我们有两个`add`函数，虽然其调用形式不同以致于可以重载，但是在最后一行中我们无法判断添加的`add`究竟说的是哪一个`add`函数。

我们有下面的方法来解决上面操作的二义性：

- 存储函数指针而非函数的名字：

  ```c++
  int (*fp)(int, int) = add;
  binops.insert( {"+"， fp} );
  ```

- 使用 lambda

  ```c++
  binops.insert( {"+", [](int a, int b) { return add(a, b;) } } );
  ```

  在传入的 lambda 表达式中，我们直接调用了一个`add`函数，这样它就会进行函数匹配，找到我们使用的真正的函数。