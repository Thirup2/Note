# 一. 基本概念

重载的运算符是具有特殊名字的**函数**：它们的名字由关键字`operator`和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。

重载运算符函数的**参数数量**与该运算符作用的运算对象数量一样多。一元运算符有一个参数，二元运算符有两个。对于二元运算符来说，左侧运算对象传递给第一个参数，而右侧运算对象传递给第二个参数。除了重载的函数调用运算符`operator()`之外，其他重载运算符不能含有默认实参。

如果一个运算符函数是**成员函数**，则它的第一个（左侧）运算对象绑定到隐式的`this`指针上，因此，成员运算符函数的（显式）参数数量比运算符的运算对象总数少一个。

对于一个运算符函数来说，它或者是**类的成员**，或者至少包含一个**类类型的参数**，而不能对内置类型的运算符进行重载。

我们只能重载**已有的**运算符，而无权发明新的运算符号。

有四个符号（`+`、`-`、`*`、`&`）既是一元运算符也是二元运算符，所有这些运算符都能被重载，从参数的数量我们可以推断到底定义的是哪种运算符。

对于一个重载的运算符来说，其**优先级**和**结合律**与对应的内置运算符保持一致。



# 二. 可重载运算符

**可以**被重载的运算符如下表所示：

| 运算符               | 运算符              | 运算符 | 运算符  | 运算符   | 运算符                    |
| -------------------- | ------------------- | ------ | ------- | -------- | ------------------------- |
| `+`                  | `-`                 | `*`    | `/`     | `%`      | `^`                       |
| `&`                  | <code>&#124;</code> | `~`    | `!`     | `,`      | `=`                       |
| `<`                  | `>`                 | `<=`   | `>=`    | `++`     | `--`                      |
| `<<`                 | `>>`                | `==`   | `!=`    | `&&`     | <code>&#124;&#124;</code> |
| `+=`                 | `-=`                | `/=`   | `%=`    | `^=`     | `&=`                      |
| <code>&#124;=</code> | `*=`                | `<<=`  | `>>=`   | `[]`     | `()`                      |
| `->`                 | `->*`               | `new`  | `new[]` | `delete` | `delete[]`                |

还有几个**不能被重载**的运算符：

- `::`
- `.*`
- `.`
- `?:`

****

除此之外，某些运算符即使在可重载名单中也不建议对其重载。如某些运算符指定了运算对象求值的顺序，如`&&`、`||`、`,`运算符，这些运算符所规定的求值顺序在重载之后无法保留下来。特别是`&&`和`||`运算符除了求值顺序，它们的短路求值策略也无法保留。

因为上述运算符的重载版本无法保留求值顺序和/或短路求值属性，因此不建议重载它们。当代码使用了这些运算符的重载版本时，用户可能会突然发现他们一直习惯的求值规则不再适用了。

另外对于取地址符`&`和逗号运算符`,`我们一般也不重载：C++ 已经定义好了这两种运算符用于类类型对象时的特殊含义，这一点与大多数运算符都不相同。



# 三. 重载运算符函数的调用

通常情况下，我们将运算符作用于类型正确的实参，从而以这种方式间接调用重载的运算符函数：

```c++
data1 + data2;
```

然而，我们也能像调用普通函数一样直接调用运算符函数：

```c++
operator+(data1, data2);
```



# 四. 重载运算符设计准则

## 1. 使用与内置类型一致的含义

如果某些操作在逻辑上与运算符相关，则它们适合于定义成重载的运算符：

- 如果类执行 IO 操作，则定义移位运算符使其与内置类型的 IO 保持一致
- 如果类的某个操作是检查相等性，则定义`operator==`；如果类有了`operator==`，意味着它通常也应该有`operator!=`
- 如果类包含一个内才的单序比较操作，则定义`operator<`；如果类有了`operator<`，则它也应该含有其他关系操作。
- 重载运算符的返回类型通常情况下应该与其内置版本的返回类型兼容：逻辑运算符和关系运算符应该返回`bool`，算术运算符应该返回一个类类型的值，赋值运算符和复合赋值运算符应该返回左侧运算对象的一个引用。



## 2. 赋值和符合赋值运算符

赋值运算符的行为和复合版本的类似：赋值之后，左侧运算对象和右侧运算对象的值相等，并且运算符应该返回它左侧运算对象的一个引用。重载的赋值运算应该继承而非违背其内置版本的含义。

如果类含有算术运算符或者位运算符，则最好也提供对应的符合赋值运算符。



## 3. 选择作为成员或者非成员

当我们定义重载的运算符时，必须首先决定是将其声明为类的成员函数还是声明为一个普通的非成员函数。在某些时候我们别无选择，因为有的运算符必须作为成员；另一些情况下，运算符作为普通函数比作为成员更好。

下面的准则有助于我们在将运算符定义为成员函数还是普通的非成员函数做出抉择：

- 赋值（`=`）、下标（`[]`）、调用（`()`）和成员访问箭头运算符（`->`）必须是成员
- 符合赋值运算符一般来说应该是成员，但并非必须，这一点与赋值运算符略有不同
- 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员
- 具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，因此它们通常应该是普通的非成员函数。