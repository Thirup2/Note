# 一. 简介

我们可以通过定义一个只接受一个实参的非显式构造函数定义从其他类型到类类型的隐式转换，我们也可以通过添加`explicit`关键字避免隐式转换，从而要求只使用`ClassName()`这种构造对象形式或者`static_cast`形式的显式转换。

而定义一个类型转换运算符则可以定义从类类型到其他类型的类型转换，且默认可以是隐式转换，同样的我们可以通过添加`explicit`关键字避免隐式转换，以要求只使用`Type()`形式或`static_cast`形式的显式转换。

转换构造函数和类型转换运算符共同定义了**类类型转换**（class-type conversions），这样的转换有时也被称作**用户定义的类型转换**（user-defined conversions）。需要注意的是，编译器一次只能执行一个用户定义的类型转换，但是隐式的用户定义类型转换可以置于一个标准（内置）类型转换之前或之后，并与其一起使用。

类型转换运算符的重载形式如下：

```c++
operator type() const;
```

其中`type`表示某种类型。类型转换运算符可以面向任意类型（除了`void`之外）进行定义，只要该类型能作为函数的返回类型。因此，我们不允许转换成数组或者函数类型，但允许转换成指针或者引用类型。

类型转换运算符**没有显式的返回类型**，也**没有形参**，而且必须定义成类的**成员函数**。并且类型转换运算符通常不应该改变待转换对象的内容，因此，类型转换运算符一般被定义成 const 成员。另外，虽然类型转换运算符没有显式的返回类型，但实际上每个类型转换函数都会返回一个对应类型的值。

一个含有类型转换运算符的示例如下：

```c++
class SmallInt {
public:
    SmallInt(int i = 0): val(i)
    {
        if (i < 0 || i > 255)
            throw std::out_of_range("Bad SmallInt value");
    }
    operator int() const { return val; }
private:
    std::size_t val;
};
```

这个类只保存 0 ～ 255 之间的一个数，相当于一个新的整数类型，我们叫它`SmallInt`也就是 “小整数” 类型。它可以从`int`转换为小整数类型，也可以从小整数类型转换为`int`类型。



# 二. 隐式转换

在不添加`explicit`关键字时，用户定义的类型转换都是隐式转换（也可以用显式转换的形式），这代表我们可以如下使用：

```c++
SmallInt si;
si = 4;			// 先将 4 转换为 SmallInt，然后赋值给 si
si + 3;			// 由于我们的 si 没有重载 + ，所以这个 + 是 int 的 + ，于是先将 si 转换为 int，然后与 3 相加
```

用户定义的类型转换编译器一次只能执行一个（隐式转换形式），但是隐式的用户定义类型转换可以置于一个内置类型转换之前或之后，并与其一起使用，如：

```c++
SmallInt si = 3.14;		// 先将 3.14 转换为 int（内置隐式转换），然后 int 转换为 SmallInt（用户定义隐式转换）
si + 3.14;			// 先将 si 转换为 int（用户定义隐式转换），然后 int 转换为 double（内置隐式转换）
```



# 三. 显式类型转换

在实践中，类很少提供类型转换运算符。在大多数情况下，如果类型转换自动发生，用户可能会感觉到比较意外，而不是感觉受到了帮助。然而这条经验法则存在一种例外情况：对于类来说，定义向 bool 的类型转换还是比较普遍的现象。

但是在早期的 C++ 中，如果类想定义一个向 bool 的类型转换，则它常常会遇到一个问题：因为 bool 是一种算术类型，所以类类型的对象转换成 bool 后就能被用在任何需要算术类型的上下文中。这样的类型转换可能引发意想不到的结果，例如下面的代码：

```c++
int i = 42;
cin << i;
```

很显然，我们是想读取一个整数到`i`中，但如果`cin`会自动转换为 bool 类型，那么此时的行为就是`cin`先转换为 bool 类型值，然后将其向左移`i`位，很明显这与我们的想法大相径庭。

为了解决这个问题，C++ 11 标准引入了**显式的类型转换运算符**（explicit conversion operator）：

```c++
class SmallInt {
public:
    explicit operator int() const { return val; }
};
```

和显式的构造函数一样，编译器也不会将一个显式的类型转换运算符用于隐式类型转换：

```c++
SmallInt si = 3;		// 正确：此处调用的是构造函数，构造函数并不是隐式的
static_cast<int>(si) + 3;	// 正确：显式请求类型转换
```

当类型转换运算符是显式的时，我们也能执行类型转换，不过必须通过显式的强制类型转换才可以。

另外，该规定存在一个例外，即如果表达式被用作条件，则编译器会将显式的类型转换自动应用于它。换句话说，当表达式出现在下列位置时，显式的类型转换将被隐式地执行：

- `if`、`while`即`do`语句的条件部分
- `for`语句头的条件表达式
- 逻辑非运算符（`!`）、逻辑或运算符（`||`）、逻辑与运算符（`&&`）的运算对象
- 条件运算符（`?:`）的条件表达式



# 四. 避免二义性转换

如果类中包含一个或多个类型转换，则必须确保在类类型和目标类型之间只存在唯一一种转换方式，否则，我们编写的代码将很可能具有二义性。

在两种情况下可能产生多重转换路径。

- 第一种情况是两个类提供相同的类型转换：例如，当 A 类定义了一个接受 B 类对象的转换构造函数，同时 B 类定义了一个转换目标是 A 类的类型转换运算符时，我们就说他们提供了相同的类型转换。因为这两种转换实际上是同一个转换的两个（可能）不同的实现

  当这种情况出现的时候，通过实参匹配是无法判断该调用的是哪一个函数的，如果我们确实想调用，就不得不显式地调用类型转换运算符或者构造函数：

  ```c++
  b.operator A();		// 注意：不能使用 A() 的形式，这种调用方式和下面的方式相同
  A(b);
  ```

  另外，我们还不能使用强制类型转换的方式来解决二义性问题，因为强制类型转换本身也面临二义性，即无法判断调用哪一个函数。

- 第二种情况是类定义了多个转换规则，而这些转换涉及的类型本身可以通过其他类型转换联系在一起。最典型的例子是算术运算符，对某个给定的类来说，最好只定义一个与算术类型有关的转换规则，然后让标准类型转换完成其他算术类型转换的工作。

****

**重载函数与转换构造函数**：

除了上述情况之外，还有一种情况也将可能导致二义性——重载函数。

当我们调用重载的函数时，从多个类型转换中进行选择将变得更加复杂。如果两个或多个类型都提供了同一种可行匹配，则这些类型转换一样好。

举个例子，当几个重载函数的参数分属不同的类类型时，如果这些类恰好定义了同样的转换构造函数，则二义性问题将进一步提升：

```c++
struct C {
    C(int);
};
struct D {
    D(int);
};
void manip(const C&);
void manip(const D&);
manip(10);		// 二义性错误
```

其中`C`和`D`都包含`int`的构造函数，两个构造函数各自匹配`manip`的一个版本。因此调用将具有二义性：它的含义可能是把`int`转换为`C`，然后调用`manip`的第一个版本；也可能是把`int`转换为`D`，然后调用`manip`的第二个版本。

调用者可以显式地构造正确的类型从而消除二义性：

```c++
manip(C(10));
```

然而，如果在调用重载函数时我们需要使用构造函数或者强制类型转换来改变实参的类型，这通常意味着程序的设计存在不足。

