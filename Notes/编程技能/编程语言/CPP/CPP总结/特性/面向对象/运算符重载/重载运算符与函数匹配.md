显然，重载的运算符也是重载的函数。因此，通用的函数匹配规则同样适用于判断在给定的表达式中到底应该使用内置运算符还是重载的运算符。

但是，运算符的重载与普通函数的重载多了一个不确定因素，如果`a`是一个类类型对象，当我们使用`a sym b`这个表达式时，它可能是下面两种情况中的一种：

```c++
a.operatorsym(b);
operatorsym(a, b);
```

和普通函数调用不同，我们不能通过调用的形式来区分当前调用的是成员函数还是非成员函数。另外，如果类提供了转换目标是算术类型的类型转换，也提供了重载的运算符，那么还可能与内置的运算符产生二义性问题。

如，我们首先为`SmallInt`类定义一个加法运算符：

```c++
class SmallInt {
    friend SmallInt operator+(const SmallInt&, const SmallInt &);
public:
    SmallInt(int = 0);
    operator int() const { return val; }
private:
    std::size_t val;
};
```

此时我们再像下面这样调用`+`运算符：

```c++
SmallInt s3 = 42;
int i = s3 + 0;
```

此时就将会导致二义性错误，因为我们无法判断这个`+`是内置的`+`运算符还是重载的`+`运算符。

****

**解决成员函数二义性的问题**：

这个问题的解决方案比较简单，一种是在调用时用函数的形式调用，这样是成员函数还是非成员函数就一清二楚了，但很显然，这样的调用方法违背了重载运算符的初衷；

另一个方法就是对同一个运算符的重载不要同时用成员函数和非成员函数，要么都重载为成员函数，要么都重载为非成员函数。

**解决与内置运算符的二义性问题**：

这个问题没有太多的解决方案，在遇到这个问题时，我们首先要做的是反思自己的设计在哪些地方出了问题，如果实在没有办法，我们仍然可以使用函数调用的形式来使用重载的运算符，但是我们没有办法调用内置的运算符。