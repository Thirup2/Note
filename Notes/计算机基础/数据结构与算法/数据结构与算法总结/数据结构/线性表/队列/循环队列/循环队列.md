# 一. 简介

队列的顺序实现即用数组实现的队列结构，我们用两个指针指向队头和队尾，在队头删除队尾插入。但是使用数组像这样实现的队列有一个巨大的缺陷。我们在数组开始的位置进行删除元素，删除元素之后，队头指针将指向后面的元素将其作为新的队头，当我们的队尾到达数组尾端时，我们就无法再向队列中插入元素了，但实际上我们的队列如果进行过删除元素操作，此时应该是处于未满状态，这将严重浪费空间并且逐渐缩小队列的大小。

所以我们使用另一种数组的实现方法，即将数组当作一个环，我们可以通过计算逻辑位置的方式实现。



# 二. 实现

```c
#define MAXSIZE 100
typedef struct {
    ElemType data[MAXSIZE];
    int front;		// 队头指针
    int rear;		// 队尾指针
} SqQueue;
```



# 三. 操作

## 1. 创建

在创建一个循环队列之前，我们需要定义好两个指针`front`和`rear`的位置。事实上我们有多种选择，比如`front`指向队头元素，`rear`指向队尾元素；或者`front`指向队头元素而`rear`指向尾后位置等。但按照习惯我们通常在队空时让`front`和`rear`指向同一个位置，它们并不一定是为 -1 或者说为 0（虽然通常为 0，即数组第一个元素的下标），因为我们实现的是循环队列。

同时也正因为我们实现的是循环队列，所以在队满时`front`和`rear`也可能是指向同一个位置，此时我们就需要一个额外的成员来判定此时是队空还是队满。当然我们也可以空出一个元素的位置，这样在队空和队满时的状态就不一样了，我们将详细描述这几种方法：

- 牺牲一个单元来区分队空和队满，入队时少用一个队列单元，这是一种较为普遍的做法。当`front == rear`时则队空，当`rear + 1 == front`（注意这里的`+1`不是数学意义上的`+1`，而表示下一个位置，接下来会详细说明这个`+1`在代码中的表示方法）为队满
- 在结构中增加一个成员来区分队满和队空，这个成员可以是队列的长度，也可以是一个布尔值。如果是队列的长度，则长度为零时队空，长度为`MAXSIZE`时队满；如果是一个布尔值，则分别用它的两个状态来代表队满和队空即可。



## 2. 左右相邻位置的计算

由于我们实现的是一个循环队列，当我们在删除和插入以及判断队空队满时都需要计算左右相邻的位置实际上的下标值而不是简单的`+1`或者`-1`。

- 当我们对一个位置进行`+1`时，其结果可能超过`MAXSIZE - 1`，这些下标都是非法的下标。我们可以通过将`+1`的结果对`MAXSIZE`求模来获得`+1`后的下标值，代码如下：

  ```c
  (position + 1) % MAXSIZE
  ```

- 当我们对一个位置进行`-1`时也是一样的。可以想到方法还是对`MAXSIZE`求模，但由于`-1`操作还可能导致出现负数，所以我们要先对`-1`的结果加上一个`MAXSIZE`，然后再求模：

  ```c
  (position - 1) % MAXSIZE
  ```



## 3. 插入

我们初始状态下，习惯上将`front`和`rear`指向同一个位置，通常是数组的第一个元素的位置。此时插入元素先在`rear`处插入，然后递增`rear`的值就行了，该状态下，`rear`永远指向队尾元素的下一位置。另外需要记住`+1`操作的实际代码。

在插入前我们还应该先判断是否队满，如果队满应该返回相应状态并退出。



## 4. 删除

首先判断是否队空，如果是，则返回相应状态并退出。

然后队列的删除操作只能在队头，所以我们只需要将队头指针`+1`即可，前面的元素虽然还存在数组里，但逻辑上是被删除的状态。`front`应该永远指向队头元素或者与`rear`指向同一位置（此时队空或队满）。