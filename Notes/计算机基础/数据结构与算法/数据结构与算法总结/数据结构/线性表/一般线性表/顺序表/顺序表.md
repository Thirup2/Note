# 一. 简介

顺序表是线性表中最简单的一种表结构。它指的是使用物理上连续的内存来存放逻辑上连续的元素。在 C 语言中，顺序表的实现通常使用数组类型，由于 C 语言数组的性质，这导致用数组实现的顺序表其大小无法更改。

当然，我们也可以使用 C 标准库中的动态分配内存方法来灵活分配数组的大小，并在需要的时候进行扩张和收缩。这种方法的好坏取决于其扩张和收缩的策略如何，一个比较理想的策略是当数组的空间装满了元素之后，将其空间扩张为原本的 2 倍，然后在数组中元素个数小于数组大小的 1/2 时，将其空间收缩为原本的 1/2。这样做既避免了每一次插入都分配内存的消耗，也避免了删除元素后产生的空间浪费。当然，这个扩张和收缩的策略可以根据实际情况灵活决定。

可以说使用动态分配内存是一个比较理想的顺序表实现方法，但对于 C/C++ 来说，它有一个比较大的缺陷，就是必须人工管理内存。如果内存管理不到位就可能发生内存泄漏等一系列问题。C++ 现在可以通过智能指针来管理动态分配的内存，算是一个比较好的管理方法，但是对于 C 语言来说，仍然需要人工管理内存，或者自己实现一个类似于 C++ 智能指针的类来管理内存。



# 二. 实现

## 1. 静态实现

```c
#define MAXSIZE 10		// 最大元素个数
struct list
{
    ElemType data[MAXSIZE];			// 元素内容
    int length;					// 表长
};
typedef struct list SeqList;
```



## 2. 动态实现

```c
#define INITSIZE 10		// 初始化时元素个数
struct list
{
    ElemType *data;			// 指向动态内存的指针
    int capacity;			// 数组容量
    int length;				// 表长
};
typedef struct list SeqList;
```



# 三. 操作分析

- 按值查找

  对于无序表来说，那么通常需要遍历整个表来查找，其时间复杂度为 $O(n)$，或者先将其排序再进行查找，其时间复杂度为选择的排序算法和查找算法的叠加。

  对于有序表，那么其时间复杂度则取决于使用的查找算法的时间复杂度。

- 按位查找

  对于顺序表来说，按位查找的时间复杂度都是 $O(1)$

- 插入

  由于需要维护线性表的定义，所以如果在头部插入需要移动所有后面的元素，其时间复杂度是 $O(n)$（可以将数组当作一个循环表使用来将此操作的时间复杂度变为 $O(1)$，此方法需要注意位序的换算以及只能使用静态分配的数组）；

  在顺序表的末尾插入元素的时间复杂度为 $O(1)$；

  平均的时间复杂度为 $O(n)$

- 删除

  删除元素的时间复杂度和插入元素相同