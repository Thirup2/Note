# 一. 简介

**链栈**是栈的链式实现方法，其主要特点如下：

- 大小灵活，唯一的空间问题仅仅是链结构需要的指针域会占用一部分空间
- 对于栈这种特殊的线性表来说，链表的缺点得到了隐藏，因为不需要对栈内部的内容进行操作

> 由于链栈相对于顺序栈来说多出了一部分空间占用，但牺牲这部分空间是为了更高的灵活性。当然，也可以采用其他的解决方法，比如变长数组。
>
> 一般来说，如果栈的长度很容易确定且变化很小，那么采用顺序栈会更好，如果栈的长度难以确定或经常变化，那么链栈就比较合适。



# 二. 代码实现

## 1. 概念实现

- **栈顶**：用链表的哪一端作为栈顶？由于我们增删查都在栈顶进行，很明显，用操作最方便的一端作为栈顶最好，即头结点位置作为栈顶。
- **栈底**：即最后一个结点，该结点的链应该指向 NULL
- **空栈、栈满、栈长**：遍历栈即可



## 2. 代码

- 数据元素类型

  ```c
  typedef struct items ElemType;		// 基础数据元素类型，struct items自行定义
  typedef ElemType *PtrElem;		// 一般数据元素指针
  typedef const ElemType *cPtrElem;		// 指向常量的数据元素指针
  ```
  
- 结点类型

  ```c
  struct node
  {
      ElemType data;
      struct node *next;
  };
  typedef struct node Node;
  typedef Node *PtrNode;
  typedef const Node *cPtrNode;
  ```

- 链栈类型

  ```c
  struct stack
  {
      PtrNode top;
  };
  typedef struct stack Stack;
  typedef Stack *PtrStack;
  typedef const Stack *cPtrStack;
  ```



# 三. 难点操作

- 压栈

  ```c
  Status Push(PtrStack stack, cPtrElem elem)
  {
      PtrNode now = (PtrNode) malloc(sizeof(Node));
      if (!now) {
          exit(EXIT_FAILURE);
      }
      AssignElem(&now->data, elem);
      now->next = stack->top;
      stack->top = now;
      return SUCCESS;
  }
  ```

- 弹栈

  ```c
  Status Pop(PtrStack stack, PtrElem elem)
  {
      if (StackEmpty(stack)) {
          return ISEMPTY;
      }
      AssignElem(elem, &stack->top->data);
      PtrNode p = stack->top;
      stack->top = p->next;
      free(p);
      return SUCCESS;
  }
  ```

