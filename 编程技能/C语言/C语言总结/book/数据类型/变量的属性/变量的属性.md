# 一. 作用域
## 1. 代码块作用域

> - **C99**: 在C99之前，具有块作用域的变量都必须声明在块的开头，而C99标准允许在块中的任意位置声明变量

- 位置
位于一对花括号之间的所有语句称为一个代码块。任何在代码块的开始位置声明的标识符都具有代码块作用域，表示它们可以被这个代码块中的所有语句访问。

- 函数定义的形式参数在函数体内部也具有代码块作用域。

> - **K&R C**：在K&R C中，函数形参的作用域开始于形参的声明处，位于函数题之外。如果在函数体内部声明了名字和形参相同的局部变量，它们就将隐藏形参。这样一来，形参便无法被函数的任何部分访问。
> - **ANSI C**：标准把形参的作用域设定为函数最外层的那个作用域（也就是整个函数体）。这样，声明于函数最外层作用域的局部变量无法和形参同名，因为它们的作用域相同。

## 2. 文件作用域
- 位置
任何在所有代码块之外声明的标识符都具有文件作用域，它表示这些标识符从它们的声明之处直到它所在的源文件结尾处都是可以访问的。

- 在文件中定义的函数名也具有文件作用域，因为函数名本身并不属于任何代码块。

- 在头文件中编写并通过`#include`指令包含到其他文件中的声明就好像它们是直接写在那些文件中一样。它们的作用域并不局限于头文件的文件尾

## 3. 原型作用域
- 位置
只适用于在函数原型中声明的参数名。在原型中，参数的名字并非必需的。但是，如果出现参数名，则可以给它们取任何名字，它们不必与函数定义中的形参名匹配，也不必与函数实际调用时所传递的实参匹配。原型作用域防止这些参数名与程序其他部分的名字冲突。事实上，唯一可能出现的冲突就是在同一个原型中不止一次地使用同一个名字

## 4. 函数作用域
- 位置
它只适用于语句标签，它只适用于语句标签，语句标签用于goto语句。基本上，函数作用域可以简化为一条规则——一个函数中的所有语句标签必须唯一。

# 二. 链接属性
当组成一个程序的各个源文件分别被编译之后，所有的目标文件以及那些从一个或多个函数库中引用的函数将链接在一起，形成可执行程序。然而，如果相同的标识符出现在几个不同的源文件中时，它们是表示一个实体，还是表示不同的实体？这就取决于标识符的链接属性。以下是一段示例代码：
```c
typedef char* a;
int b;
int c(int d)
{
    int e;
    int f(int g);
    ...
}
```
- 内部链接（internal）属性：属于internal链接属性的标识符在同一个源文件内的所有声明中都指同一个实体，但位于不同源文件的多个声明则分属不同的实体
- 外部链接（external）属性：属于external链接属性的标识符不论声明多少次，位于几个源文件都表示同一个实体
- 无链接（none）属性：属于none链接属性的标识符总是被当做单独的个体，也就是说该标识符的多个声明被当做不同的独立实体
## 1. 缺省状态下标识符的链接属性
1. 声明在所有代码块之外的变量和函数具有外部链接（external）属性，如：b, c
2. 函数调用时调用的函数具有外部链接（external）属性，如：f
3. 除以上两种情况外，其余标识符均为无链接（none）属性

## 2. static
用于在声明中修改标识符的链接属性
- 在具有外部链接（external）属性的声明前加上static关键字可以使它的链接属性变为内部链接（internal）属性，如：
    ```c
    static int b;
    static int c(int d)
    ...
    ```
- static只对缺省链接属性为external的声明才有改变链接属性的效果，例如，如果对上述示例代码的变量e的声明修改为`static int e;`，其完成的工作并非让e具有了内部链接属性，而是让其变成了静态变量

## 3. extern
- 当extern关键字用于源文件中一个标识符的第1次声明时，它指定该标识符具有external链接属性
- 当它用于该标识符的第2次或以后的声明时，它并不会更改由第1次声明所指定的链接属性
- 如果在一个地方定义变量，并在使用这个变量的其他源文件的声明中添加extern关键字，表示使用其他源文件中定义的具有外部链接属性的同一个实体，关键字非必需，但可以使读者更容易理解意图。

# 三. 存储类型
- 静态变量：存储于静态内存中。在程序运行之前创建，直到程序结束被销毁。对于这类变量，无法为它们指定其他存储类型。
- 自动变量：存储于堆栈中。在程序执行到声明自动变量的代码块时，自动变量才被创建，当程序的执行流离开该代码块时，这些自动变量便自行销毁。
- 寄存器变量：存储于硬件寄存器中。存在时间段与自动变量相同。
## 1. 缺省状态下变量的存储类型
1. 凡是在任何代码块之外声明的变量总是存储于静态内存中，即静态变量。
2. 在代码块内部声明的变量的缺省存储类型是自动变量。

## 2. auto
- 一般只能用于本来在缺省状态下就是自动变量的地方，主要作用是提示读者

## 3. static
- 对于在代码块内部声明的变量，如果给它加上关键字static，可以使它的存储类型从自动变为静态
- 修改变量的存储类型并不表示修改该变量的作用域，它仍然只能在该代码块内部按名字访问
- 函数的形式参数不能声明为静态，因为实参总是在堆栈中传递给函数，用于支持递归。

## 4. register
- 用于自动变量的声明，提示它们应该存储于机器的硬件寄存器而不是内存中
- 编译器不一定会理睬register关键字