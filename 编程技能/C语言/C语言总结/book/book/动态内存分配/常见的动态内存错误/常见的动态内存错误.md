# 一. 未对所请求的内存进行检查
未对所请求的内存是否成功分配可能导致一些问题，如对NULL指针进行解引用操作等。

# 二. 对分配的内存进行操作时越过边界

# 三. 释放并非动态分配的内存
可能导致程序立即终止或在晚些时候终止

# 四. 试图释放一块动态分配的内存的一部分
释放一块内存的一部分是不允许的。动态分配的内存必须整块一起释放。但是，`realloc`函数可以缩小一块动态分配的内存，有效地释放它尾部的部分内存。

# 五. 一块动态内存被释放后被继续使用
假定你对一个指向动态分配的内存的指针进行了复制，而且这个指针的积分副本散布于程序各处。当使用其中一个指针时，你无法保证它所指向的内存是不是已被另一个指针释放。另一方面，必须确保程序中所有使用这块内存的地方在这块内存被释放前停止对它的使用

# 六. 内存泄漏
当动态分配的内存不再需要时，应该被释放，这样它以后可以被重新分配使用。分配内存但在使用完毕后不释放将引起内存泄漏。在那些所有执行程序共享一个通用内存池的操作系统中，内存泄漏将一点点的地榨干可用内存，最终使其一无所有。要摆脱这个困境，只有重启系统。
其他操作系统都能够记住每个程序当前拥有的内存段，这样当一个程序终止时，所有分配给它但未被释放的内存都将归还给内存池。但即使在这类系统中，内存泄漏仍然是一个严重的问题，因为一个持续分配却一点不释放内存的程序最终将耗尽可用的内存。此时，这个有缺陷的程序将无法执行下去，它的失败有可能导致当前已经完成的工作统统丢失。