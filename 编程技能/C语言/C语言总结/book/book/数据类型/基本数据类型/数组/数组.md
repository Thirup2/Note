# 一维数组
## 一. 数组与指针
### 1. 数组名
考虑下面这些声明:
```c
int a;
int b[10];
```
- `a`称为标量, 因为它是个单一的值, 这个变量的类型是一个整数
- `b`称为数组, 因为它是一些值的集合
    - 下标和数组一起使用, 用于表示该集合中某个特定的值, 例如:`b[0]`表示数组`b`的第一个值. 每个特定值都是一个标量
    - 如果只使用数组名`b`, 它的含义是一个指针常量, 也就是数组第1个元素的地址. 它的类型取决于数组元素的类型: 如果它们是`int`类型, 那么数组名的类型就是指向int的常量指针
    - 数组名具有确定数量的元素, 而指针只是一个标量值, 只有当数组名在表达式中使用时, 编译器才会为它产生一个指针常量(**不是指针变量, 无法修改**)
    - 只有在两种场合下, 数组名并不用指针常量来表示:
        1. 当数组名作为sizeof操作符的操作数时, sizeof返回整个数组的长度, 而不是指向数组的指针的长度
        2. 当数组名作为取地址符&的操作数时, 产生的是一个指向数组的指针, 而不是一个指向某个指针常量值的指针

### 2. 下标引用
**除优先级外, 下标引用和间接访问完全相同**
- 需注意两点
    1. 当数组下标为负值时
        ```c
        int array[10]
        int *ap = array+2;
        ```
        - 此时, `ap[-1]`是有意义的, 即`array[1]`
        - 但, `array[-1]`是没有意义的, 因为不知道数组前的地址存储的是什么内容
    2. 当数组下标超过边界时
        - 如`array[10]`或`ap[9]`, 后者看上去没有问题, 但它实际上等价于`ap[11]`, 这两者所表示的内容都是未知的
- 另外, `2[array]`这种形式也是合法的, 与`array[2]`等价, 但其会大大影响程序的可读性

### 3. 指针与下标
**当两种方法都是正确的时候, 下标绝不会比指针更有效率, 但指针有时会比下标更有效率**
如:
```c
int array[10], a;
for(a = 0; a < 10; a += 1)
    array[a] = 0;
```
与
```c
int array[10], *ap;
for(ap = array; ap < array + 10; ap++)
    *ap = 0;
```
- 第一个例子为了对下标表达式求值, 编译器在程序中插入指令, 取得`a`的值, 并把它与整型的长度(也就是4)相乘, 这个乘法需要花费一定的时间和空间
- 第二个例子在每一次循环中也执行一次乘法, 但乘法的内容都是相同的, 每次都是两个相同的数(1和4). 于是, 这个乘法只在编译时执行一次, 后面每一次都直接加4, 而不再进行重复的乘法运算

### 4. 指针的效率
**指针有时比下标更有效率, 前提是它们被正确地使用**
如:
首先有如下声明:
```c
#define SIZE 50
int x[SIZE];
int y[SIZE];
int i;
int *p1, *p2;
```
1. 以下是函数的下标版本
    ```c
    void try1(void)
    {
        for(i = 0; i < SIZE; i++)
            x[i] = y[i];
    }
    ```
    - 每一次循环中都对`i*4`进行求值
2. 以下是函数的指针版本
    ```c
    void try2(void)
    {
        for(p1 = x, p2 = y; p1 - x < SIZE;)
            *p1++ = *p2++;
    }
    ```
    - 复制整数并增加指针值的代码减少了, 但初始化代码却增加了, 用于检查循环结束的代码也增加了许多
3. 以下是函数的指针与计数器混合版本
    ```c
    void try3(void)
    {
        for(i = 0, p1 = x, p2 = y; i < SIZE; i++)
            *p1++ = *p2++;
    }
    ```
    - 用于复制整数和增加指针值以及控制循环结束的代码要短一些, 但在执行间接访问之前, 仍需要把指针变量复制到地址寄存器
4. 以下是将指针变为寄存器变量
    ```c
    void try4(void)
    {
        register int *p1, *p2;
        register int i;
        for(i = 0, p1 = x, p2 = y; i < SIZE; i++)
            *p1++ = *p2++;
    }
    ```
    - 使指针的间接访问操作更快了一些
5. 消除计数器
    ```c
    void try5(void)
    {
        register int *p1, *p2;
        for(p1 = x, p2 = y; p1 < &x[SIZE];)
            *p1++ = *p2++;
    }
    ```
    - 指针的间接访问操作更快, 控制循环结束的代码也更短更快

结论:
1. 当根据某个固定数目的增量在一个数组中移动时, 使用指针变量将比使用下标产生效率更高的代码. 当这个增量是1并且机器具有地址自动增量模型时, 这一点表现得更为突出
2. 声明为寄存器变量的指针通常比位于静态内存和堆栈中的指针效率更高(具体提高的幅度取决于所使用的机器)
3. 如果可以通过测试一些已经初始化并经过调整的内容来判断循环是否应该终止, 就不需要使用一个单独的计数器.
4. 哪些必须在运行时求值的表达式较之如`&array[SIZE]`或`array+[SIZE]`这样的常量表达式往往代价更高

### 5. 数组和指针
**指针和数组并不是相等的**
如:
```c
int a[5];
int *b;
```
- `a`和`b`都具有指针值, 而且都可以进行间接访问和下标引用操作
- 声明一个数组时, 编译器将根据声明所指定的元素数量为数组保留内存空间, 然后再创建数组名, 它的值是一个常量, 指向这段空间的起始位置
- 声明一个指针变量时, 编译器只为指针本身保留内存空间, 它并不为任何整型值分配内存空间. 此外, 指针变量并未被初始化为指向任何现有的内存空间.
- 在上述声明之后, 表达式`*a`是完全合法的, 但表达式`*b`却是非法的, 因为没有进行初始化. 另外, `b++`可以通过编译, 但`a++`却不行, 因为`a`的值是一个常量

## 二. 数组与函数
### 1. 作为函数参数的数组名
数组名本身是一个指针常量, 无法对其进行操作, 但将数组名传递给参数之后, 其实是将这个指针常量赋值给了函数中创建的一个指针变量, 所以在函数中可以对传递进去的指针进行操作

### 2. 声明数组参数
当传递的指针是一个数组名时, 下面两个函数原型是相等的:
```c
int strlen(char *string);
int strlen(char string[]);
```

## 三. 初始化
### 1. 格式
```c
int vector[5] = { 10, 20, 30, 40, 50 };
```
### 2. 静态和自动初始化
- 静态初始化: 只初始化一次, 也就是在程序开始执行之前, 如果数组未被初始化, 数组元素的初始值将会自动设置为零
- 自动初始化: 如果未进行显式初始化, 则数组中的值为垃圾; 如果进行了显式初始化, 则每当执行流进入自动变量声明所在的作用域时, 变量就被一条隐式的赋值语句初始化, 所以需要衡量如果程序的执行流会多次进入某个函数或代码块时, 每次都对数组进行重新初始化是不是值得, 如果答案是否定的, 就把数组声明为static
### 3. 不完整的初始化
```c
int vector[5] = { 1, 2, 3, 4 };
```
- 数组只有前4个元素被显式赋值
- 当对数组中任意个数元素显式赋值后, 其余未显式赋值的元素则初始化为0
### 4. 自动计算数组长度
```c
int vector[] = { 1, 2, 3, 4, 5 };
```
- 当未指定数组元素的个数时, 根据初始化列表中元素的个数创建数组
### 5. 字符数组(字符串)的初始化
```c
char message[] = { 'H', 'e', 'l', 'l', 'o', 0 };
char message[] = "Hello";
```
- 以上两种方法都是合法的, 第二种初始化方法其语义与第一种是相同的, 即它是第一种初始化列表的另一种写法, 而并不是一个字符串常量.
- `char *message2 = "Hello";`中的`"Hello"`则是一个字符串常量
- 二者的区别在于字符串常量产生的是一个地址, 用于赋值给指针, 而初始化列表只是一个个字符

# 多维数组
## 一. 数组与指针
### 1. 数组名
假设数组声明如下:
```c
int matrix[3][10];
```
- matrix是一个二维数组, 首先matrix可以看作一个一维数组, 包含3个元素, 每个元素都是包含10个整型元素的数组.
- `matrix`这个名字的值是一个指向它第1个元素的指针, 所以`matrix`是一个指向一个包含10个整型元素的数组的指针
- 假设`n`是一个从0~2的整数, 则`matrix[n]`是一个指向一个整型元素的指针
> - **K&R C**：“指向数组的指针”这个概念是在相当后期才加入到K&R C中的，有些老式的编译器并没有完全实现它。但是，这个概念对于理解多维数组的下标引用是至关重要的。

### 2. 存储顺序
假设数组声明如下:
```c
int array[3][6];
```
则数组array在内存中的顺序是:
```c
(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (0, 5),
(1, 0), (1, 1), (1, 2), (1, 3), (1, 4), (1, 5),
(2, 0), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5)
```

### 3. 下标
如果要标识一个多维数组的某个元素, 必须按照与数组声明时相同的顺序为每一维都提供一个下标, 而且每个下标都单独位于一对方括号内.
同样, 下标引用实际上只是间接访问表达式的一种伪装形式, 以下两种表达式是等效的:
```c
matrix[i][j];
*(*(matrix+i)+j);
```

### 4. 指向数组的指针
假设有下面两个数组:
```c
int vector[10];
int matrix[3][10];
```
- 声明一个指向一维数组的指针应该是`int *vp = vector;`或者`int *vp = matrix[n];`(假设n是0~2的整数)
- 声明一个指向二维数组的指针应该是`int (*p)[10] = matrix;`, p指向数组matrix的第一个元素, 也就是一个包含10个整型元素的一维数组

## 二. 数组与函数
假设有这样一个数组:
```c
int matrix[3][10];
```
则函数原型应该是下面两种形式中的任何一种:
```c
void function(int (*mat)[10]);
void function(int mat[][10]);
```

## 三. 初始化
### 1. 初始化风格
- 在一条初始化列表里进行初始化
    ```c
    int matrix[2][3] = { 100, 101, 102, 110, 111, 112 };
    ```
    - 按照元素在内存中的排列顺序进行初始化
- 用多条初始化列表进行初始化
    ```c
    int matrix[2][3] = {
        { 100, 101, 102 },
        { 110, 111, 112 }
    };
    ```
    - 每一条初始化列表对应多维数组的第一维
    - 每一条初始化列表对第一维所对应的各个数组进行初始化操作, 按照每一维在内存中的排列顺序进行
### 2. 不完整的初始化列表
- 对于第一种初始化风格, 如果是不完整的初始化列表, 则按照元素顺序进行初始化, 未进行初始化的元素设置为0
- 对于第二种初始化风格, 如果是不完整的初始化列表, 将对应到第一维的每一行, 如果某一行进行了不完整的初始化, 则该行后面的元素设置为0
### 3. 数组长度自动计算
```c
int two_dim[][5] = {
    { 00, 01, 02 },
    { 10, 11 },
    { 20, 21, 22, 23 }
};
```
- 编译器将自动推断创建一个第一维为3的二维数组
- 其他维数也可以省略, 前提是每个列表种的子初始值列表至少有一个要以完整的形式出现

# 指针数组
## 一. 声明
创建一个指针数组形式如下:
```c
int *api[10];
```
- 数组api包含10个元素, 每个元素都是一个指针