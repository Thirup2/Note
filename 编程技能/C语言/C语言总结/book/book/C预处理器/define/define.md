- 语法：
```c
#define name stuff
```
- 有了这条指令以后，每当有符号`name`出现在这条指令后面时，预处理器就会把它替换成`stuff`
> - **K&R C**：早期的C编译器要求`#`出现在每行的起始位置，不过它的后面可以跟一些空白
> - **ANSI C**：在ANSI C中，这条限制被取消了

# 例
```c
#define reg register
#define do_forever for( ; ; )
#define CASE break;case
```
1. 第1个定义只是为关键字`register`创建了一个简短的别名。这个较短的名字使各个声明更容易通过制表符进行排列。
2. 第2条声明用一个更具描述性的符号来代替一种用于实现无限循环的`for`语句类型。
3. 最后一个`#define`定义了一种简短记法，以便在`switch`语句中使用。它自动地把一个`break`放在每个`case`之前，这使得`switch`语句看上去更像其他语言的`case`语句。
4. 如果定义中的`stuff`非常长，它可以分成几行，除了最后一行，每行的末尾都要加一个反斜杠，如下面的例子所示：
    ```c
    #define DEBUG_PRINT printf("File %s line %d:"    \
                               " x=%d, y=%d, z=%d",  \
                               __FILE__, __LINE__,   \
                               x, y, z)
    ```
    这里利用了“相邻的字符串常量被自动连接为一个字符串”这个特性。在调试一个存在许多涉及一组变量的不同计算过程的程序时，这种类型的声明非常有用。我们可以很容易地插入一条调试语句，打印出它们的当前值：
    ```c
    x *= 2;
    y += x;
    z = x * y;
    DEBUG_PRINT;
    ```
    - **警告**：这条语句在`DEBUG_PRINT`后面加了一个分号，所以不应该在宏定义的尾部加上分号。如果这样做了，结果就会产生两条语句。有些场合只允许出现一条语句，如果放入两条语句就会出现问题。