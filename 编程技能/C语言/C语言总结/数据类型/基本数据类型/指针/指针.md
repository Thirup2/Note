# 一. 指针变量
## 1. 指针变量
- 指针变量的内容：其他内容的地址
- 指针变量的地址：该地址存储的值即为指针变量的内容也即其他内容的地址
- 指针变量的大小：不论其存储的地址所在处所存储的内容是什么类型，指针变量本身所占用的大小通常是固定的，一般为机器字长

## 2. 未初始化和非法的指针
```c
int *a;
...
*a = 12;
```
- 其中a是一个指针，由于未进行初始化，所以如果变量是静态的，则a将初始化为0，否则a的值为一个随机值
- 若a的初始值为一个非法地址，即未分配给程序的内存位置，程序将会出错并终止
- 若a的初始值为一个随机合法地址，则后来的赋值语句将原来处于该地址的值修改，被修改的值可能是程序其他的重要组成部分

## 3. 指针的指针

```c
int a = 12;
int *b = &a;
int **c = &b;
```
- `c`是一个指向指针`b`的指针
- `*c`是指针`b`，指向一个值（`a`）
- `**c`是指针`*c`（`b`）指向的内容（`a`）

# 二. 指针常量
## NULL指针
- NULL指针的使用
    - 一个特殊的指针变量，表示不指向任何东西。
    - 要使一个指针变量为NULL，可以给它赋一个零值。
    - 为了测试一个指针变量是否为NULL，可以将它与零值进行比较
    - 就机器内部而言，NULL指针的实际值可能与0不同。在这种情况下，编译器将负责零值和内部值之间的翻译转换
- 用途
    表示某个特定的指针目前并未指向任何东西
- 注意
    因为NULL指针并未指向任何东西，因此，对一个NULL指针进行解引用操作是非法的

# 三. 指针操作
## 1. 间接访问操作符
通过间接访问操作符（*）可以得到指针变量存储的地址所在处的值，类型按照指针变量的类型进行解释
如：
```c
int a = 20;
int *p = &a;
printf("%d",*p);
```
- p是一个指针，其值为变量a的地址
- 对p进行间接访问操作，得到p存储的a的地址的值即0x0014，按照指针p的类型进行解释，最终值为int类型值20
- 指针一般只能关联相同类型的变量

## 2. 指针表达式
```c
char ch = 'a';    // 字符变量ch
char *cp = &ch;    // 指针变量cp，指向ch
```
### `ch`
|表达式|右值|左值|
|:-:|:-:|:-:|
|`ch`|变量`ch`的值`'a'`|存储`ch`变量的内存的地址|
- 当它作为右值使用时，表达式`ch`的值为变量`ch`的值`'a'`
- 当它作为左值使用时，表达式的值为这个内存的地址，而不是该地址所包含的值

### `&ch`
|表达式|右值|左值|
|:-:|:-:|:-:|
|`&ch`|变量`ch`的地址|非法|

### `cp`
|表达式|右值|左值|
|:-:|:-:|:-:|
|`cp`|`cp`的值即其保存的地址|`cp`自身的内存位置|

### `&cp`
|表达式|右值|左值|
|:-:|:-:|:-:|
|`&cp`|指针变量`cp`的地址|非法|

### `*cp`
|表达式|右值|左值|
|:-:|:-:|:-:|
|`*cp`|变量`ch`的值`'a'`|变量`ch`的地址|

### `*cp+1`
|表达式|右值|左值|
|:-:|:-:|:-:|
|`*cp+1`|变量`ch`的值`'a'`加1即`'b'`|非法|
- 指针`cp`以及变量`ch`的值本身并未被改变

### `*(cp+1)`
|表达式|右值|左值|
|:-:|:-:|:-:|
|`*(cp+1)`|变量`ch`的地址的后一个单位的地址的值|变量`ch`的地址的后一个单位的地址|
- 这里的一个单位是指针类型对应的数据类型的长度, 这里是`char`即8位, 1字节

### `++cp`
|表达式|右值|左值|
|:-:|:-:|:-:|
|`++cp`|变量`ch`后一个单位的地址|非法|
- 表达式的副作用将会改变指针`cp`的值, 该表达式将`cp`的值改为变量`ch`后一个单位的地址

### `cp++`
|表达式|右值|左值|
|:-:|:-:|:-:|
|`cp++`|变量`ch`的地址|非法|
- 表达式的副作用将会改变指针`cp`的值, 该表达式将`cp`的值改为变量`ch`后一个单位的地址

### `*++cp`
|表达式|右值|左值|
|:-:|:-:|:-:|
|`*++cp`|变量`ch`后一个单位的地址存储的值|变量`ch`后一个单位的地址|
- `cp`值被改变位变量`ch`后一个单位的地址

### `*cp++`
|表达式|右值|左值|
|:-:|:-:|:-:|
|`*cp++`|变量`ch`的值`'a'`|变量`ch`的地址|
- `cp`值被改变为变量`ch`后一个单位的地址

### `++*cp`
|表达式|右值|左值|
|:-:|:-:|:-:|
|`++*cp`|变量`ch`的值`'a'`加1即`'b'`|非法|
- 变量`ch`的值改变为`'b'`

### `(*cp)++`
|表达式|右值|左值|
|:-:|:-:|:-:|
|`(*cp)++`|变量`ch`的值`'a'`|非法|
- 变量`ch`的值改变为`'b'`

### `++*++cp`
|表达式|右值|左值|
|:-:|:-:|:-:|
|`++*++cp`|变量`ch`后一个单位的地址存储的值加1所的的值|非法|
- 指针`cp`的值更改为变量`ch`后一个单位的地址
- 变量`ch`后一个单位的地址存储的值改变为原值+1

### `++*cp++`
|表达式|右值|左值|
|:-:|:-:|:-:|
|`++*cp++`|变量`ch`的值加1即`'b'`|非法|
- 指针`cp`的值更改为变量`ch`后一个单位的地址
- 变量`ch`的值改变为`'b'`

## 3. 指针运算
1. 算术运算
    ```c
    指针 + 整数;
    指针 - 整数;
    ```
    - 标准规定这种形式只能用于指向数组中某个元素的指针, 也适用于使用malloc函数动态分配获得的内存
    - 对指针执行假发或减法运算之后, 如果结果指针所指的位置在数组第1个元素的前面或在数组最后一个元素的后面, 那么其效果就是未定义的
    - 让指针指向数组最后一个元素后面的那个位置是合法的, 但对这个指针执行间接访问可能会失败
    
    ```c
    指针 - 指针;
    ```
    - 只有当两个指针都指向同一个数组中的元素时, 才允许从一个指针减去另一个指针
    - 两个指针相减的结果的类型时ptrdiff_t, 这是一种有符号整数类型
    - 减法运算的值是两个指针在内存中的距离(以数组元素的长度为单位)
    - 如果两个指针所指向的不是同一个数组中的元素, 那么它们之间相减的结果是未定义的
2. 关系运算
    可以使用下列关系操作符对两个指针值进行比较:
    ```c
    <    <=    >    >=    !=    ==
    ```
    - 前四个操作符要求两个指针都指向同一个数组中的元素
    - 数组中靠后的元素的地址更大
    - 后两个操作符可以在两个任意的指针间执行相等或不相等测试

# 四. 指向指针的指针
假设有以下声明：
```c
int i;
int *pi;
int **ppi;
```
然后有如下语句：
```c
// 1
printf("%d\n", ppi);
//2
printf("%d\n", &ppi);
//3
*ppi = 5;
```
它们的效果分别是：
1. 如果`ppi`是个自动变量，它就未被初始化，这条语句将打印一个随机值。如果他是个静态变量，这条语句将打印0
2. 这条语句将把存储`ppi`的地址作为十进制打印出来。这个值并不是很有用。
3. 这条语句的结果是不可预测的。对`ppi`不应该执行间接访问操作，因为它尚未被初始化。

接下来的两条语句用处较大：
```c
// 1
ppi = &pi;
```
这条语句把`ppi`初始化为指向变量`pi`。以后就可以安全地对`ppi`执行间接访问操作了
```c
// 2
*ppi = &i;
```
这条语句把`pi`（通过`ppi`间接访问）初始化为指向变量`i`。

如果想声明一个变量指向一个指向指针的指针，那么它应该像下面这样声明：
```c
int ***pppi;
```

# 五. 高级声明
所有声明都可以通过表达式的求值顺序来进行推论：
## 1. 简单声明
```c
int f;
int *f;
int f();
int *f();
int f[20];
```
- 声明`f`是一个整型
- `*f`进行结合，声明`*f`是一个整型，所以`f`是一个指向整型的指针
- `f()`进行结合，声明`f`是一个函数，返回一个整型值
- 按照运算符优先级`f()`先结合，声明`f`是一个函数，返回一个指向`int`类型的指针
- `f[20]`进行结合，表示下标引用之后的表达式是一个整型值，所以去掉下标引用就是一个数组名

## 2. 高级声明
### 1). 函数指针
```c
int (*f)();
```
- `*f`先进行结合，所以`f`是一个指针
- 然后`(*f)()`再进行结合，表明`*f`是一个函数，返回一个整型值
- 所以`f`是一个指向函数的指针，它指向的函数返回一个整型值

### 2). 指针数组
```c
int *f[20];
```
- `f[20]`先进行结合，所以首先`f`是个数组
- 然后是`*f[20]`结合，表明数组的某个元素进行解引用之后是个整型值，所以数组的某个元素是一个指向整型值的指针
- 所以`f`是一个包含二十个指向整型值的指针的数组

### 3). 函数指针数组
```c
int (*f[20])();
```
- `f[20]`先结合，所以`f`是个数组
- `*f[20]`结合，所以`f`是个指针数组
- `*f[20]()`结合，所以`f`是个数组，数组元素是20个指针，每个指针指向一个返回值为整型值的函数
```c
int *(*f[20])();
```
- 和上面一样，`f`是一个函数指针数组，但数组的每一个元素所指的函数的返回值是指向整型值的指针

## 3. 典型错误声明
### 1). 返回数组的函数
```c
int f()[];
```
- `f()`结合表明`f`是一个函数
- `f()[]`表明`f`的返回值是一个数组
- 函数只能返回标量值，不能返回数组

### 2). 函数数组
```c
int f[]();
```
- `f[]`结合表明`f`是一个数组
- `f[]()`结合表明每一个数组元素都是一个函数，返回值为整型值
- 数组元素必须具有相同的长度，但不同的函数显然可能具有不同的长度

# 六. 函数指针
## 1. 常见用途
- 转换表
- 作为参数传递给另一个函数

## 2. 使用方法
### 1). 创建
初始化一个函数指针之前需要有与之类型相对应的函数原型或定义，否则编译器将无法检查函数指针与被指函数的类型是否一致
### 2). 初始化
由于函数指针是一个指针，具有与其他任何普通指针相同的特性，在对函数指针执行间接访问之前必须把它初始化为指向某个函数
### 3). 取址操作符
对函数的取址操作符(`&`)是可选的，因为函数名被使用时总是由编译器把它转换为函数指针。`&`操作符只是显式地说明了编译器将隐式执行的任务。
### 4). 例
```c
int f(int);
int (*pf)(int) = &f;
```

# 七. 命令行参数
C程序的main函数具有两个形参。第1个通常称为`argc`，它表示命令行参数的数目。第2个通常称为`argv`，它指向一组参数值。由于参数的数目并没有内在的限制，所以`argv`指向这组参数值的第1个元素，这些元素的每一个都是指向一个参数文本的指针。如果程序需要访问命令行参数，main函数在声明时就要加上这些参数：
```c
int main( int argc, char **argv )
```
- `argc`：从程序名开始的字符串的个数
- `argv[]`或`*argv`：某个字符串，`argv[0]`是程序名。最后一个字符串之后的内容为NULL

# 八. 字符串常量
字符串常量出现于表达式中时，它的值是个指针常量，
数组名用于表达式中时，它们的值也是指针常量，
而我们可以对数组名进行下标引用、间接访问以及指针运算，
那么这些操作对字符串常量是否有意义呢？
- `"xyz"+1`：该表达式的结果是个指针，指向字符串中的第2个字符：y
- `*"xyz"`：该表达式的结果是字符：x
- `"xyz"[2]`：该表达式的结果是字符：z
- `*("xyz"+4)`：该表达式的结果是一个不可预测的字符
- `"xyz""abc"`：该表达式的结果是一个指向字符串`"xyzabc"`的指针，相邻的字符串常量被自动连接为一个字符串，前面一个字符串后面的NUL字节被覆盖

**注意**：对字符串常量进行访问是允许的，但是对其中的字符进行修改是由编译器决定的，如果要修改字符串中的内容，请使用数组。