# 一. 引例

想象一个场景，如果把学生考试的分数转换成对应的等级，加入满分为100分，等级按照十分一个档次，90分以上为A，80分以上为B，70分以上为C，60分以上为D，60分以下为E。

假设现在有一个分数a，这个场景可以转换为一个二叉树：

- 根结点判断：`a<60`
- 若成立，则进入其左孩子，即E等级；若不成立，则进入其右孩子，即判断`a<70`
- 若成立，进入其左孩子，即D等级；若不成立，则进入其右孩子，即判断`a<80`
- 以此类推，直到获得叶子结点上的等级然后退出

其形式如下:

![graphviz](https://user-images.githubusercontent.com/91216205/194515826-694233bc-2ca2-4a7a-9b37-bbf64103ccfa.svg)

在实际的学习过程中，学生的成绩一般如下分布：

| 分数   | 占比 |
| ------ | ---- |
| 0~59   | 5%   |
| 60~69  | 15%  |
| 70~79  | 40%  |
| 80~89  | 30%  |
| 90~100 | 10%  |

在上述的图结构中，要判断70分以上的等级都需要经过3次以上的判断才可以得到结果，这显然不合理。

先说结论，可以按照以下结构构造这个树结构：

![graphviz ](https://user-images.githubusercontent.com/91216205/194518342-81697947-400e-4b1d-97c3-a89c1889f372.svg)



# 二. 定义

首先将二叉树简化成叶子结点带权的二叉树，如下图所示：

![graphviz](https://user-images.githubusercontent.com/91216205/194520154-bf599ac9-c12d-4ec3-8d29-9186a709fd25.svg)

## 1. 关键概念

- 路径：从树中一个结点到另一个结点之间的分支构成两个结点之间的路径
- 路径长度：路径上的分支数目即为路径长度
- 树的路径长度：从树根到每一结点的路径长度之和
- 带权路径长度：从该结点到根结点之间的路径长度与结点上权的乘积。
- 树的带权路径长度：树中所有叶子结点的带权路径长度之和



## 2. 定义

假设有$$n$$个权值{ $$w_1$$， $$w_2$$， ···， $$w_n$$ }，构造一棵有$$n$$个叶子结点的二叉树，每个叶子结点带权$$w_k$$，每个叶子结点的路径长度为$$l_k$$，则其中带权路径长度WPL最小的二叉树称为**哈夫曼树**。



# 三. 原理

1. 首先把有权值的叶子结点按照从小到大的顺序排列成一个有序序列，即$$A5$$，$$E10$$，$$B15$$，$$D30$$，$$C40$$

2. 取两个最小权值的结点作为一个新结点$$N_1$$的两个子结点，较小的是左孩子，如下图：

   ![graphviz](https://user-images.githubusercontent.com/91216205/194522602-193397e0-fbd7-497d-8a9f-5a5c509214ba.svg)

3. 然后将$$N_1$$看成一个整体，其权值为两个子结点权值之和，此时序列为：$$N_115$$，$$B15$$，$$D30$$，$$C40$$

4. 再从中取两个最小权值的结点作为一个新结点$$N_2$$的两个子结点，如下图：

   ![graphviz (1)](https://user-images.githubusercontent.com/91216205/194523653-d55faaf9-c918-43aa-990a-ac00360edb53.svg)

5. 重复操作，最终可以得到下面这个树结构：

   ![graphviz (2)](https://user-images.githubusercontent.com/91216205/194525194-529777d2-3cdc-460a-8d9e-cbf570de984e.svg)

### 规则

1. 根据给定的$$n$$个权值{ $$w_1$$， $$w_2$$， ···， $$w_n$$ }构成$$n$$棵二叉树的集合$$F=$$ { $$T_1$$， $$T_2$$， ···， $$T_n$$ }，其中每棵二叉树$$T_i$$中只有一个带权为$$w_i$$的根结点，其左右子树均为空。
2. 在$$F$$中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。
3. 在$$F$$中删除这两棵树，同时将新得到的二叉树加入$$F$$中。
4. 重复步骤2和3，直到$$F$$只含一棵树为止。这就是哈夫曼树



# 四. 应用：哈夫曼编码

## 1. 引入

如果要将一串文字"BADCADFEED"通过网络传输给别人，假设英文字符总共只有以下六个，并且有以下频率关系：

| A    | B    | C    | D    | E    | F    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 27   | 8    | 15   | 15   | 30   | 5    |

如果按照完整数据传输的方式，即按照对应的二进制字符进行传输，假设对应的二进制编码为：

| A    | B    | C    | D    | E    | F    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 000  | 001  | 010  | 011  | 100  | 101  |

那么需要传输的数据为：

```
001 000 011 010 000 011 101 100 100 011
```

一共30个字符



## 2. 哈夫曼编码

将这六个字符按照权重先构造出相应的哈夫曼树：

![graphviz (3)](https://user-images.githubusercontent.com/91216205/194528999-6cac3b45-b3d4-453e-921a-4c2edbee4c8a.svg)

然后将每个结点到其左子树的分支设置为0，结点到其右子树的分支设置为1，如下图所示：

![graphviz (4)](https://user-images.githubusercontent.com/91216205/194529367-93a9cba7-725f-48ee-87c9-69674fb04fa4.svg)

从该树中，可以得到新的字符编码：

| A    | B    | C    | D    | E    | F    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 01   | 1001 | 101  | 00   | 11   | 1000 |

此时需要传输的数据为：

```
1001 01 00 101 01 00 1000 11 11 00
```

一共25个字符。



## 3. 总结

哈夫曼编码即将原有的字符按照出现频率对其进行重排，此时出现越频繁的字符，其编码就越短，成功达到了压缩的目的。



## 4. 注意

1. 若要设计长短不等的编码，则必须是任一自负的编码都不是另一个字符的编码的前缀，这种编码称为前缀编码。
2. 对于哈夫曼编码，发送方和接收方必须使用同样的哈夫曼编码规则进行编解码才行
