# 一. 分析

如果我们有一个根节点的指针，那么我们只要知道每一个结点的所有子树的根节点就可以遍历整个树。

我们可以暂时使用链表来存储，每个结点包括数据域和多个指针域用于指向所有的子树的根结点。该方法的问题是，指针域的个数如何确定？有两种方法，一是将所有结点的指针域的个数设置为树的度，即所有结点的度的最大值。该方法在树中各结点度相差不大时很好用，但是在各结点度相差很大时，就会明显地浪费空间；第二种方法就是在每一个结点设置一个度域，用以保存该结点的度，然后将结点的子域个数设置为度的值，该方法可以有效的减少空间浪费，但是由于每个结点都是不相同的结构，并且还要维护结点的度的数值，在运算上会带来时间上的损耗。

因此，我们可以将每个结点的孩子结点排列起来，以单链表作存储结构。然后将n个头指针组成一个线性表，采用顺序存储结构，放进一个一维数组中。

当然，如果只有每个结点的孩子结点，那么当查询双亲结点时就比较复杂，所以可以在每个头结点中添加一个双亲指针，特殊的，将根节点的双亲指针设置为-1。



# 二. 代码实现

```c
#define MAXSIZE 100
struct items
{
    int x;
    int y;
};									// 数据项
typedef struct items ElemType;		// 数据元素类型

struct node
{
    int child;						// 保存孩子的位置
    struct node *next;				// 下一个孩子链表的孩子结点
};									// 结点定义
typedef struct node Node;			// 结点类型
typedef Node *PNode;				// 结点指针

struct box
{
    ElemType data;					// 数据域
    int parent;						// 双亲指针
    PNode firstchild;				// 孩子指针
};
typedef struct box Box;				// 数组元素类型

struct tree
{
    Box nodes[MAXSIZE];				// 数据
    int root;						// 根结点的位置
    int length;						// 结点的个数
}
```

