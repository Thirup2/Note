# 一. 分类

- 顺序栈
- 两栈共享空间
- 链栈



# 二. 定义

栈 ( stack ) 是限定仅在表尾进行插入和删除操作的线性表



# 三. 关键概念

- 栈顶：允许插入和删除的一端称为栈顶（top）
- 栈底：与栈顶相对的另一端称为栈底（bottom）
- 空栈：不含任何数据元素的栈称为空栈
- LIFO结构：即后进先出的结构（Last In First Out）
- 进栈、压栈、入栈：即栈的插入操作
- 出栈、弹栈：即栈的删除操作



# 四. 栈的抽象数据类型

- ADT 栈(stack)
- Data
  - 同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系
- Operation
  - `InitStack(*S)`：初始化操作，建立一个空栈
  - `DestroyStack(*S)`：若栈存在，则销毁它
  - `ClearStack(*S)`：将栈清空
  - `StackEmpty(S)`：若栈为空，返回true，否则返回false
  - `GetTop(S, *e)`：若栈存在且非空，用e返回S的栈顶元素
  - `Push(*S, e)`：若栈S存在，插入新元素e到栈S中并成为栈顶元素
  - `Pop(*S, *e)`：删除栈S中栈顶元素，并用e返回其值
  - `StackLength(S)`：返回栈S的元素个数
- endADT



# 五. 栈的应用

栈的引入简化了程序设计的问题，划分了不同关注层次，使得思考范围缩小，更加聚焦于我们要解决的问题核心。

## 1. 递归

### 1） 定义

一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称作递归函数。



### 2） 条件

每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出。



### 3） 斐波那契数列

**引例**：如果兔子在出生两个月后，就有繁殖能力，一对兔子每个月能生出一对小兔子来。假设所有兔子都不死，那么一年以后可以繁殖多少对兔子呢？

**分析**：经过的月数和兔子的总数可以列出下表：

| 经过的月数 | 兔子对数 |
| :--------: | :------: |
|     1      |    1     |
|     2      |    1     |
|     3      |    2     |
|     4      |    3     |
|     5      |    5     |
|     6      |    8     |
|     7      |    13    |
|     8      |    21    |
|     9      |    34    |
|     10     |    55    |
|     11     |    89    |
|     12     |   144    |

**建模**：根据上表我们可以写出以下数学模型
$
F(n)=\begin{cases}
0 & n=0	\\
1 & n=1	\\
F(n-1)+F(n-2) & n>1
\end{cases}
$
**代码**：

- 常规迭代方法

```c
int main()
{
    int i;
    int a[40];
    a[0] = 0;
    a[1] = 1;
    printf("%d ", a[0]);
    printf("%d ", a[1]);
    for(i = 2; i < 40; i++)
    {
        a[i] = a[i-1] + a[i-2];
        printf("%d ", a[i]);
    }
    return 0;
}
```



- 递归方法

```c
int Fbi(int i)
{
    if(i < 2)
        return i == 0 ? 0 : 1;
    return Fbi(i-1)+Fbi(i-2);
}

int main()
{
    int i;
    for(i = 0; i<40; i++)
        printf("%d ", Fbi(i));
    return n;
}
```



## 2. 四则运算表达式求值——后缀表示法

### 1） 定义

后缀表示法是一种不需要括号的运算表达式的书写方法，也叫作逆波兰表示。表达式中所有的符号都是在要运算数字的后面出现。



### 2） 转换为后缀表达式

**规则**：

- 从左到右遍历中缀表达式的每个数字和符号
- 若是数字就输出到后缀表达式中
- 若是符号，则判断其与栈顶符号的优先级
  - 若是左括号，则进栈
  - 若是右括号，将栈顶元素依次出栈，直到遇到左括号（左括号需要出栈，两个括号不用写到后缀表达式中）
  - 若是优先级不高于栈顶符号的符号，则将栈顶符号出栈并输出，然后与下一个栈顶符号比较
  - 若是优先级高于栈顶符号，将该符号入栈
- 当中缀表达式遍历完后，将栈顶元素依次出栈并输出

**例**：将表达式$9+(3-1)\times 3+10\div 2$转换为后缀表达式

1. 数字$9$，输出。
   - **表达式**：$9$
   - **栈(从栈底开始)**：空
2. 符号$+$，入栈。
   - **表达式**：$9$
   - **栈**：$+$
3. 符号$($，入栈。
   - **表达式**：$9$
   - **栈**：$+$、$($
4. 数字$3$，输出。
   - **表达式**：$9$、$3$
   - **栈**：$+$、$($
5. 符号$-$，入栈。
   - **表达式**：$9$、$3$
   - **栈**：$+$、$($、$-$
6. 数字$1$，输出。
   - **表达式**：$9$、$3$、$1$
   - **栈**：$+$、$($、$-$
7. 符号$)$，栈顶元素依次出栈并输出，直到遇到$($
   - **表达式**：$9$、$3$、$1$、$-$
   - **栈**：$+$
8. 符号$\times$，入栈
   - **表达式**：$9$、$3$、$1$、$-$
   - **栈**：$+$、$\times$
9. 数字$3$，输出
   - **表达式**：$9$、$3$、$1$、$-$、$3$
   - **栈**：$+$、$\times$
10. 符号$+$，优先级低于$\times$，输出$\times$；优先级不高于$+$，输出$+$；入栈
    - **表达式**：$9$、$3$、$1$、$-$、$3$、$\times$、$+$
    - **栈**：$+$
11. 数字$10$，输出。
    - **表达式**：$9$、$3$、$1$、$-$、$3$、$\times$、$+$、$10$
    - **栈**：$+$
12. 符号$\div$，入栈。
    - **表达式**：$9$、$3$、$1$、$-$、$3$、$\times$、$+$、$10$
    - **栈**：$+$、$\div$
13. 数字2，输出。
    - **表达式**：$9$、$3$、$1$、$-$、$3$、$\times$、$+$、$10$、$2$
    - **栈**：$+$、$\div$
14. 遍历完成，输出栈顶元素
    - **表达式**：$9$、$3$、$1$、$-$、$3$、$\times$、$+$、$10$、$2$、$\div$、$+$
    - **栈**：空
15. 后缀表达式为：$9$ $3$ $1$ $-$ $3$ $\times$ $+$ $10$ $2$ $\div$ $+$



### 3） 后缀表达式的计算

**规则**：

- 从左到右遍历后缀表达式的每个数字和符号
- 若是数字，则进栈
- 若是符号，则将栈顶两个数字出栈进行运算，然后将运算结果进栈
  - 先出栈的数字作为运算符的右侧运算对象
  - 后出栈的数字作为运算符的左侧运算对象
- 表达式遍历完成后，将最后的结果数字出栈

**例**：计算后缀表达式：$9$ $3$ $1$ $-$ $3$ $\times$ $+$ $10$ $2$ $\div$ $+$

1. 数字$9$、$3$、$1$先入栈。**栈(从栈底开始)**：$9$、$3$、$1$
2. 符号$-$，取出$1$、$3$进行运算，结果$2$入栈。**栈**：$9$、$2$
3. 数字$3$，入栈。**栈**：$9$、$2$、$3$
4. 符号$\times$，取出$3$、$2$进行运算，结果6入栈。**栈**：$9$、$6$
5. 符号$+$，取出$6$、$9$进行运算，结果$15$入栈。**栈**：$15$
6. 数字$10$、$2$入栈。**栈**：$15$、$10$、$2$
7. 符号$\div$，取出$2$、$10$进行运算，结果$5$入栈。**栈**：$15$、$5$
8. 符号$+$，取出$5$、$15$进行运算，结果$20$入栈。**栈**：$20$
9. 遍历完成，取出结果$20$。**栈**：空
