# 一. 简介

在通过哈希函数求关键字的哈希值的时候，经常会遇到两个关键字$key_1\neq key_2$，但是却有$f(key_1)=f(key_2)$，这种现象我们称为**冲突**（collision），并把$key_1$和$key_2$称为这个散列函数的同义词（synonym）。

解决散列冲突有以下几种方法。



# 二. 处理散列冲突的方法

## 1. 开放定址法

即一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。

它的公式是：
$
f_i(key)=(f(key)+d_i)\ \% \ m
$
其中$d_i=1$，$2$，$3$，...，$m-1$

这种解决冲突的开放定址法称为**线性探测法**，其问题是有些本来都不是同义词却需要争夺一个地址的情况，这种现象称为**堆积**，由于堆积现象的出现，使得我们需要不断处理冲突，无论是存入还是查找效率都会大大降低。

改善这种堆积现象有一些方法：

1. 将每次的位移量变成平方：$f_i(key)=(f(key)+d_i)\ \% \ m$，其中$d_i=1^2$，$-1^2$，$2^2$，$-2^2$，...，$q^2$，$-q^2$$(q\leqslant m/2)$，这种方法称为**二次探测法**，这种方法的目的是为了不让关键字都聚集在某一块区域。
2. 用随机函数得到每次的位移量：$f_i(key)=(f(key)+random(i))\ \% \ m$，这种方法称之为**随机探测法**。



## 2. 再散列函数法

对于我们的散列表来说，我们可以事先准备多个散列函数，按照顺序使用，若第一个散列函数发生了冲突，则对该关键字使用第二个散列函数，当不再冲突时，就将数据存储即可。

这种方法能够使得关键字不产生聚集，但是也相应地增加了计算的时间。



## 3. 链地址法

即在原来的哈希表结点中添加一个指向哈希值等于该地址的链表头指针，不管是否发生冲突，总之哈希值为多少，就将对应的关键字放到对应地址后的链表中。

此方法的好处是，对于可能会造成很多冲突的散列函数来说，提供了绝不会出现找不到地址的保障，但是也带来了查找时需要遍历单链表的性能损耗。



## 4. 公共溢出区法

即在哈希表之外，再建立一个溢出表，当关键字产生冲突时，就将关键字保存到溢出表，查找时，先通过散列函数计算出散列值在散列表中进行查找，如果没找到，再到溢出表中进行顺序查找。

在有冲突的数据很少的情况下，公共溢出区的结构对查找性能来说还是非常高的。
