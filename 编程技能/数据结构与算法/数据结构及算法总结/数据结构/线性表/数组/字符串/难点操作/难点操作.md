-   模式匹配算法

# 一. 朴素的模式匹配算法

## 1. 伪码描述

-   首先创建两个变量，一个变量指向指定的主串开始查找的位置，另一个变量指向子串的起始位置
-   用循环逐个对比两个位置上的字符是否相等，若相等则将两个变量加1，若不相等则将第二个变量退回到第一个字符的位置，第二个变量退回到之前的开始位置的后一个位置，然后继续开始查找
-   当某个字符串遍历完成之后，退出循环
-   若第二个字符串遍历完成，返回此次循环主串开始的位置
-   若第一个字符串遍历完成，说明无匹配子串，返回0

## 2. C代码

假设主串`S`和要匹配的子串`T`的长度存在`S[0]`与`T[0]`中：

```c
int Index(String S, String T, int pos)
{
    int i = pos;
    int j = 1;
    while (i <= S[0] && j <= T[0])
    {
        if (S[i] == T[j])
        {
            ++i;
            ++j;
        } else {
            i = i - j + 2;
            j = 1;
        }
    }
    if (j > T[0])
    {
        return i - T[0];
    } else {
        return 0;
    }
}
```



# 二. KMP模式匹配算法

## 1. 分析

在朴素的模式匹配算法中，每一次开始匹配，都会将`i`退回到上一次循环的后一个位置，`j`被退回到第一个字符的位置。

但实际情况是，在朴素的模式匹配算法中，包含了许多无用的操作。如`abcdefgab`和`abcdex`这个例子，前面五个字符都匹配，直到第六个字符时不匹配。按照朴素的模式匹配算法，主串将从`b`开始，子串将从`a`开始，而主串中第一个字符`a`和后面的字符都不相同，而刚刚前五个字符都已经和主串比较过是相同的，也就是说，子串的第一个字符肯定和主串的第2-5个字符是不同的，所以在朴素的模式匹配算法中会存在很多的多余操作。在此可以得到一个结论，就是每一次循环`j`可以不一定从1开始，主串指针`i`也不一定需要回退。

在初步的推导中，主串指针`i`是不需要回退的，所以我们直接考虑每一次模式匹配，`j`需要怎么进行回溯。



## 2. 数学模型

`j`的值可以通过下面这个数学模型进行推导：
$$
next[j]=\begin{cases}
0 & j=1\\
Max\{ k|(1<k<j) \&\& (P_1...P_{k-1}=P_{j-k+1}...P_{j-1})\} & \{ k\}\neq \varnothing
\\ 1 & Others
\end{cases}
$$

>   其中，`next[j]`是一个数组，下标代表子串的字符位序，其中保存的元素表示当此次匹配在某个位序处失败后，下一次匹配从数组中此位序元素值所显示的位序开始匹配。
>
>   $$P_1...P_{k-1}$$和$$P_{j-k+1}...P_{j-1}$$是两个字符串，$$P_1...P_j$$是这个需要匹配的子串
>
>   $$\{ k\}\neq \varnothing$$表示前面的`K`集合不是空集。



## 3. C代码

-   根据子串内容写入`next`数组

    ```c
    void get_next(String T, int *next)
    {
        int i, k;
        i = 1;
        k = 0;
        next[1] = 0;
        while (i < T[0])
        {
            if (k == 0 || T[i] == T[k])
            {
                ++i;
                ++k;
                next[i] = k;
            } else {
                k = next[k];
            }
        }
    }
    ```

-   匹配部分

    ```c
    int Index_KMP(String S, String T, int pos)
    {
        int i = pos;
        int j = 1;
        int next[255];
        get_next(T, next);
        while (i <= S[0] && j <= T[0]) {
            if (j == 0 || S[i] == T[j]) {
                ++i;
                ++j;
            } else {
                j = next[j];
            }
        }
        if (j > T[0])
            return i - T[0];
        else
            return 0;
    }
    ```




# 三. KMP模式匹配算法的改进

## 1. 分析

上述的KMP算法仍然存在一定缺陷。比如有以下两个字符串：`aaaabcde`和`aaaaax`，在子串和主串的指针都移动到5时，二者产生差异，此时按照上述的KMP模式匹配算法，`i`依旧指向5，`j`移动到4，然后开始匹配，结果依旧不匹配，`j`又移动到3。然而由于子串中前5个字符都是`a`，所以第五个字符与主串的第五个字符不匹配，那么说明子串的前面四个字符也都和主串的第五个字符不匹配，所以按照之前的KMP算法，依然会有一些多余操作存在。



## 2. C代码

以下是改进之后的写入`next`数组的函数：

```c
void get_nextval(String T, int *nextval)
{
    int i, k;
    i = 1;
    k = 0;
    nextval[1] = 0;
    while (i < T[0]) {
        if (k == 0 || T[i] == T[k]) {
            ++i;
            ++k;
            if(T[i] != T[k])
                nextval[i] = k;
            else
                nextval[i] = nextval[k];
        } else
            k = nextval[k];
    }
}
```

