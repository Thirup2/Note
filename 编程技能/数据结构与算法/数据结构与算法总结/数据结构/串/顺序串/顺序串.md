# 一. 简介

**顺序串**通常是最常用的字符串实现方法，即使用数组实现，为了实现字符串的大小灵活的特点，可以使用变长数组。之所以说顺序串是最常用的字符串实现方法，是因为链式串往往只在连接字符串和字符串中插入字符串时复杂度优于顺序串，而其他操作顺序串都是优于链式串的。总的来看，顺序串的优越性是高于链式串的。



# 二. 代码实现

## 1. 概念实现

- **串的长度**：首先我们为了简化，每个串的第一个元素空出来不保存字符，而保存该字符串的长度，同时在字符串的末尾必须保留一个空字符，所以实际上的每个串的数组比串的长度大 2
- **空串**：数组应该有两个元素，下标为 0 的元素同样保存字符串长度，第二个元素保存空字符



## 2. 代码

- 数据元素类型

  ```c
  typedef char CHAR;
  typedef char *PCHAR;
  typedef const char *CPCHAR;
  ```

- 字符串类型

  ```c
  typedef PCHAR STRING;
  typedef CPCHAR CSTRING;
  
  typedef signed char size_char;
  #define MAXSIZE 127
  ```



# 三. 难点操作

- 字符串比较

  ```c
  size_char StrCompare(CSTRING str1, CSTRING str2)
  {
      size_char len = (StrLength(str1) < StrLength(str2)) ? StrLength(str1) : StrLength(str2);
      size_char i = 1;
      while (i <= len) {
          if (toupper(str1[i]) > toupper(str2[i])) {
              return i;
          } else if (toupper(str2[i]) > toupper(str1[i])) {
              return -i;
          } else {
              if (str1[i] > str2[i]) {
                  return i;
              } else if (str1[i] < str2[i]) {
                  return -i;
              } else {
                  i++;
              }
          }
      }
      if (StrLength(str1) == StrLength(str2)) {
          return 0;
      }
  }
  ```

- 字符串连接

  ```c
  STRING Concat(CSTRING str1, CSTRING str2)
  {
      size_t len = StrLength(str1) + StrLength(str2);
      if (len > MAXSIZE) {
          return NULL;
      }
      STRING string = (STRING) malloc((len + 2) * sizeof(CHAR));
      if (!string) {
          exit(EXIT_FAILURE);
      }
      string[0] = (size_char) len;
      size_char i = 1;
      size_char j = 1;
      while (j <= StrLength(str1)) {
          string[i++] = str1[j++];
      }
      j = 1;
      while (j <= StrLength(str2)) {
          string[i++] = str2[j++];
      }
      string[j] = '\0';
      return string;
  }
  ```

- 替换子串

  ```c
  Status Replace(STRING string, CSTRING substring, CSTRING restring)
  {
      if (StringEmpty(substring)) {
          return ISEMPTY;
      }
      size_char len = StrLength(substring);
      size_char now = Index(string, substring, 1);
      while (now > 0) {
          StrDelete(string, now, len);
          StrInsert(string, now, restring);
          now += StrLength(restring);
          now = Index(string, substring, now);
      }
      return SUCCESS;
  }
  ```

- 插入字符串

  ```c
  Status StrInsert(STRING string, size_char pos, CSTRING substring)
  {
      if (pos < 1 || pos > StrLength(string) + 1) {
          return WRONGPOS;
      }
      size_t str_len = StrLength(string);
      size_t sub_len = StrLength(substring);
      size_t len = StrLength(string) + StrLength(substring);
      if (len > MAXSIZE) {
          return ISFULL;
      }
      string = (STRING) realloc(string, (len + 2) * sizeof(CHAR));
      if (!string) {
          exit(EXIT_FAILURE);
      }
      for (size_char i = len + 1, j = i - sub_len; j >= pos; i--, j--) {
          string[i] = string[j];
      }
      for (size_char i = pos, j = 1; j <= sub_len; i++, j++) {
          string[i] = substring[j];
      }
      return SUCCESS;
  }
  ```

- 删除字符串

  ```c
  Status StrDelete(STRING string, size_char pos, size_char len)
  {
      size_char str_len = StrLength(string);
      size_char i = 0;
      while (pos + len + i <= str_len + 1) {
          string[pos + i] = string[pos + len + i];
      }
      string = (STRING) realloc(string, (str_len - len + 2) * sizeof(CHAR));
      if (!string) {
          exit(EXIT_FAILURE);
      }
      string[0] = str_len - len;
      return SUCCESS;
  }
  ```

- 字符串匹配：见算法部分