# 一. 简介

**链队列**是队列的链式实现方法，其主要特点如下：

- 大小灵活，但需要为每个结点提供指针域
- 链表的缺点在队列这种数据结构中得到了隐藏

> 与栈相同，如果队列的长度容易确定且变化不大，那么使用循环队列会比较好，而如果队列的长度很难确定或变化较大，那么使用链队列会比较好



# 二. 代码实现

## 1. 概念实现

对于链队列来说，不用烦恼应该哪一端作队头，哪一端作队尾，因为两个都应该有指向的指针。



## 2. 代码

- 数据元素类型

  ```c
  typedef struct items ElemType;		// 基础数据元素类型，struct items自行定义
  typedef ElemType *PtrElem;		// 一般数据元素指针
  typedef const ElemType *cPtrElem;		// 指向常量的数据元素指针
  ```

- 结点类型

  ```c
  struct node
  {
      ElemType data;
      // 双向链表或许会比较合适
      struct node *next;
      struct node *pre;
  };
  typedef struct node Node;
  typedef Node *PtrNode;
  typedef const Node *cPtrNode;
  ```

- 链队列类型

  ```c
  struct queue
  {
      PtrNode head;
      PtrNode last;
  };
  typedef struct queue Queue;
  typedef Queue *PtrQueue;
  typedef const Queue *cPtrQueue;
  ```



# 三. 难点操作

- 入队列

  ```c
  Status EnQueue(PtrQueue queue, cPtrElem elem)
  {
      PtrNode p = (PtrNode) malloc(sizeof(Node));
      if (!p) {
          exit(EXIT_FAILURE);
      }
      AssignElem(&p->data, elem);
      if (QueueEmpty(queue)) {
          p->next = NULL;
          p->pre = NULL;
          queue->head = p;
          queue->last = p;
      } else {
          p->next = queue->last->next;
          p->pre = queue->last;
          queue->last->next = p;
          queue->last = p;
      }
      return SUCCESS;
  }
  ```

- 出队列

  ```c
  Status DeQueue(PtrQueue queue, PtrElem elem)
  {
      if (QueueEmpty(queue)) {
          return ISEMPTY;
      }
      if (QueueLength(queue) == 1) {
          AssignElem(elem, &queue->head->data);
          free(queue->head);
          queue->head = NULL;
          queue->last = NULL;
      } else {
          PtrNode p = queue->head;
          p->next->pre = p->pre;
          queue->head = p->next;
          AssignElem(elem, &p->data);
          free(p);
      }
      return SUCCESS;
  }
  ```

