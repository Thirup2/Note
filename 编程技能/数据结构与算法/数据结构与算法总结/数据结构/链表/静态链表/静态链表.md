# 一. 简介

**静态链表**也是链表的一种类型，但又与普通的链表有很大的区别，因为它是用数组实现的，其主要特点如下：

- 通过数组来模拟链表的实现，将未使用的数组空间作为内存池进行分配
- 失去了数组本身的灵活访问的特性，主要是在无法使用指针的机器或语言中模拟链表的结构



# 二. 代码实现

## 1. 实现方法

1. 首先，我们建立一个足够大的数组，用来模拟足够大的内存空间，该数组的元素应该是一个包含两部分的结构，分别是保存的数据和作为**链**存在的游标。

   建立好的数组大概如下：

   <table>
       <tr>
           <td><strong>下标</strong></td>
           <td>0</td>
           <td>1</td>
           <td>2</td>
           <td>3</td>
           <td>4</td>
           <td>5</td>
           <td>6</td>
           <td>7</td>
           <td>8</td>
           <td>...</td>
           <td>MaxSize-1</td>
       </tr>
       <tr>
           <td><strong>data</strong></td>
           <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td>
       </tr>
       <tr>
           <td><strong>cur</strong></td>
           <td>1</td>
           <td>2</td>
           <td>3</td>
           <td>4</td>
           <td>5</td>
           <td>6</td>
           <td>7</td>
           <td>8</td>
           <td>9</td>
           <td>...</td>
           <td>0</td>
       </tr>
   </table>

2. 然后，我们将这个数组分成四部分：

   - 下标为0的元素：不保存数据，其游标保存**备用链表**的第一个元素的下标值。

   - 最后一个元素：不保存数据，其游标保存**已用链表**的第一个元素的下标，即充当头指针

   - 备用链表：未被使用的数组元素，其中备用链表的最后一个元素的游标应该指向0

   - 已用链表：已使用的数组元素，其最后一个元素的游标应该指向0

3. 接着，我们还需要两个函数来分别模拟`malloc`和`free`函数

4. 然后，我们就可以使用由数组实现的静态链表了



## 2. 代码

- 数据元素类型

  ```c
  typedef struct items ElemType;		// 基础数据元素类型，struct items自行定义
  typedef ElemType *PtrElem;		// 一般数据元素指针
  typedef const ElemType *cPtrElem;		// 指向常量的数据元素指针
  ```

- 预定义常量

  ```c
  #define STATIC_NULL                     0
  // 根据后续定义的static_size_t的实际类型确定
  #define MAXSIZE                         USHRT_MAX
  // 使用时提供LinkList的实例作为参数
  #define MEMORY_POOL(LinkList_Instance)  LinkList_Instance[0].cur            // 备用链表的第一个元素下标
  #define HEAD(LinkList_Instance)         LinkList_Instance[MAXSIZE-1].cur    // 已用链表第一个元素下标
  ```

- 结点类型

  ```c
  typedef unsigned short int static_size_t;
  
  struct node
  {
      ElemType data;
      static_size_t cur;
  };
  typedef struct node Node;
  typedef Node *PtrNode;
  typedef const Node *cPtrNode;
  ```

- 静态链表类型

  ```c
  typedef Node LinkList[MAXSIZE];
  typedef Node *PtrLL;
  typedef const Node *cPtrLL;
  ```
  



# 三. 难点操作

- 初始化

  ```c
  void InitList(PtrLL list)
  {
      for (static_size_t i = 0; i < MAXSIZE - 2; i++) {
          list[i].cur = i + 1;
      }
      list[MAXSIZE - 2].cur = STATIC_NULL;
      HEAD(list) = STATIC_NULL;
  }
  ```

- 访问

  ```c
  Status GetElem(cPtrLL list, static_size_t position, PtrElem elem)
  {
      if (ListEmpty(list)) {
          return ISEMPTY;
      }
      if (position < 1 || position > ListLength(list)) {
          return WRONGPOS;
      }
      static_size_t i = HEAD(list);
      while (--position) {
          i = list[i].cur;
      }
      AssignElem(elem, &list[i].data);
      return SUCCESS;
  }
  ```

- 查找

  ```c
  static_size_t LocateElem(cPtrLL list, cPtrElem elem)
  {
      static_size_t pos = 1;
      static_size_t i = HEAD(list);
      while (i != STATIC_NULL) {
          if (CompareElems(elem, &list[i].data)) {
              return pos;
          }
          pos++;
          i = list[i].cur;
      }
      return 0;
  }
  ```

- 插入

  - 模拟分配内存

    ```c
    static_size_t Static_Malloc(PtrLL list)
    {
        static_size_t i = MEMORY_POOL(list);
        MEMORY_POOL(list) = list[i].cur;
        return i;
    }
    ```

  - 主要操作

    ```c
    Status ListInsert(PtrLL list, static_size_t position, cPtrElem elem)
    {
        if (position < 1 || position > ListLength(list) + 1) {
            return WRONGPOS;
        }
        static_size_t p = Static_Malloc(list);
        if (p == STATIC_NULL) {
            exit(EXIT_FAILURE);
        }
        AssignElem(&list[p].data, elem);
        static_size_t i = MAXSIZE - 1;
        while (--position) {
            i = list[i].cur;
        }
        list[p].cur = list[i].cur;
        list[i].cur = p;
        return SUCCESS;
    }
    ```

- 删除

  - 模拟释放内存

    ```c
    void Static_Free(PtrLL list, static_size_t i)
    {
        list[i].cur = MEMORY_POOL(list);
        MEMORY_POOL(list) = i;
    }
    ```

  - 主要操作

    ```c
    Status ListDelete(PtrLL list, static_size_t position, PtrElem elem)
    {
        if (ListEmpty(list)) {
            return ISEMPTY;
        }
        if (position < 1 || position > ListLength(list)) {
            return WRONGPOS;
        }
        static_size_t i = HEAD(list);
        static_size_t s = MAXSIZE - 1;
        while (--position) {
            s = i;
            i = list[i].cur;
        }
        list[s].cur = list[i].cur;
        AssignElem(elem, &list[i].data);
        Static_Free(list, i);
        return SUCCESS;
    }
    ```

- 遍历链表

  ```c
  void PrintList(cPtrLL list)
  {
      static_size_t p = HEAD(list);
      while (p != STATIC_NULL) {
          PrintElem(&list[p].data);
          p = list[p].cur;
      }
      printf("\n");
  }
  ```

