# 一. 简介

**链表**（Link List）属于线性表的一种，其主要操作性能如下：

- 添加、删除元素：都是 $O(1)$
- 访问元素：平均为 $O(n)$
- 查找元素：与算法相关，一般是 $O(n)$
- 遍历：时间复杂度为 $O(n)$

> 相比于定容数组来说，链表提供了更高的灵活性，但为此牺牲的是访问元素的性能，即使是变长数组，在访问性能上也是与定容数组齐平的。所以，如果是添加、删除操作比较频繁，那么可以使用链表来存储；如果访问操作比较频繁，那么还是选择数组比较好，在数组之间；同时还有空间的权衡，如果空间可预测，那么定容数组是一个比较好的选择，否则的话，选择变长数组或链表比较好。
>
> 但是为了做到在指定位置添加或删除元素，链表同样会花费平均 $O(n)$ 的性能进行访问操作，这与数组的添加及删除操作又差不了多少了，最多只是常数倍数的关系，要做到真正的添加、删除元素达到 $O(1)$ 的时间复杂度，就必须舍弃访问元素的能力，让链表成为真正无序的线性表，但这样的话，就几乎只能从链表头或者链表尾进行插入删除操作，在概念上，这又向栈与队列靠齐了。综上来看，不论是数组还是链表，或许其真正的用途是在为其他数据结构提供一个表示的基础方法。
>
> 如果只是单独的存储数据，或许变长数组是一种比较好的选择，如果想维护一个有序的变长数组，只需要加上一个排序算法就行了，然后插入操作只需要在末尾进行就可以了，此时的时间复杂度仅仅与排序算法的复杂度相同。



# 二. 关键概念

若将链表记为：$(a_1,\ \dots,\ a_{i-1},\ a_i,\ a_{i+1},\ \dots,\ a_n)$，则

- **直接前驱元素**：如 $a_{i-1}$ 是 $a_i$ 的直接前驱元素
- **直接后继元素**：如 $a_{i+1}$ 是 $a_i$ 的直接后继元素
- **表长**：所有有效元素的个数 $n(n\geqslant 0)$
- **空表**：当 $n=0$ 时，称为空表
- **位序**：元素在链表中的位置称为位序，如 $i$ 为 $a_i$ 在链表中的位序
- **头结点**：在第一个有效元素所在结点之前设置的一个结点
- **头指针**：指向链表第一个结点的指针称为头指针



# 三. 抽象数据类型

> - ADT 链表(LinkList)
> - Data
>   链表的数据对象集合为$(a_1,\ a_2,\ \dots,\ a_n)$，每个元素的类型均为`DataType`。其中，除第一个元素$ a_1 $外，每一个元素有且只有一个直接前驱元素，除了最后一个元素$ a_n $外，每一个元素有且只有一个直接后继元素，数据元素之间的关系是一对一的关系
>  - Operation
>    - `InitList(*L)`: 初始化操作，建立一个空的链表L
>    - `ListEmpty(L)`: 若链表为空，返回true，否则返回false
>    - `ClearList(*L)`: 将链表清空
>    - `GetElem(L, i, *e)`: 将链表L中的第i个位置元素值返回给e
>    - `LocateElem(L, e)`: 在链表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成功；否则，返回0表示失败
>    - `ListInsert(*L, i, e)`: 在链表L中的第i个位置插入新元素e
>    - `ListDelete(*L, i, *e)`: 删除链表L中第i个位置元素，并用e返回其值
>    - `ListLength(L)`: 返回链表L的元素个数
> - endADT