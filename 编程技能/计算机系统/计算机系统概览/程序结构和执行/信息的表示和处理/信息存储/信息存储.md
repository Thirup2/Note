内存是由位组成的，而操作系统的基本单位一般是字节，其一般将内存视为一个非常大的字节数组，称为**虚拟内存**。内存的每一个字节都由一个唯一的数字来标识，这就是这个字节的**地址**，所有可能地址的集合就称为**虚拟地址空间**。这个概念通过动态随机访问存储器（DRAM）、内存、磁盘存储器、特殊硬件和操作系统软件结合来实现。

# 一. 十六进制

一个字节由8位组成。在二进制表示法中，它的值域是$00000000_2\sim 11111111_2$；在十进制表示法中，它的值域是$0_{10}\sim 255_{10}$。对于二进制来说，其表示的二进制数字串过于冗长，对于十进制表示来说，其表示法与位模式的转换比较麻烦。

于是就有了**十六进制数**（hexadecimal）来表示位模式。十六进制（简写为“hex”）使用数字‘0’ ~ ‘9’和字符‘A’ ~ ‘F’（不区分大小写）来表示16个可能的值。

表征一串数字是十六进制数一般在其前面添加一个`0x`前缀，如：`0xFA1D37B`

下面是一个十六进制、十进制与二进制对应的表格：

![image](https://user-images.githubusercontent.com/91216205/199455633-9883fd09-c588-477d-b3dc-7c115ac2c3e3.png)

十六进制向二进制的转换比较简单，只需要将十六进制数每一个位转换成对应的4位二进制数即可；同样，将二进制数转换为十六进制也一样，但需要注意的是需要从二进制数的最右侧开始，每次将四位二进制数转换为一个十六进制数，最左侧的几位二进制数如果不足4位则在左侧补零即可。

十六进制与十进制之间的转换也比较简单，将‘A’~‘F’这六个字符对应的十进制记住就行了，可以先记住三个标志用的字符对应的十进制，如`A`、`C`、`F`，然后其他的字符`B`、`D`、`E`可以根据它们和前面三个字符之间的关系很快推断出来。当然如果是超过一位的十六进制数或超过15的十进制数需要按位数取16的$n$次幂($n$为`位数-1`)或反复地用16除以十进制数将所有余数串联起来即可（具体的不做叙述）。



# 二. 数据大小

每台计算机都有一个**字长**（word size），它指明了指针数据的大小。因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。对于一个字长为$\omega$位的机器而言，虚拟地址的范围为：$0\sim 2^\omega-1$，程序最多访问$2^\omega$个字节。据计算，32位字长限制计算机的虚拟地址空间为4GB大小，而64位却使得机器的虚拟地址空间为16EB。

大多数的64位机器都能运行32位机器编译的程序，这是一种向后兼容。

以C语言为例，其支持的多种数据类型的大小如下表所示：

![image](https://user-images.githubusercontent.com/91216205/199468675-1ab73fb2-694b-427c-8f88-ab653d72a39c.png)

上表中给出的大小只是一个典型值，因为C语言并没有规定每种类型的绝对大小



# 三. 字节顺序

许多程序对象的大小不止一个字节，所以我们在定位一个对象的时候，必须明确两点：对象的地址是什么，以及在内存中如何排列这些字节。

按照人的常理来说，我们更希望内存的排序从小到大排列，然后对象的数据按照顺序放入从某个字节开始的几个连续字节中，这样我们就可以把这个对象的起始字节作为这个对象的地址，当我们找到这个对象的地址之后，也能很自然的看出整个对象的数据内容（只要知道一个对象的字节大小），这个方法叫做大端法，与之相对的叫做小端法，二者的定义如下：

假设有一个$\omega$位的整数，其位表示为$[x_{w-1},\ x_{w-2},\ \dots,\ x_1,\ x_0]$，其中$x_{w-1}$是最高有效位，而$x_0$是最低有效位。假设$\omega$是8的倍数，这些位就能被分组成为字节，其中最高有效字节包含位$[x_{w-1},\ x_{w-2},\ \dots,\ x_{w-8}]$，而最低有效字节包含位$[x_7,\ x_6,\ \dots,\ x_0]$，其他字节包含中间的位。某些机器选择在内存中按照从最低有效字节到最高有效字节的顺序存储对象，而另一些机器则按照从最高有效字节到最低有效字节的顺序存储。前一种规则——最低有效字节在最前面的方式，称为**小端法**（little endian）。后一种规则——最高有效字节在最前面的方式，称为**大端法**（big endian）。

假设变量$x$的类型为`int`，位于地址`0x100`处，它的十六进制值为`0x01234567`，则大端法与小端法的存储效果如下：

![image](https://user-images.githubusercontent.com/91216205/199473569-76822a6b-c2c7-44b0-9530-16c444690353.png)

对于比较新的微处理器来说，现在一般都是**双端法**（bi-endian），也就是说可以对处理器进行配置，让它作为大端或者小端的机器运行，这一步一般在选定操作系统之后也就决定了，操作系统会对其进行配置。

字节顺序可能会导致一些问题：

- 当小端法及其产生的数据被发送到大端法机器或者与之相反，接受程序会发现，字里的字节成了反序的。
- 当检查机器级程序时，代码中数据的字节顺序很重要
- 如C语言中的联合，由于两个类型可以合用一块内存，所以字节顺序也很重要，这也是一种检测自己的机器是大端法还是小端法的方法



# 四. 布尔代数

布尔代数即将逻辑值中**真**（TRUE）和**假**（FALSE）编码为1和0，这刚好和一个位能够表示的内容相同。

布尔代数有四种运算：非（`~`）、且（`&`）、或（`|`）以及异或（`^`），其运算的结果如下图所示：

![image](https://user-images.githubusercontent.com/91216205/199489928-1c262768-99f1-4d3d-9810-d12c68e173f3.png)

对于由多个位构成的数据来说，它们之间的位运算相当于对二者每一个对应的位进行位运算之后的结果组成的一个位串，具体的定义如下：

首先定义一个概念，叫做**位向量**，即一个固定长度为$\omega$、由 0 和 1 组成的串，一个`int`类型的数据在大部分机器中的表示就是一个固定长度为 32 的 0、1 串。**位向量的运算可以定义成参数的每个对应元素之间的运算**。假设`a`和`b`分别表示位向量 $[a_{w-1},\ a_{w-2},\ \dots,\ a_0]$ 和$[b_{w-1},\ b_{w-2},\ \dots,\ b_0]$。我们将 $a\ \&\ b$ 也定义为一个长度为 $\omega$ 的位向量，其中第 $i$ 个元素等于 $a_i\ \&\ b_i,\ 0\leqslant i<w$ 。可以用类似的方式将运算`|`、`^`和`~`扩展到位向量上。

我们还可以用位向量来编码任意一个包含于集合 $\{0,\ 1,\ 2,\ \dots,\ w-1\}$ 的集合，即把一个 $w$ 位的位向量对应的位设置为 1，其余位设置为 0 即可，被设置为 1 的位向量的位所在的位置就是这个子集的一个元素。如位向量 $a=[01101001]$ 这个位向量如果表示的是集合$A$，那么集合$A=\{0,\ 3,\ 5,\ 6\}$ ，因为位向量 $a$ 中第 1，4，6，7位是 1，其余位全是 0



# 五. C语言中的逻辑运算与位运算

C语言中的逻辑运算与位运算是两个不同的运算，逻辑运算可以认为是两个位之间的运算，但位运算却是两个位向量之间的运算：

**逻辑运算**：两个布尔值之间进行逻辑运算，结果为 TRUE 或 FALSE，使用逻辑运算符 `||`、`&&`和`!`。当然，在C语言中不存在布尔值 TRUE 和 FALSE，C语言将所有非 0 作为 TRUE，0 作为 FALSE。其示例如下图所示：

![image](https://user-images.githubusercontent.com/91216205/199498136-7964a099-0d21-48c4-8615-6e8bf6cc31e5.png)

**位运算**：两个整数类型的值转换为二进制后得到的两个位向量进行位运算，结果依然是一个整数，使用位运算符`|`、`&`、`~`以及`^`。其示例如下图所示：

![image](https://user-images.githubusercontent.com/91216205/199498410-189f9357-669c-4d9b-97fc-36f5943f781e.png)

**移位操作**：将一个整数类型的值转换为二进制后得到的位向量整体向左或向右移动，使用移位运算符`<<`和`>>`。

- 对于左移运算符`<<`而言，左侧移出位向量区域的位直接抛弃，右侧缺少的位直接用 0 补齐
- 对于右移运算符`>>`而言，右侧移出位向量区域的位直接抛弃，左侧缺少的位用 1 或 0 补齐，这主要有下面两种可能：
  - 左侧缺少的位都用 0 补齐，这称作**逻辑右移**，对于无符号数，右移必须是逻辑的。
  - 左侧缺少的位都用之前最左侧的位补齐，这称作**算术右移**

其示例如下图所示：

![image](https://user-images.githubusercontent.com/91216205/199498645-8fcdbfd7-69b2-4ee3-804d-8c29a25aa006.png)

