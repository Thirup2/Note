# 一. 前言

浮点数的表示一开始并没有什么规则，每个计算机制造商都设计了自己的表示浮点数的规则，以及对浮点数执行运算的细节。直到 1985 年IEEE标准 754 的推出。现在所有的计算机都支持这个后来被称为 **IEEE浮点** 的标准。



# 二. 二进制小数

在讨论浮点数之前，我们需要先理解一下含有小数值的二进制数字。

在此之前，先看一下十进制小数，它的形式如下：
$$
d_md_{m-1}\dots d_1d_0.d_{-1}d_{-2}\dots d_{-n}
$$
其中每个十进制数 $d_i$ 的取值范围是 $0\sim 9$ 。该表达所描述的数值 $d$ 定义如下：
$$
d=\sum_{i=-n}^m10^i\times d_i
$$
很明显，对于小数点左边的数字，其权为非负幂，对于小数点右边的数字，其权为负幂。十进制这个属性影响的只是每一位数字的范围以及在 $d$ 的表达式中的 10 这个数字。

所以，我们可以很容易将其推导至二进制小数的表示，首先其表现形式如下：
$$
b_mb_{m-1}\dots b_1b_0.b_{-1}b_{-2}\dots b_{-n-1}b_{-n}
$$
其中每个二进制数字 $b_i$ 的取值范围是 0 和 1。该表达式所描述的数值 $b$ 定义如下：
$$
b=\sum_{i=-n}^m2^i\times b_i
$$
对于二进制小数而言，其与十进制小数的一个区别就是能够表示的准确度不同，例如用十进制表示 $1\over 5$ 为 $0.2$，但是如果想要使用二进制小数来表示会发现无法准确表示，即使增加表达的位数也只能提高精度却改变不了其准确度。

另外，对于 $0.111\dots 111$ 这种形式的二进制数，其表示的数的规则和下面这一串数所表达的规则相同：${1\over 2},\ {3\over 4},\ {7\over 8},\ {15\over 16},\ \dots$

我们可以用 $1.0-\epsilon$ 来表示这样的数值。



# 三. IEEE浮点表示

如果要用类似于整数表示那样的方法来表示浮点数，那么对于大部分浮点数我们都需要大量的位来表示，如 $5\times 2^{100}$ ，它的整数类型表示是用 $101$ 后面跟随 $100$ 个零的位模式来表示。这显然很困难，首先数可以无限大，不可能一直提高位数来精确表示；其次，浮点数意味着需要精度，对于非整数来说怎么办呢？

首先对于任何一个十进制数，我们都可以用 $x\times 10^y$ 的形式来表示，即科学计数法。而对于二进制表示的数，我们也都可以用 $x\times 2^y$ 的格式来表示，只是与 10 进制的精确度稍有差别而已。所以现在我们的问题是如何来表示形如 $x\times 2^y$ 的值。

IEEE浮点标准规定了表示 $x\times 2^y$ 的值的方法，即用 $V=(-1)^s\times M\times2^E$ 的形式来表示一个数，其含义如下：

- $s$：符号，决定这个数是负数（$s=1$）还是正数（$s=0$），对于数值 0，其符号位解释作为特殊情况处理
- $M$：尾数，它是一个二进制小数，它的范围是 $1\sim 2-\epsilon$，或者是 $0\sim 1-\epsilon$（实际上就是表示小数整数部分的位只有 1 位）
- $E$：阶码，其作用是对浮点数加权，这个权重是 2 的 $E$ 次幂（可能是负数）

如果根据IEEE标准来表示一个浮点数，那么就需要先将浮点数的位分为三部分来分别表示上述三个部分：

- 一个单独的符号位 $s$ 直接编码符号 $s$
- $k$ 位的阶码字段 $exp=e_{k-1}\dots e_1e_0$ 编码阶码 $E$
- $n$ 位小数字段 $frac=f_{n-1}\dots f_1f_0$ 编码尾数 $M$，编码出来的值依赖于阶码字段的值是否等于 0

下图展示了按照IEEE标准下的单精度与双精度浮点数的位分配情况：

![image](https://user-images.githubusercontent.com/91216205/200098440-39efbc85-d116-4e77-9a1d-cf73a5152efb.png)

其中比较特殊的是阶码部分，因为阶码也可能是负数，而 $s$ 表示的是整个表达式的正负或者说是尾数部分的正负。对于阶码的表示可以分成下图所示的几种情况：

![image](https://user-images.githubusercontent.com/91216205/200098843-d14c449e-a1b6-40a8-b27f-ff3342c9212d.png)

1. 规格化的值

   这是最普遍的情况。当 $exp$ 的位模式既不全为 0，也不全为 1 时，都属于这类情况。在这种情况中，阶码字段被解释为以偏置形式表示的有符号整数，其值为 $E=e-Bias$，其中 $e$ 是将这些位解释为一个无符号整数后的值，其位表示为 $e_{k-1}\dots e_1e_0$，$Bias$ 就是偏置值，其值为 $2^{k-1}-1$。综上，阶码所表示的指数的取值范围为 $-2^{k-1}+2\sim 2^{k-1}-1$。

   这种情况下，小数字段 $frac$ 被解释为描述小数值 $f$ ，其中 $0\leqslant f<1$，其二进制表示为 $0.f_{n-1}\dots f_1f_0$，也就是二进制小数点在最高有效位的左边。尾数定义为 $M=1+f$。该方式也叫作 **隐含的以 1 开头的** 表示，即 $M$ 可以看做一个二进制表达式为 $1.f_{n-1}f_{n-2}\dots f_0$ 的数字。

   对于大部分数字，我们都可以用这种方式表示，只需要调整阶码 $E$ 就可以将尾数 $M$ 保持在范围 $1\leqslant M<2$ 中。

   对于该方法而言，由于其整数部分一定为 0，所以我们可以不用显示地表示它，这样就可以多一个位来提升精度。

2. 非规格化的值

   当阶码的位模式全是 0 时，所表示的数是 **非规格化** 形式。在这种情况下，阶码值为 $E=1-Bias$，尾数的值是 $M=f$，也就是小数字段的值，开头不是隐含的 1 而是 0

   使用非规格化数可以表示数值 0，在规格化的表示当中，$M$ 一定大于等于 1，因此我们就不能表示 0。而非规格化数可以将浮点数所有位都设置为 0 来表示 0，即 $M=f=0$。另外，当符号位为 1 时，其他域全为 0 时，其值也为 0，作为区分，前者写作 $+0.0$，后者写作 $-0.0$，它们在某些方面被认为是不同的。

   另外非规格化数可以表示那些非常接近与 $0.0$ 的数，它们提供了一种属性，称为 **逐渐下溢**。

3. 特殊值

   当阶码全是 1 时，该浮点数表示特殊值。当小数域全为 0 时，得到的值表示无穷，当 $s=0$ 时是 $+\infty$；当 $s=1$ 时是 $-\infty$。当小数域为非零时，结果值被称为 $NaN$ ，即 “不是一个数” 的缩写，比如 $\sqrt{-1}$ 的结果就应该是 $NaN$。



# 四. 整数转换为浮点数

将一个整数转换为浮点数的过程如下：

首先整数的小数点在其位模式的最右侧，首先将其转换为一个规格化的表示需要将小数点左移，直到小数点左边只有一个 1 为止。然后将整数部分的 1 隐藏不表示，小数点移动的位数就是阶码的值减去偏置值得到的值，所以该浮点数的阶码应该是这个移动的位数加上偏置值转换为无符号整数的位表示。然后尾数部分需要将我们得到的小数的小数点右侧的位依次放到尾数部分中，不足的部分用 0 填充。符号位根据符号判断即可。

如将一个整数 $12345$ 转换为浮点表示过程如下：

- 首先 $12345$ 的位模式为：$[11000000111001]$
- 移动其小数点到最高的一个 1 后面：$[1.1000000111001]$，移动了 13 位，即 $12345=1.1000000111001_2\times 2^{13}$
- 浮点数第一个位设置为 0（正数）
- 计算 $k$ 位阶码字段：$E=13+(2^{k-1}-1)$，然后将其解释为无符号值的位表示，依次填入到阶码部分
- 尾数部分的 $n$ 位设置为 $[100000011100100\dots 00]$



# 五. 舍入

由于浮点数的表示大概率是不准确的，要更精确只能添加用于表示的位数，但是位数是有限的，总会到某个位置之后就不能再精确了，这个时候就需要对最后一位数进行舍入。而如何进行舍入也是一个问题，其主要方式有以下几种：

1. 向偶数舍入：也被称为向最近的值舍入，是默认的方式，试图找到一个最接近的匹配值。对于中间值以下的值来说，将其向下舍入；对于中间值以上的值来说，将其向上舍入；而对于中间值来说，可能将数字向上或向下舍入，使得结果的最低有效数字是偶数。
2. 向零舍入：即向靠近零的方向舍入，对于正数来说，就是向下舍入；对于负数来说，就是向上舍入
3. 向下舍入：不论正负，都向下进行舍入。对于正数来说，与向零舍入同向；对于负数来说，与向零舍入反向
4. 向上舍入：与向下舍入的方向相反

对一个实数进行舍入可以用下面的表达式来表示：$Round(x)$。