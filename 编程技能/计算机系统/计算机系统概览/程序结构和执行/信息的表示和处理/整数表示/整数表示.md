# 一. 前言

整数在C语言中分为两类，一类是无符号整数，一类是带符号整数，二者的编码方式有些不同。

在研究编码方式和操作时，会用到以下的数学术语：

| 符号     | 类型 | 含义             |
| -------- | ---- | ---------------- |
| $B2T_w$  | 函数 | 二进制转补码     |
| $B2U_w$  | 函数 | 二进制转无符号数 |
| $U2B_w$  | 函数 | 无符号数转二进制 |
| $U2T_w$  | 函数 | 无符号数转不嘛   |
| $T2B_w$  | 函数 | 补码转二进制     |
| $T2U_w$  | 函数 | 补码转无符号数   |
| $TMin_w$ | 常数 | 最小补码值       |
| $TMax_w$ | 常数 | 最大补码值       |
| $UMax_w$ | 常数 | 最大无符号数     |
| $+^t_w$  | 操作 | 补码加法         |
| $+_w^u$  | 操作 | 无符号数加法     |
| $*^t_w$  | 操作 | 补码乘法         |
| $*_w^u$  | 操作 | 无符号数乘法     |
| $-_w^t$  | 操作 | 补码取反         |
| $-_w^u$  | 操作 | 无符号数取反     |



# 二. 无符号数的编码

对于一个 $w$ 位的位向量，我们可以将其写成 $\vec {x}$，表示整个向量；也可以将其写成 $[x_{w-1},\ x_{w-2},\ \dots,\ x_0]$，表示向量中的每一位。

## 1. 定义

对向量 $\vec{x}=[x_{w-1},\ x_{w-2},\ \dots,\ x_0]$：
$$
B2U_w(\vec{x})=\sum^{w-1}_{i=0}x_i2^i
$$
该等式的含义是：将位向量 $\vec{x}$ 由二进制转换为无符号数后，其值为等号右边的部分

其中：

$x_i$ 即第 $i$（$i$ 从 0 开始）位的取值，非 0 即 1。

例：
$$
B2U_4([0001])=0\cdot 2^3+0\cdot 2^2+0\cdot 2^1+1\cdot 2^0=0+0+0+1=1\\
B2U_4([0101])=0\cdot 2^3+1\cdot 2^2+0\cdot 2^1+1\cdot 2^0=0+4+0+1=5\\
B2U_4([1011])=1\cdot 2^3+0\cdot 2^2+1\cdot 2^1+1\cdot 2^0=8+0+2+1=11\\
B2U_4([1111])=1\cdot 2^3+1\cdot 2^2+1\cdot 2^1+1\cdot 2^0=8+4+2+1=15
$$

## 2. 性质

- 最小值：0
- 最大值：$UMax_w=B2U_w([11\dots 1])=2^w-1$
- 唯一性：无符号数编码具有唯一性，即每个介于 $0\sim 2^w-1$ 之间的数都有唯一一个 $w$ 位的值编码



# 三. 有符号数的编码（补码编码）

## 1. 定义

对向量 $\vec{x}=[x_{w-1},\ x_{w-2},\ \dots,\ x_0]$：
$$
B2T_w(\vec{x})=-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i
$$
该等式的含义是：将向量 $\vec{x}$ 转换为补码后，其值等于右边的部分，

其中：

$x_{w-1}$ 表示用最高位表示符号，也称为**符号位**，当该位为 1 时，为负；

$-2^{w-1}$ 表示它的权重，是一个负数。

例：
$$
B2T_4([0001])=-0\cdot 2^3+0\cdot 2^2+0\cdot 2^1+1\cdot 2^0=0+0+0+1=1\\
B2T_4([0101])=-0\cdot 2^3+1\cdot 2^2+0\cdot 2^1+1\cdot 2^0=0+4+0+1=5\\
B2T_4([1011])=-1\cdot 2^3+0\cdot 2^2+1\cdot 2^1+1\cdot 2^0=-8+0+2+1=-5\\
B2T_4([1111])=-1\cdot 2^3+1\cdot 2^2+1\cdot 2^1+1\cdot 2^0=-8+4+2+1=-1
$$

## 2. 性质

- 最小值：$TMin_w=B2T_w([10\dots 0])=-2^{w-1}$；
- 最大值：$TMax_w=B2T_w([01\dots 1])=2^{w-1}-1$；
- 唯一性：补码编码具有唯一性，即每个介于 $-2^{w-1}\sim 2^{w-1}-1$ 之间的数都有唯一一个 $w$ 位的编码
- 补码的范围不对称：$|TMin|=|TMax|+1$
- 相同位向量转换成的无符号数值刚好比补码的最大值的两倍大一点：$UMax_w=2TMax_w+1$

**注意**：将全是 1 的位向量转换成补码并不像看上去负得那么多，其值刚好是负得最少的，为 $-1$ ；将除了符号位之外全是 0 的位向量转换成补码也并不上看上去负得那么少，其值是负得最多的，为 $-2^{w-1}$ 。

## 3. 其他编码方式

### 1）反码（Ones’  Complement）

其最高有效位的权是 $-(2^{w-1}-1)$ 而不是 $-2^{w-1}$，其余部分与补码相同：
$$
B2O_w(\vec{x})=-x_{w-1}(2^{w-1}-1)+\sum_{i=0}^{w-2}x_i2^i
$$
很明显，这种编码方式的正负值是对称的，最小值的绝对值与最大值相同，并且值为 0 的编码不唯一。

### 2）原码（Sign-Magnitude）

其最高有效位是符号位，并无权重，该位用来确定剩下的位应该取负还是取正：
$$
B2S_w(\vec{x})=(-1)x_{w-1}\cdot (\sum_{i=0}^{w-2}x_i2^i)
$$
这种编码将负数转换为正数的操作非常简单，只需要更改最高位的值即可。同时，它的正负值也是对称的，并且 0 的编码也不唯一。



# 四. 有符号数和无符号数之间的转换

在各种高级编程语言中，都会或多或少用到一些类型转换的操作，下面主要讨论由一个数转换为相同位数的无符号或有符号数计算机进行的处理，并不包括整型提升等会改变数字位数的操作。

首先一个 $w$ 位的无符号数的范围在 $0\sim 2^w-1$ 之间，一个 $w$ 位的有符号数的范围在 $-2^{w-1}\sim 2^{w-1}-1$ 之间，二者的重合区域为：$0\sim 2^{w-1}-1$，非重合区域有：$-2^{w-1}\sim -1$ 以及 $2^{w-1}\sim 2^w-1$，当数据处于重合区域时，二者的值都相同，并且很明显二者的位向量也是相同的，此时无论是有符号数转换为无符号数还是无符号数转换为有符号数其值都相同。所以以下主要讨论数据处于非重合区域时计算机的转换过程。

在讨论之前，很显然的一件事是：**无论怎么转换，都不会改变该数据的位向量**。

(以下无符号数默认使用补码表示)

## 1. 无符号转换为有符号数

无符号数中与有符号不重合的范围是：$2^{w-1}\sim 2^w-1$ ，其最高位一定是 1，当将其转换为有符号数后，其数值必然是负数。

其定义可以如下（其中带下标的 $u$ 表示该数据位向量某个位的数值）：

- $U2T_w(u)=B2T_w(U2B_w(u))=-u_{w-1}2^w+u$
- $U2T_w(u)=\begin{cases}u, & u\leqslant TMax_w \\ u-2^w, & u>TMax_w\end{cases}$

## 2. 有符号转换为无符号数

有符号数中与无符号不重合的范围是：$-2^{w-1}\sim -1$，其最高位也为 1，当将其转换为无符号数后，其值一定大于$2^{w-1}-1$。

其定义可以如下（其中带下标的 $x$ 表示该数据位向量某个位的数值）：

- $T2U_w(x)=B2U_w(T2B_w(x))=x+x_{w-1}2^w$
- $T2U_w(x)=\begin{cases}x+2^w, & x<0\\ x, & x\geqslant0 \end{cases}$



# 五. 数字的位表示的扩展

与符号转换一样常见的操作还有整型的提升，上一节提供了无符号与有符号数之间的转换方法，所以本节将独立于上一节进行。也就是说，本节讨论由无符号数提升到无符号数以及有符号数提升到有符号数，并不讨论无符号数提升到有符号数或有符号数提升到无符号数，因为这种提升可以将本节与上一节结合起来完成。

## 1. 无符号数的扩展

无符号数的位扩展非常简单，只需要在其位向量的开头添加 0 即可。这种运算被称为**零扩展**，其表示原理如下：

定义宽度为 $w$ 位的位向量 $\vec{u}=[u_{w-1},\ u_{w-2},\ \dots,\ u_0]$ 和宽度为 $w'$ 位的位向量 $\vec{u}'=[0,\ \dots,\ 0,\ u_{w-1},\ u_{w-2},\ \dots,\ u_0]$，其中 $w'>w$。则 $B2U_w(\vec{u})=B2U_{w'}(\vec{u}')$。

## 2. 有符号数的扩展

对于补码而言，有符号数的补码将在位向量的开头添加最高有效位的值，这种运算被称为**符号扩展**，其原理如下：

定义宽度为 $w$ 的位向量 $\vec{x}=[x_{w-1},\ x_{x-2},\ \dots,\ x_0]$ 和宽度为 $w'$ 的位向量 $\vec{x}'=[x_{w-1},\ \dots,\ x_{w-1},\ x_{w-1},\ x_{w-2},\ \dots,\ x_0]$，其中$w'>w$ 。则 $B2T_w(\vec{x})=B2T_{w'}(\vec{x}')$。



# 六. 截断数字

将一个大类型的整数转换成一个小类型的整数的操作有时也会遇到，这个操作会将一个数字的位表示进行截断，同样，对于该操作的讨论也是在类型独立的基础上进行的。

数字的截断都是从最高位开始，最后保留的是原本在位向量中右边部分的 $k$ 位，$k$ 为被截断后保留的位数。下面主要讨论的是当一个数字被截断后的数值。

## 1. 无符号数的截断

首先无符号数都是大于 0 的数，其次每次从最高位截断一位就相当于将原数值除以了 2，最后的数值相当于对 $2^{w-1}$ 取模，将其推广至更一般的情况可以得到，将一个 $w$ 位的无符号数截断为 $k$ 位后得到的数值为 $x\ mod\ 2^k$ ，这也就是下面的定义：

令 $\vec{x}$ 等于位向量 $[x_{w-1},\ x_{w-2},\ \dots,\ x_0]$ ，而 $\vec{x}'$ 是将其截断为 $k$ 位的结果：$\vec{x}'=[x_{k-1},\ x_{k-2},\ \dots,\ x_0]$。令 $x=B2U_w(\vec{x}),\ x'=B2U_k(\vec{x}')$。则 $x'=x\ mod\ 2^k$。

可以说，只要大类型的无符号数在小类型的无符号数的数值范围内，那么这种转换的截断对其值是无影响的，因为被截断的位的值都为0。

## 2. 有符号数的截断

有符号数的截断原理是：先将数对 $2^k$ 取模，然后将得到的数执行 $U2T_w(\vec{x})$ 函数。之所以这样做，是因为要满足两个要求：

1. 对一个大类型的数值在小类型的无符号数的数值范围内时，进行截断后，其值应该和截断前相同；
2. 当对一个数进行截断后，得到的数值如果超过了对应类型的有符号数的表示范围但是在无符号数的表示范围内时，其应该进行转换且转换所得的值应该和直接进行同等类型大小之间有符号和无符号数转换得到的值相同。

其具体的定义如下：

令 $\vec{x}$ 等于位向量 $[x_{w-1},\ x_{w-2},\ \dots,\ x_0]$，而 $\vec{x}'$ 是将其截断为 $k$ 位的结果：$\vec{x}'=[x_{k-1},\ x_{k-2},\ \dots,\ x_0]$。令 $x=B2U_w(\vec{x}),\ x'=B2T_k(\vec{x}')$。则 $x'=U2T_k(x\ mod\ 2^k)$。
