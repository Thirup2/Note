# 一. 简介

下表列出了x86-64 的一些整数和逻辑操作：

| 指令                                                         | 效果                                                         | 描述                                                      |
| ------------------------------------------------------------ | ------------------------------------------------------------ | --------------------------------------------------------- |
| `leaq S, D`                                                  | $D\longleftarrow \&S$                                        | 加载有效地址                                              |
| `INC D`<br/>`DEC D`<br/>`NEG D`<br/>`NOT D`                  | $D\longleftarrow D+1$<br />$D\longleftarrow D-1$<br />$D\longleftarrow -D$<br />$D\longleftarrow \sim D$ | 加1<br />减1<br />取负<br />取补                          |
| `ADD S, D`<br/>`SUB S, D`<br/>`IMUL S, D`<br/>`XOR S, D`<br/>`OR S, D`<br/>`AND S, D` | $D\longleftarrow D+S$<br />$D\longleftarrow D-S$<br />$D\longleftarrow D\times S$<br />$D\longleftarrow D^S$<br />$D\longleftarrow D\ \|\ S$<br />$D\longleftarrow D\ \&\ S$ | 加<br />减<br />乘<br />异或<br />或<br />与              |
| `SAL k, D`<br />`SHL k, D`<br />`SAR k, D`<br />`SHR k, D`   | $D\longleftarrow D<<k$<br />$D\longleftarrow D<<k$<br />$D\longleftarrow D>>_A k$<br />$D\longleftarrow D>>_L k$ | 左移<br />左移（等同于`SAL`）<br />算术右移<br />逻辑右移 |

> - 对于大写的操作表示指令类，这些指令类有各种带不同大小操作数的变种；小写的操作表示具体的某个指令
> - 对于上表中的每一个操作来说，都是在$D$的基础上执行了一些操作，并将值放在$D$中，并没有用第二个寄存器来存储结果



# 二. 加载有效地址

加载有效地址的指令为：`leaq`。其两个操作数，左边的是一个按照内存引用格式写出的操作数，右边操作数是一个寄存器或一个地址引用。

其执行的操作是将左操作数的计算结果赋给右操作数，所以通过这一个指令，我们可以将一些简单的加法和乘法运算放在一个指令中。

需要注意的是，左操作数虽然是一个内存引用格式，但是其并未执行内存引用操作，整个过程是先展开地址运算式，然后将寄存器中的值放到这个运算式中进行计算，然后将计算所得的结果放入右操作数中；而对于`movq`操作来说，如果有内存引用格式的操作数，那么其执行的操作是，先按照与上述相同的方式计算地址运算式的值，**然后根据计算所得的值，将其作为地址对内存进行访问**，然后将访问得到的值赋给右操作数。所以二者的区别就在于`movq`指令多出了加粗的那一部分。

例：

对于一个C代码：

```c
long scale(long x, long y, long z)
{
    long t = x + 4 * y + 12 * z;
    return t;
}
```

将转换为下面的汇编代码：

```assembly
scale:
	leaq (%rdi, %rsi, 4), %rax		; 将 x + 4 * y 存入 %rax 寄存器
	leaq (%rdx, %rdx, 2), %rdx		; 地址计算结果为：z + 2 * z = 3 * z, 然后将 3 * z 存入到 %rdx 寄存器
	leaq (%rax, %rdx, 4), %rax		; 地址计算结果为：(x + 4 * y) + 4 * (3 * z) = x + 4 * y + 12 * z, 然后将结果存入到 %rax 寄存器
	ret
```



# 三. 一元和二元操作

对于一元操作来说，包括`INC`、`DEC`、`NEG`、`NOT`这四类操作，它们只有一个操作数，既是源也是目的。这个操作数可以是一个寄存器，也可以是一个内存位置。

对于二元操作来说，包括`ADD`、`SUB`、`IMUL`、`XOR`、`OR`、`AND`这几类操作，第二个操作数既是源也是目的，前三个是算术运算，后面三个是逻辑运算。



# 四. 移位操作

最后一组是移位操作，包括`SAL`、`SHL`、`SAR`、`SHL`这四类操作，它们有两个操作数，第一个操作数是位移量，第二个操作数是要移位的数。这四类操作又可分为两类操作，一是算术移位：`SAL`和`SAR`，二是逻辑移位：`SHL`和`SHR`。只不过因为对于左移操作来说，其算术左移和逻辑左移效果相同，所以二者任选一个即可。

**注意**：

- 对于左操作数来说，只能是一个立即数或者放在单字节寄存器`%cl`中

- x86-64 中，移位操作对 $\omega$ 位长的数据值进行操作，移位量由`%cl`的低`m`位决定，其中 $2^m=\omega$ 。

  如当寄存器`%cl`的十六进制值为`0xFF`时，指令`salb`会移 7 位，`salw`会移 15 位，`sall`会移 31 位，而`salq`会移 63 位