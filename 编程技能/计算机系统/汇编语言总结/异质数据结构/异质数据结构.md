# 一. 结构

在 C 语言中，结构和数组有相似之处，首先数组是将一堆相同类型的元素聚合在一起，而结构可能是不同类型的元素聚合在一起。

结构的所有组成部分都存放在内存中一段连续的区域内，而指向结构的指针就是结构第一个字节的地址。编译器维护每个结构类型的信息，指示每个字段的字节偏移。它以这些偏移作为内存引用指令中的位移，从而产生对结构元素的引用。

假设有下面这样一个结构声明：

```c
struct rec
{
    int i;
    int j;
    int a[2];
    int *p;
};
```

假设一个`int`类型为 4 个字节，`rec`的起始地址为 $x_A$ ，那么`rec`中各元素的偏移量如下：

- `i`：0
- `j`：4
- `a`：8
- `p`：16

要访问对应的元素，就使用 $x_A+偏移量$ 以及对应元素的大小即可访问对应的元素。另外，`a`是一个数组，其中的元素也有偏移量，这些元素的偏移量则是相对于数组的地址而言的，所以在此只考虑数组起始位置即可。



# 二. 联合

联合看上去和结构相似，但实际上和结构有很大不同。

联合声明的所有成员表示这个联合类型可以解释为的类型个数，也就是说联合可以是其声明中的所有成员类型中的一种，但不能是多个类型的组合。

同时，一个联合类型的大小由联合声明中最大长度成员类型决定。

不论怎么声明，联合声明的所有成员的偏移量都是 0，其数据的不同主要根据访问时选择的类型决定。

如有下面的声明：

```c
union U3
{
    char c;
    int i[2];
    double v;
};
```

则`c`、`i`、`v`的偏移量都是 0，另外`U3`的大小为成员中最大长度数据类型的值即`double`类型的值：8 字节



# 三. 数据对齐

许多计算机系统对基本数据类型的合法地址做出了一些限制，要求某种类型对象的地址必须是某个值 $K$（通常是 2、4 或 8）的倍数。这种对齐限制简化了形成处理器和内存系统之间接口的硬件设计。

对于 x86-64 来说，无论数据是否对齐，硬件都能正确工作。不过，Intel 还是建议要对齐数据以提高内存系统的性能。对齐原则是任何 $K$ 字节的基本对象的地址必须是 $K$ 的倍数。

即对于`char`类型来说，`char`类型的实体对象的地址可以是任意的地址，对于`int`类型来说，其实体对象的地址必须是 4 的倍数，而对于`double`类型来说，其实体对象的地址必须是 8 的倍数。

所以，对于结构来说，假设有下面的声明：

```c
struct S1
{
    int i;
    char c;
    int j;
};
```

由于`i`的地址必须是 4 的倍数，所以`S1`的地址也必须是 4 的倍数。从内存中找到一个符合该条件的地址作为`S1`的起始地址。

然后`c`的地址可以是任何数，所以`c`的偏移量为 4，此时`c`之后的第一个位置是以 4 的倍数的一个地址上偏移量为 5 的一个地址。

由于`j`必须是 4 的倍数，所以`c`后面的 3 个字节都不满足条件，将跳过在该处存放`j`，最终在偏移量为 8 的位置存放`j`。

由此可以看出，`S1`中三个元素理论上总共的大小应该只有 9 个字节，但实际上花费了 12 个字节。

另外，为了满足结构的数组元素的对齐，编译器可能会在结构的末尾添加一些空位填充，如

```c
struct S2
{
    int i;
    int j;
    char c;
};
```

编译器可能会为结构`S2`分配 12 个字节。