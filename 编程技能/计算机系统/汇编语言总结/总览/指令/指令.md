# 一. 数据传送

## 1. 对等数据类型传送

| 指令类     | 效果             | 描述                                   | 指令                                                         |
| ---------- | ---------------- | -------------------------------------- | ------------------------------------------------------------ |
| $MOV\ S,D$ | $S\rightarrow D$ | 将第一个操作数传送到第二个操作数的地址 | `movb`（传送字节）<br />`movw`（传送字）<br />`movl`（传送双字）<br />`movq`（传送四字）<br />`movabsq`（传送绝对的四字） |

**注意**：

- 第一个操作数可以是一个立即数，也可以是保存在寄存器或内存中的立即数；第二个操作数指定一个位置，要么是一个寄存器，要么是一个内存地址
- 在 x86-64 中，传送指令的两个操作数不能都指向内存位置，所以将一个值从一个内存位置复制到另一个内存位置需要两条指令，以寄存器为中转
- 如果其中一个操作数是寄存器，则该寄存器的大小必须与值令指定的大小相同
- `movl`值令若以寄存器为目的时，它会把该寄存器的高位 4 字节设置为 0
- `movq`指令只能以表示为 32 位补码数字的立即数为源操作数，然后把这个值符号扩展得到 64 位的值，放到目的位置；`movabsq`指令能够以任意 64 位立即数值作为源操作数，并且只能以寄存器作为目的



## 2. 由小到大（零扩展）

| 指令类      | 效果                     | 描述                                       | 指令                                                         |
| ----------- | ------------------------ | ------------------------------------------ | ------------------------------------------------------------ |
| $MOVZ\ S,R$ | $S(零扩展)\rightarrow R$ | 将 $S$ 进行零扩展之后传送到 $R$ 指示的位置 | `movzbw`（零扩展字节传送到字）<br />`movzbl`（零扩展字节传送到双字）<br />`movzwl`（零扩展字传送到双字）<br />`movzbq`（零扩展字节传送到四字）<br />`movzwq`（零扩展字传送到四字） |

**注意**：

- 指令的第一个后缀字母指示源的大小，第二个后缀字母指示目的的大小
- 若操作数是寄存器，其大小必须和指令指定的大小相同
- `movzbl`和`movzwl`两个指令除了将源进行零扩展之外，如果目的是一个寄存器，还会将该寄存器的高位 4 字节设置为 0
- 将双字零扩展传送到四字的指令可以通过`movl`实现，但是目的只能是寄存器



## 3. 由小到大（符号扩展）

| 指令类      | 效果                       | 描述                                         | 指令                                                         |
| ----------- | -------------------------- | -------------------------------------------- | ------------------------------------------------------------ |
| $MOVS\ S,R$ | $S(符号扩展)\rightarrow R$ | 将 $S$ 进行符号扩展之后传送到 $R$ 指示的位置 | `movsbw`（符号扩展字节传送到字）<br />`movsbl`（符号扩展字节传送到双字）<br />`movswl`（符号扩展字传送到双字）<br />`movsbq`（符号扩展字节传送到四字）<br />`movswq`（符号扩展字传送到四字）<br />`movslq`（符号扩展双字传送到四字）<br />`cltq`（将`%eax`寄存器符号扩展到`%rax`寄存器）<br />`cqto`（将`%rax`寄存器符号扩展到`%rdx:%rax`寄存器，即符号扩展四字到八字） |

**注意**：

- `movsbl`和`movswl`两个指令如果以寄存器为目的，则会将该寄存器的高位 4 字节设置为 0
- `cltq`指令没有操作数，其效果等价于`movslq %eax,%rax`
- `cqto`指令没有操作数，该指令将原本存在`%rax`寄存器中的内容用两个寄存器（`%rdx`和`%rax`）表示，`%rdx`保存高位 8 字节，`%rax`保存低位 8 字节



# 二. 栈操作

| 指令       | 效果                                                    | 描述                                                         |
| ---------- | ------------------------------------------------------- | ------------------------------------------------------------ |
| $pushq\ S$ | $R[\%rsp]=R[\%rsp]-8$；<br />$S\rightarrow M[R[\%rsp]]$ | 首先将`%rsp`寄存器中保存的地址向上移动一个四字的大小；<br />然后将 $S$ 传送到`%rsp`寄存器所保存的内存地址中 |
| $popq\ D$  | $M[R[\%rsp]]\rightarrow D$；<br />$R[\%rsp]=R[\%rsp]+8$ | 首先将`%rsp`寄存器中值作为地址找到的内存中的位置处取一个四字大小的数据到 $D$ 中；<br />然后将`%rsp`寄存器中保存的地址向下移动一个四字的大小 |

**注意**：

- `push`和`pop`操作都只有四字大小的
- 程序栈存放在内存中某个地址，栈指针`%rsp`保存着栈顶元素的地址
- 栈和程序代码以及其他形式的程序数据都放在同一内存中，所以程序可以用标准的内存寻址方法访问栈内的任意位置



# 三. 算术操作

## 1. 加载有效地址

| 指令        | 效果               | 描述                                     |
| ----------- | ------------------ | ---------------------------------------- |
| $leaq\ S,D$ | $\&S\rightarrow D$ | 将 $S$ 计算所得的值传送到 $D$ 指示的位置 |

**注意**：

- $S$ 应该形如一个内存访问表达式，但实际上并不引用内存，而是根据该表达式计算出一个值，然后将该值传送到指定位置中
- `leaq`为四字大小的指令，$D$ 必须是一个寄存器，且是一个四字大小的寄存器



## 2. 递增

| 指令类   | 效果    | 描述 | 指令                                                         |
| -------- | ------- | ---- | ------------------------------------------------------------ |
| $INC\ D$ | $D=D+1$ | 加 1 | `incb`（递增字节）<br />`incw`（递增字）<br />`incl`（递增双字）<br />`incq`（递增四字） |



## 3. 递减

| 指令类   | 效果    | 描述 | 指令                                                         |
| -------- | ------- | ---- | ------------------------------------------------------------ |
| $DEC\ D$ | $D=D-1$ | 减 1 | `decb`（递减字节）<br />`decw`（递减字）<br />`decl`（递减双字）<br />`decq`（递减四字） |



## 4. 取负

| 指令类   | 效果   | 描述 | 指令                                                         |
| -------- | ------ | ---- | ------------------------------------------------------------ |
| $NEG\ D$ | $D=-D$ | 取负 | `negb`（字节取负）<br />`negw`（字取负）<br />`negl`（双字取负）<br />`negq`（四字取负） |



## 5. 加

| 指令类     | 效果    | 描述 | 指令                                                         |
| ---------- | ------- | ---- | ------------------------------------------------------------ |
| $ADD\ S,D$ | $D=D+S$ | 加   | `addb`（字节加法）<br />`addw`（字加法）<br />`addl`（双字加法）<br />`addq`（四字加法） |

**注意**：

- 加法可能产生超过数据类型表示范围的结果，此结果将根据指令指定的大小进行截断



## 6. 减

| 指令类     | 效果    | 描述 | 指令                                                         |
| ---------- | ------- | ---- | ------------------------------------------------------------ |
| $SUB\ S,D$ | $D=D-S$ | 减   | `subb`（字节减法）<br />`subw`（字减法）<br />`subl`（双字减法）<br />`subq`（四字减法） |



## 7. 乘

| 指令类      | 效果          | 描述 | 指令                                                         |
| ----------- | ------------- | ---- | ------------------------------------------------------------ |
| $IMUL\ S,D$ | $D=D\times S$ | 乘   | `imulb`（字节乘法）<br />`imulw`（字乘法）<br />`imull`（双字乘法）<br />`imulq`（四字乘法） |

| 指令       | 效果                                 | 描述         |
| ---------- | ------------------------------------ | ------------ |
| $imulq\ S$ | $R[\%rdx]:R[\%rax]=S\times R[\%rax]$ | 有符号全乘法 |
| $mulq\ S$  | $R[\%rdx]:R[\%rax]=S\times R[\%rax]$ | 无符号全乘法 |

**注意**：

- 对于 $IMUL$ 类的双操作数的指令来说，如果乘法产生了超过数据类型表示范围的结果，将根据指令指定大小对结果进行截断
- 对于单操作数的`imulq`和`mulq`指令来说，乘法得到的结果将保存在两个寄存器中，其中`%rdx`寄存器保存结果的高位 8 字节，`%rax`寄存器保存结果的低位 8 字节
- 单操作数的`imulq`和`mulq`指令只需要一个操作数，乘法的另一个操作数保存在`%rax`寄存器中



## 8. 除

| 指令       | 效果                                                         | 描述                                                         |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| $idivq\ S$ | $R[\%rdx]=R[\%rdx]:R[\%rax]\ mod\ S$；<br />$R[\%rax]=R[\%rdx]:R[\%rax]\div S$ | 有符号除法，除法的商保存在`%rax`寄存器中，余数保存在`%rdx`寄存器中 |
| $divq\ S$  | $R[\%rdx]=R[\%rdx]:R[\%rax]\ mod\ S$；<br />$R[\%rax]=R[\%rdx]:R[\%rax]\div S$ | 无符号除法，除法的商保存在`%rax`寄存器中，余数保存在`%rdx`寄存器中 |

**注意**：

- 除法指令都只需要一个操作数作为除数，而以`%rdx:%rax`寄存器作为被除数。如果被除数只有 64 位，那么应该将`%rdx`设置为全 0（无符号运算）或者`%rax`的符号位（有符号运算，可以通过`cqto`指令进行设置）



# 四. 逻辑操作

## 1. 异或

| 指令类     | 效果        | 描述 | 指令                                                         |
| ---------- | ----------- | ---- | ------------------------------------------------------------ |
| $XOR\ S,D$ | $D=D$ ^ $S$ | 异或 | `xorb`（字节异或）<br />`xorw`（字异或）<br />`xorl`（双字异或）<br />`xorq`（四字异或） |



## 2. 或

| 指令类    | 效果             | 描述 | 指令                                                         |
| --------- | ---------------- | ---- | ------------------------------------------------------------ |
| $OR\ S,D$ | $D=D$ &#124; $S$ | 或   | `orb`（字节或）<br />`orw`（字或）<br />`orl`（双字或）<br />`orq`（四字或） |



## 3. 与

| 指令类     | 效果         | 描述 | 指令                                                         |
| ---------- | ------------ | ---- | ------------------------------------------------------------ |
| $AND\ S,D$ | $D=D\ \&\ S$ | 与   | `andb`（字节与）<br />`andw`（字与）<br />`andl`（双字与）<br />`andq`（四字与） |



# 五. 位操作

## 1. 取补

| 指令类   | 效果       | 描述 | 指令                                                         |
| -------- | ---------- | ---- | ------------------------------------------------------------ |
| $NOT\ D$ | $D=\sim D$ | 取补 | `notb`（字节取补）<br />`notw`（字取补）<br />`notl`（双字取补）<br />`notq`（四字取补） |



## 2. 左移

| 指令类     | 效果     | 描述 | 指令                                                         |
| ---------- | -------- | ---- | ------------------------------------------------------------ |
| $SAL\ k,D$ | $D=D<<k$ | 左移 | `salb`（字节左移）<br />`salw`（字左移）<br />`sall`（双字左移）<br />`salq`（四字左移） |

| 指令类     | 效果     | 描述                 | 指令                                                         |
| ---------- | -------- | -------------------- | ------------------------------------------------------------ |
| $SHL\ k,D$ | $D=D<<k$ | 左移（等同于 $SAL$） | `shlb`（字节左移）<br />`shlw`（字左移）<br />`shll`（双字左移）<br />`shlq`（四字左移） |



## 3. 右移

| 指令类     | 效果       | 描述     | 指令                                                         |
| ---------- | ---------- | -------- | ------------------------------------------------------------ |
| $SAR\ k,D$ | $D=D>>_Ak$ | 算术右移 | `sarb`（字节算术右移）<br />`sarw`（字算术右移）<br />`sarl`（双字算术右移）<br />`sarq`（四字算术右移） |

| 指令类     | 效果       | 描述     | 指令                                                         |
| ---------- | ---------- | -------- | ------------------------------------------------------------ |
| $SHR\ k,D$ | $D=D>>_Lk$ | 逻辑右移 | `shrb`（字节逻辑右移）<br />`shrw`（字逻辑右移）<br />`shrl`（双字逻辑右移）<br />`shrq`（四字逻辑右移） |



# 六. 控制操作

## 1. 设置条件码

| 指令类         | 效果      | 描述                                                | 指令                                                         |
| -------------- | --------- | --------------------------------------------------- | ------------------------------------------------------------ |
| $CMP\ S_1,S_2$ | $S_2-S_1$ | 通过 $S_2-S_1$ 的结果设置条件码，但不改变寄存器的值 | `cmpb`（比较字节）<br />`cmpw`（比较字）<br />`cmpl`（比较双字）<br />`cmpq`（比较四字） |

| 指令类          | 效果           | 描述                                                     | 指令                                                         |
| --------------- | -------------- | -------------------------------------------------------- | ------------------------------------------------------------ |
| $TEST\ S_1,S_2$ | $S_1\ \&\ S_2$ | 通过 $S_1\ \&\ S_2$ 值结果设置条件码，但不改变寄存器的值 | `testb`（测试字节）<br />`testw`（测试字）<br />`testl`（测试双字）<br />`testq`（测试四字） |

**注意**：

- $CMP$ 指令中操作数的大小关系应该是第二个操作数在前，第一个操作数在后，如根据条件码判断得出“大于”的关系，那么应该是 $S_2>S_1$
- $TEST$ 指令往往有两种典型用法：1. 两个操作数相同，用来判断操作数的正负性或是否为 0；2. 其中一个操作数是掩码，用来指示哪些位应该被测试


## 2. 根据条件设置字节

| 指令       | 同义名      | 效果                          | 描述                                                |
| ---------- | ----------- | ----------------------------- | --------------------------------------------------- |
| $sete\ D$  | $setz\ D$   | $D=ZF$                        | 若相等或为零设置 $D$ 为 1，否则设置为 0             |
| $setne\ D$ | $setnz\ D$  | $D=$ ~ $ZF$                   | 若不等或非零设置 $D$ 为 1，否则设置为 0             |
| $sets\ D$  | 无          | $D=SF$                        | 若为负数设置 $D$ 为 1，否则设置为 0                 |
| $setns\ D$ | 无          | $D=$ ~ $SF$                   | 若为非负数设置 $D$ 为 1，否则设置为 0               |
| $setg\ D$  | $setnle\ D$ | $D=$ ~ $(SF$ ^ $OF)$ & ~ $ZF$ | 若大于（有符号>）设置 $D$ 为 1，否则设置为 0        |
| $setge\ D$ | $setnl\ D$  | $D=$ ~ $(SF$ ^ $OF)$          | 若大于等于（有符号>=）设置 $D$ 为 1，否则设置为 0   |
| $setl\ D$  | $setnge\ D$ | $D=SF$ ^ $OF$                 | 若小于（有符号<）设置 $D$ 为 1，否则设置为 0        |
| $setle\ D$ | $setng\ D$  | $D=(SF$ ^ $OF)$ &#124; $ZF$   | 若小于等于（有符号<=）设置 $D$ 为 1，否则设置为 0   |
| $seta\ D$  | $setnbe\ D$ | $D=$ ~ $CF$ & ~ $ZF$          | 若超过（无符号>）设置 $D$ 为 1，否则设置为 0        |
| $setae\ D$ | $setnb\ D$  | $D=$ ~ $CF$                   | 若超过或相等（无符号>=）设置 $D$ 为 1，否则设置为 0 |
| $setb\ D$  | $setnae\ D$ | $D=CF$                        | 若低于（无符号<）设置 $D$ 为 1，否则设置为 0        |
| $setbe\ D$ | $setna\ D$  | $D=CF$ &#124; $ZF$            | 若低于或相等（无符号<=）设置 $D$ 为 1，否则设置为 0 |

**注意**：

- $SET$ 指令的目的操作数是低位单字节寄存器元素之一，或是一个字节的内存位置。为了得到一个更多位数的结果，我们必须对高位清零，可以使用 $MOVZ$ 指令
- 所有的算术和逻辑操作都会设置条件码，但是对于 $SET$ 指令来说，都适用的是 $CMP$ 指令



## 3. 根据条件跳转

| 指令            | 同义名        | 跳转条件                  | 描述                         |
| --------------- | ------------- | ------------------------- | ---------------------------- |
| $jmp\ Label$    |               | $1$                       | 直接跳转（不需要任何条件）   |
| $jmp\ *Operand$ |               | $1$                       | 间接跳转（不需要任何条件）   |
| $je\ Label$     | $jz\ Label$   | $ZF$                      | 相等或为零则跳转             |
| $jne\ Label$    | $jnz\ Label$  | ~ $ZF$                    | 不等或非零则跳转             |
| $js\ Label$     |               | $SF$                      | 为负数则跳转                 |
| $jns\ Label$    |               | ~ $SF$                    | 为非负数则跳转               |
| $jg\ Label$     | $jnle\ Label$ | ~ $(SF$ ^ $OF)$ & ~ $ZF$  | 大于（有符号>）则跳转        |
| $jge\ Label$    | $jnl\ Label$  | ~ $(SF$ ^ $OF)$           | 大于等于（有符号>=）则跳转   |
| $jl\ Label$     | $jnge\ Label$ | $SF$ ^ $OF$               | 小于（有符号<）则跳转        |
| $jle\ Label$    | $jng\ Label$  | $(SF$ ^ $OF)$ &#124; $ZF$ | 小于等于（有符号<=）则跳转   |
| $ja\ Label$     | $jnbe\ Label$ | ~ $CF$ & ~ $ZF$           | 超过（无符号>）则跳转        |
| $jae\ Label$    | $jnb\ Label$  | ~ $CF$                    | 超过或相等（无符号>=）则跳转 |
| $jb\ Label$     | $jnae\ Label$ | $CF$                      | 低于（无符号<）则跳转        |
| $jbe\ Label$    | $jna\ Label$  | $CF$ &#124; $ZF$          | 低于或相等（无符号<=）则跳转 |

**注意**：

- $Label$ 表示一个标签，用于标识程序中的某个位置，其格式通常为`.Label:`，其后跟着一条条指令
- 间接跳转中的跳转目标是`*`后的操作数，如`jmp *%rax`以`%rax`中的值为跳转目标，`jmp *(%rax)`以`%rax`中的值作为读地址，从内存中读出的值作为跳转目标



## 4. 根据条件传送数据

| 指令          | 同义名         | 传送条件                  | 描述                         |
| ------------- | -------------- | ------------------------- | ---------------------------- |
| $cmove\ S,R$  | $cmovz\ S,R$   | $ZF$                      | 相等或为零则传送             |
| $cmovne\ S,R$ | $cmovnz\ S,R$  | ~ $ZF$                    | 不等或非零则传送             |
| $cmovs\ S,R$  |                | $SF$                      | 为负则传送                   |
| $cmovns\ S,R$ |                | ~ $SF$                    | 非负则传送                   |
| $cmovg\ S,R$  | $cmovnle\ S,R$ | ~ $(SF$ ^ $OF)$ & ~ $ZF$  | 大于（有符号>）则传送        |
| $cmovge\ S,R$ | $cmovnl\ S,R$  | ~ $(SF$ ^ $OF)$           | 大于或等于（有符号>=）则传送 |
| $cmovl\ S,R$  | $cmovnge\ S,R$ | $SF$ ^ $OF$               | 小于（有符号<）则传送        |
| $cmovle\ S,R$ | $cmovng\ S,R$  | $(SF$ ^ $OF)$ &#124; $ZF$ | 小于或等于（有符号<=）则传送 |
| $cmova\ S,R$  | $cmovnbe\ S,R$ | ~ $CF$ & ~ $ZF$           | 超过（无符号>）则传送        |
| $cmovae\ S,R$ | $cmovnb\ S,R$  | ~ $CF$                    | 超过或相等（无符号>=）则传送 |
| $cmovb\ S,R$  | $cmovnae\ S,R$ | $CF$                      | 低于（无符号<）则传送        |
| $cmovbe\ S,R$ | $cmovna\ S,R$  | $CF$ &#124; $ZF$          | 低于或相等（无符号<=）则传送 |

**注意**：

- 源和目的的值可以是 16 位、32 位或 64 位长，不支持单字节的条件传送，两个操作数长度应该相同，汇编器可以通过目标寄存器的名字推断出条件传送指令的操作数长度



# 七. 过程

| 指令             | 描述             |
| ---------------- | ---------------- |
| $call\ Label$    | 过程调用（直接） |
| $call\ *Operand$ | 过程调用（间接） |
| $ret$            | 从过程调用中返回 |

**注意**：

- 运行时栈和程序指令所在的位置是不同的，运行时栈是程序运行时才进行分配，而程序指令应该在内存中是一块完整的，只包含指令的数据块。不要混淆，以为实际执行的指令插在运行时栈之间。`call` 和 `ret` 指令都只是将一个实际指令的地址进行压栈和弹栈
