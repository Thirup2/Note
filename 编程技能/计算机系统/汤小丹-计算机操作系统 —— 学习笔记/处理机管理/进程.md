# 一. 前趋图

**前趋图**（Precedence Graph）是一个有向无循环图，用来描述程序执行的先后顺序，可记为 DAG（Directed Acyclic Graph）。

该方法能够较好地描述并发程序实际执行的先后顺序。

图中的每个结点可用来表示一个进程或程序段，以至于一条语句，结点间的有向边则表示两个结点之间存在的**偏序**（Partial Order）或**前趋关系**（Precedence Relation）

进程（或程序）之间的前趋关系可用 “$\to$” 来表示，如果进程 $P_i$ 和 $P_j$ 存在着前趋关系，可表示为：$(P_i,P_j)\in\to$，也可写成 $P_i\to P_j$，表示在 $P_j$ 开始执行之前 $P_i$ 必须完成。此时称 $P_i$ 是 $P_j$ 的**直接前趋**，而 $P_j$ 是 $P_i$ 的**直接后继**。在前趋图中，把没有前趋的结点称为**初始结点**（Initial Node），把没有后继的结点成为**终止结点**（Final Node）。另外，每个结点还具有一个**权重**（Weight），用于表示该节点所含有的程序量或程序的执行时间。

例如一个前趋图如下所示：

![临时](https://user-images.githubusercontent.com/91216205/225223574-8869853f-cdec-4917-875b-bdf913b358ac.jpg)

则可以将其前趋关系表示如下：

$P_1\to P_2$，$P_1\to P_3$，$P_1\to P_4$，$P_2\to P_5$，$P_3\to P_5$，$P_4\to P_6$，$P_4\to P_7$，$P_5\to P_8$，$P_6\to P_8$，$P_7 \to P_9$，$P_8\to P_9$

另外，**前趋图中不允许有循环**，否则必然会产生不可能实现的前趋关系，如下图所示：

![临时 (1)](https://user-images.githubusercontent.com/91216205/225224255-1499ba25-874d-44a3-b67e-32563496e327.jpg)

它一方面要求在 $P3$ 开始执行之前，$P2$ 必须完成，另一方面又要求在 $P2$ 开始执行之前，$P3$ 必须完成。显然，这种关系是不可能实现的。



# 二. 程序执行

## 1. 顺序执行

**介绍**：

顺序执行的程序或语句形如下图：

![临时 (2)](https://user-images.githubusercontent.com/91216205/225225286-5224a33d-1400-40ca-9e31-9ce3b7430237.jpg)

**特征**：

1. 顺序性：指处理机严格地按照程序所规定的顺序执行，即每一操作必须在下一个操作开始之前结束
2. 封闭性：指程序在封闭的环境下运行，即程序运行时独占全机资源，资源的状态（除初始状态外）只有本程序才能改变它，程序一旦开始执行，其执行结果不受外界因素影响
3. 可再现性：指只要程序执行时的环境和初始条件相同，当程序重复执行时，不论它是从头到尾不停顿地执行，还是 “停停走走” 地执行，都可获得相同的结果。程序顺序执行时的这种特性，为程序员检测和校正程序的错误带来了很大的方便。



## 2. 并发执行

**介绍**：

程序顺序执行时，虽然可以给程序员带来便利，但系统资源的利用率却很低。为此，在系统中引入了多道程序技术，使程序或程序段间能并发执行。然而，并非所有的程序都能并发执行。事实上，**只有在不存在前趋关系的程序之间才有可能并发执行**，否则无法并发执行。

如下图所示，我们用 $I$ 表示运行一个输入程序，$C$ 表示运行一个计算程序，$P$ 表示运行一个打印程序，程序间的逻辑是：我们输入数据后，计算得到结果并打印出来：

![临时 (3)](https://user-images.githubusercontent.com/91216205/225228152-342b249a-ab1d-4d20-93fd-b54a51cde899.jpg)

该图所示的就是一个并发执行程序的例子，当输入程序 $I1$ 在输入第一次数据后，由计算程序 $C1$ 对该数据进行计算的同时，输入程序 $I2$ 可以再输入第二次数据，从而使第一个计算程序 $C1$ 可以与第二个输入程序 $I2$ 并发执行。

而之所以能够执行，是因为 $C1$ 和 $I2$ 之间并不存在前趋关系。与此相反，$C2$ 和 $C1$ 和 $I2$ 都具有前趋关系，所以 $C2$ 只能在 $C1$ 和 $I2$ 都执行结束之后才能执行。

**特征**：

1. 间断性：程序在并发执行时，由于它们共享系统资源，以及为完成同一项任务而相互合作，致使在这些并发执行的程序之间形成了相互制约的关系。
2. 失去封闭性：当系统中存在着多个可以并发执行的程序时，系统中的各种资源将为它们所共享，这些资源的状态也由这些程序来改变，致使其中任一程序在运行时，其环境都必然会受到其他程序的影响。
3. 不可再现性：由于程序的并发执行失去了封闭性，所以也就导致其失去了可再现性。



# 三. 进程

## 1. 定义和特征

### 定义

由于在多道程序环境下，程序的执行属于并发执行，此时它们将失去封闭性，并具有间断性，以及其运行结果不可再现性的特征。所以，一般的程序不能参与并发执行，否则，程序的运行也就失去了意义。为了能使程序并发执行，并且可以对并发执行的程序加以描述和控制，人们引入了 “进程” 的概念。

首先，为了使参与并发执行的每个程序（含数据）都能独立地运行，在操作系统中必须为之配置一个专门的数据结构，称为**进程控制块**（Process Control Block, PCB）。系统利用 PCB 来描述进程的基本情况和活动过程，进而控制和管理进程。另外，除了进程控制块之外，一个进程还包括原本就有的**程序段**和相关的**数据段**。

由程序段、相关的数据段和 PCB 三部分便构成了**进程实体**（又称进程映像），而**进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位**。一般情况下，我们把进程实体就简称为进程，例如，所谓创建进程，实质上是创建进程实体中的 PCB；而撤销进程，实质上是撤销进程的 PCB。

除了上面的定义外，从不同的角度对于进程可以有不同的定义，其中比较典型的有：

- 进程是程序的一次执行
- 进程是一个程序及其数据在处理机上顺序执行时所发生的活动
- 进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。



### 特征

首先需要分清进程和程序，这是两个截然不同的概念，除了进程具有程序所没有的 PCB 结构外，还具有下面一些特征：

1. 动态性：进程的实质是进程实体的执行过程，因此，动态性就是进程的最基本的特征。另外还表现在：“它由创建而产生，由调度而执行，由撤销而消亡。” 可见，进程实体有一定的生命期，而程序则只是一组有序指令的集合，并存放在某种介质上，其本身并不具有活动的含义，因而是静态的。
2. 并发行：是指多个进程实体同存于内存中，且能在一段时间内同时运行。对于没有建立 PCB 的程序来说，是不能参与并发执行的。
3. 独立性：在传统的 OS 中，独立性是指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位。凡未建立 PCB 的程序都不能作为一个独立的单位参与运行。
4. 异步性：是指程序是按异步方式运行，即按各自独立的、不可预知的速度向前推进。异步性导致了传统意义上的程序其结果的不可再现性，所以在 OS 中引进了进程的概念，并且配置相应的进程同步机制。



## 2. 基本状态及转换

### 进程的三种基本状态

一个进程在其生命周期内可能具有多种状态，一般而言，每一个进程至少应该处于以下三种基本状态之一：

1. **就绪**（Ready）状态。这是指程序已处于准备好运行的状态，即进程已分配到除 CPU 以外的所有必要资源后，只要再获得 CPU，便可立即执行。如果系统中有许多处于就绪状态的进程，通常将它们按一定的策略（如优先级策略）排成一个队列，称该队列为就绪队列。
2. **执行**（Running）状态。这是指进程已获得 CPU，其程序正在执行的状态。对任何一个时刻而言，在单处理机系统中，只有一个进程处于执行状态，而在多处理机系统中，则有多个进程处于执行状态。
3. **阻塞**（Block）状态。这是指正在执行的进程由于发生某件事（如 I/O 请求、申请缓冲区失败等）暂时无法继续执行时的状态，亦即进程的执行受到阻塞。此时引起进程调度，OS 把处理机分配给另一个就绪进程，而让受阻进程处于暂停状态，一般将这种暂停状态称为阻塞状态，有时也称为等待状态或封锁状态。通常系统将处于阻塞状态的进程也排成一个队列，称该队列为阻塞队列。实际上，在较大的系统中，为了减少队列操作的开销，提高系统效率，根据阻塞原因的不同，会设置多个阻塞队列。



### 三种基本状态的转换

进程的三种基本状态之间的转换基本如下图所示：
![临时](https://user-images.githubusercontent.com/91216205/225260841-fc7fa0e9-2d55-4a76-87bc-fda4a8d22c3a.jpg)

处于就绪状态的进程，在调度程序为之分配了处理机之后便可执行，相应地，其状态就由就绪态转变为执行态；

正在执行的进程（当前进程）如果因分配给它的时间片已完而被剥夺处理机暂停执行时，其状态便由执行转为就绪；

如果因发生某事件，致使当前进程的执行受阻（例如进程访问某临界资源，而该资源正被其他进程访问时），使之无法继续执行，则该进程状态将由执行转变为阻塞；

当导致阻塞进程阻塞的事件完成，则阻塞进程从阻塞队列进入就绪队列。



### 创建状态和终止状态

为了满足进程控制块对数据及操作的完整性要求以及增强管理的灵活性，通常在系统中又为进程引入了两种常见的状态：创建状态和种植状态。

- **创建状态**：进程是由创建而产生。创建一个进程一般要通过多个步骤才能完成：如首先由进程申请一个空白 PCB，并向 PCB 中填写用于控制和管理进程的信息；然后为该进程分配运行时所必需的资源；最后，把该进程转入就绪状态并插入就绪队列之中。

  如果进程所需的资源不能得到满足，如无足够的内存使进程无法装入其中，此时创建工作尚未完成，进程不能被调度运行，于是把此时进程所处的状态称为创建状态。

  引入创建状态是为了保证进程的调度必须在创建工作完成后进行，以确保对进程控制块操作的完整性。同时，创建状态的引入也增加了管理的灵活性，OS 可以根据系统性能或主存容量的限制推迟新进程的提交（创建状态）。对于处于创建状态的进程，当其获得了所需的资源以及对其 PCB 的初始化工作完成后，便可由创建状态转入就绪状态。

- **终止状态**：进程的终止也要通过两个步骤：首先，是等待操作系统进行善后处理，最后将其 PCB 清零，并将 PCB 空间返还系统。

  当一个进程到达了自然结束点，或时出现了无法克服的错误，或是被操作系统所终结，或是被其他有终止权的进程所终结，它将进入终止状态。

  进入终止态的进程以后不能再执行，但在操作系统中依然保留一个记录，其中保存状态码和一些计时统计数据，供其他进程收集。

  一旦其他进程完成了对其信息的提取之后，操作系统将删除该进程，即将 PCB 清零，并将该空白 PCB 返还系统。

加入了创建状态和终止状态的转换图如下所示：

![临时 (1)](https://user-images.githubusercontent.com/91216205/225266755-2e20340f-13c2-41c3-abc7-645fb09f92b3.jpg)



## 3. 挂起操作和进程状态的转换

### 挂起操作

为了系统和用户观察和分析进程的需要，还引入了一个对进程的重要操作——**挂起操作**。当该操作作用于某个进程时，该进程将被挂起，意味着此时该进程处于静止状态。如果进程正在执行，它将暂停执行。若原本处于就绪状态，则该进程此时暂不接受调度。与挂起操作对应的操作是**激活操作**。

**引入原因**：

1. 终端用户的需要。当终端用户在自己的程序运行期间发现有可疑问题，希望暂停自己程序的运行，使之停止下来，以便用户研究其执行情况或对程序进行修改。
2. 父进程请求。
3. 负荷调节的需要。
4. 操作系统的需要。



### 转换

**引入挂起操作后三个进程状态时的转换**：

![临时](https://user-images.githubusercontent.com/91216205/225897887-4ca3676a-21b9-4a05-8925-e8b115435f42.jpg)

1. 活动就绪 $\to$ 静止就绪。当进程处于未被挂起的就绪状态时，称此为**活动就绪**状态，表示为 Readya，此时进程可以接受调度。当用挂起操作将该进程挂起后，该进程便转变为**静止就绪**状态，表示为 Readys，处于 Readys 状态的进程不再被调度执行。
2. 活动阻塞 $\to$ 静止阻塞。当进程处于为被挂起的阻塞状态时，称它是处于**活动阻塞**状态，表示为 Blockeda。当用挂起操作将该进程挂起后，进程便转变为**静止阻塞**状态，表示为 Blockeds。处于该状态的进程在其所期待的事件出现后，它将从静止阻塞变为静止就绪 Readys 状态。
3. 静止就绪 $\to$ 活动就绪。处于 Readys 状态的进程若用激活操作激活后，该进程将转变为 Readya 状态。
4. 静止阻塞 $\to$ 活动阻塞。处于 Blockeds 状态的进程若用激活操作激活后，该进程将转变为 Blockeda 状态。



**引入挂起操作后五个进程状态时的转换**：

![临时 (1)](https://user-images.githubusercontent.com/91216205/225901717-eb3478c9-0ac2-474e-99b0-6361becb64fb.jpg)

与三种进程状态相比，除了上述的转换之外，还多了以下转换：

1. NULL $\to$ 创建：一个新进程产生时，该进程处于创建状态
2. 创建 $\to$ 活动就绪：在当前系统的性能和内存的容量均允许的情况下，完成对进程创建的必要操作后，相应的系统进程将进程的状态转换为活动就绪状态。
3. 创建 $\to$ 静止就绪：考虑到系统当前资源状况和性能的要求，不分配给新建进程所需资源，主要是主存，相应的系统将进程状态转为静止就绪状态，被安置在外存，不参与调度，此时**进程创建工作尚未完成**。
4. 执行 $\to$ 终止：当一个进程已完成任务时，或是出现了无法克服的错误，或是被 OS 或是被其他进程所终结，此时将进程的状态转换为终止状态
