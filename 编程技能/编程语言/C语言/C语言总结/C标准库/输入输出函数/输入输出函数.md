# ANSI I/O概念
## 一. 流
- 就C程序而言，所有的I/O操作只是简单地从程序移进或移出字节。这些字节流便被称为**流**。

  程序只需要关心创建正确的输出字节数据，以及正确地解释从输入读取的字节数据。特定I/O设备的细节对程序员是隐藏的。

- 绝大多数流是**完全缓冲**的，这意味着“读取”和“写入”实际上是从一块称为缓冲区的内存区域来回复制数据。

  从内存中来回复制数据是非常快速地。用于输出流的缓冲区只有被写满时才会**刷新**（flush，物理写入）到设备或文件中。把写满的缓冲区一次性写入相较于逐片把程序产生的输出分别写入，其效率更高。类似地，输入缓冲区为空时会通过从设备或文件读取下一块较大的输入，重新填充缓冲区

- 使用标准输入和输出时，这种缓冲可能会引起混淆。所以，只有当操作系统可以断定它们与交互设备并无联系时，才会进行完全缓冲。否则它们的缓冲状态将因编译器而异。

  一个常见的策略是把标准输出和标准输入联系在一起，当请求输入时同时刷新输出缓冲区。这样，在用户必须进行输入之前，提示用户进行输入的信息和以前写入到输出缓冲区中的内容将出现在屏幕上。

- 可以使用`fflush`输入或输出从缓冲区立刻刷新，不管它是否已满
1. 文本流

  文本流的有些特性在不同的系统中可能不同

   - 文本行的最大长度：标准规定至少允许254个字符。
   - 文本行的结束方式：在MS-DOS系统中，文本文件约定以一个回车符和一个换行符（或称为行反馈符）结尾。但是UNIX系统只使用一个换行符结尾

2. 二进制流

  二进制流中的字节将完全根据程序编写它们的形式写入到文件或设备中，而且完全根据它们从文件或设备读取的形式读入到程序中。它们并未做任何改变。这种类型的流适用于非文本数据。如果不希望I/O函数修改文本文件的行末字符，也可以把它用于文本文件。

## 二. 文件
- FILE是一个数据结构，声明在头文件`<stdio.h>`中。
  它用于访问一个流。如果同时激活了几个流，每个流都有一个相应的FILE与它关联。

  为了在流上执行一些操作，需要调用一些合适的函数，并向他们传递一个与这个流相关联的FILE参数。

- 对于每个ANSI C程序，运行时系统必须提供至少3个流：标准输入（stdin）、标准输出（stdout）和标准错误（stderr），它们都是一个指向FILE的指针。

- 标准输入时缺省情况下输入的来源，标准输出是缺省的输出设置。具体的缺省值因编译器而异，通常标准输入为键盘设备，标准输出为终端或屏幕。

- 许多操作系统允许用户在程序执行时修改缺省的标准输入和输出设备。例如，MS-DOS和UNIX系统都支持用下面这种方法进行输入/输出重定向：
    ```
    $ program < data > answer
    ```
    当执行这个程序时，它会将文件data作为标准输入进行读取，而且把标准输出写入到文件answer中。
    
- 当标准输出重定向到文件后，普通的输出内容就不再会显示到屏幕上。而标准错误如果重定向到其他地方，错误信息仍将出现在屏幕或其他缺省的输出设备上。

## 三. 标准I/O常量
- `<stdio.h>`中定义了数量众多的与输入和输出有关的常量。我们已经见过的EOF是许多函数的返回值，它提示到达了文件尾。EOF所选择的实际值比一个字符要多几位，这是为了避免二进制值被错误地解释为EOF
- 一个程序同时最多能打开的文件数量和编译器有关，但可以保证至少能同时打开`FOPEN_MAX`个文件。常量`FOPEN_MAX`包括了3个标准流，它的值至少是8
- 常量`FILENAME_MAX`是一个整型值，用于提示一个字符数组应该多大，以便容纳编译器所支持的最长合法文件名。如果对文件名的长度没有一个实际的限制，则这个常量的值就是文件名的推荐最大长度。