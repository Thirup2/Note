# 一. 头文件
`<stdlib.h>`

# 二. malloc
```c
void *malloc(size_t size);
```
- 操作: 从内存池中提取一块合适的内存, 并向该程序返回一个指向这块内存的指针.
- 参数: 需要分配的内存字节数
- 返回值: 如果内存池中的可用内存足够, `malloc`就返回一个指向被分配的内存块起始位置的指针; 如果内存池是空的, 或者它的可用内存无法满足请求, 在这种情况下, `malloc`函数向操作系统请求, 要求得到更多的内存, 并在这块新内存上执行分配任务. 如果操作系统无法向`malloc`提供更多的内存, `malloc`就返回一个NULL值.
- **注意**:
    1. 通过`malloc`分配的这块内存并没有以任何方式进行初始化. 如果对这块内存进行初始化非常重要, 要么自己动手对它进行初始化, 要么使用`calloc`函数
    2. `malloc`所分配的是一块连续的内存, 并不会分开位于两块或多块不同的内存. 
    3. `malloc`实际分配的内存有可能比请求的稍微多一点, 但是, 这个行为是由编译器定义的, 所以不能指望它肯定会分配比请求更多的内存

# 三. calloc
```c
void *calloc(size_t num_elements, size_t element_size);
```
- 操作: 从内存池中提取一段合适的内存, 并将其内容初始化为0
- 参数: 第一个参数是所需元素的数量, 第二个参数是每个元素的字节数, 函数根据这些值, 自行计算出总共需要分配的内存
- 返回值: 与`malloc`函数相同

# 四. realloc
```c
void *realloc(void *ptr, size_t new_size);
```
- 操作: 用于修改一个原先已经分配的内存块的大小. 使用这个函数, 可以使一块内存扩大或缩小. 如果它用于扩大一个内存块, 那么这块内存原先的内容依然保留, 新增加的内存添加到原先内存块的后面, 新内存并未以任何方法进行初始化. 如果它用于缩小一个新内存, 该内存块尾部的部分内存便被拿掉, 剩余部分内存的原先内容依然保留
- 参数: 第一个参数是一个已分配的内存块的指针, 第二个参数是新内存的字节数
- 返回值: 返回重分配之后的内存指针.
- **注意**:
    1. 如果原先的内存块无法改变大小, 如: 因为后面的内存已经被使用导致无法扩大. `realloc`将分配另一块正确大小的内存, 并把原先那块内存的内容复制到新的块上. 因此, 在使用`realloc`之后, 就不能再使用指向旧内存的指针, 而是应该改用`realloc`所返回的新指针
    2. 如果`realloc`函数的第一个参数是NULL, 那么它的行为就和`malloc`一模一样.

# 五. free
```c
void free(void *pointer);
```
- 操作: 释放先前从`malloc`, `calloc`或`realloc`分配的内存
- 参数: NULL或者先前从`malloc`, `calloc`或`realloc`返回的值. 向free传递一个NULL参数不会产生任何效果

# 六. 注意点
## 1. 内存类型
内存分配函数并不知道所请求的内存需要存储的是整数、浮点值、结构还是数组。它们都返回一个类型为`void*`的指针，标准表示一个`void*`类型的指针可以转换为其他任何类型的指针。但是，有些编译器，尤其是那些老式的编译器，可能要求在转换时使用强制类型转换
## 2. 内存位置
对于要求边界对齐的机器，内存分配函数所返回的内存的起始位置将始终能够满足对边界对齐要求最严格的类型的要求
