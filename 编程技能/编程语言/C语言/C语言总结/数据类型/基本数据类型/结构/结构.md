# 一. 结构基础
## 1. 创建结构
### 1) 声明
```c
struct tag {
    member-list
} variable-list;
```
- tag: 结构模型的名字(一定情况下可省略)
- member-list: 成员列表
- variable-list: 结构变量的名字, 在仅建立结构模型时, 可以省略
#### 注意
- 如果省略结构模型的名字, 那么两个内容相同的结构声明将被编译器当作两个不同的声明
```c
struct {
    int a;
    char b;
    float c;
} x;
```
```c
struct {
    int a;
    char b;
    float c;
} y[20], *z;
```
- `x`是一个结构变量, 包含3个成员: 一个整数, 一个字符和一个浮点数
- `y`是一个结构数组, 包含20个元素, 每个元素都是一个结构
- `z`是一个指向结构的指针
- `x`和`y`, `z`被编译器当作两种截然不同的类型, 所以`z=&x;`这条语句是非法的
#### 使用方法
- 通过tag赋予结构模型名称, 然后通过模型名称创建该类型
```c
struct SIMPLE {
    int a;
    char b;
    float c;
};
```
```c
struct SIMPLE x;
struct SIMPLE y[20], *z;
// 此时x, y, z是同一个类型创建的变量
```
- 通过`typedef`来定义新类型
```c
typedef struct {
    int a;
    char b;
    float c;
} Simple;
// 定义了Simple类型
// 然后用Simple类型创建变量
Simple x;
Simple y[20], *z;
```
### 2) 结构的自引用
#### 方法
在结构内部, 可以声明一个指向该结构类型的指针, 但不能声明该结构的变量, 如:
```c
struct SELF_REF1 {
    int a;
    struct SELF_REF1 b;
    int c;
};
```
- 这种类型的自引用是非法的.
```c
struct SELF_REF2 {
    int a;
    struct SELF_REF2 *b;
    int c;
};
```
- 这种类型的声明是合法的
#### 注意
```c
typedef struct {
    int a;
    SELF_REF3 *b;
    int c;
} SELF_REF3;
```
- 上述代码是错误的, 因为SELF_REF3这个类型到大括号后面才被创建, 在结构声明的内部时它尚未定义
- 改进方法如下:
```c
typedef struct TAG {
    int a;
    struct TAG *b;
    int c;
} SELF_REF3;
```

### 3) 不完整的声明
形式如下:
```c
struct tag;
```
- 当该结构还无法完成定义但接下来又必须用到该结构时如此声明, 如:
    ```c
    struct B;
    struct A {
        struct B *partner;
    };
    struct B {
        struct A *partner;
    };
    ```
    - 在A的成员列表中需要标签B的不完整声明. 一旦A被声明之后, B的成员列表才可以被声明
    - 相互之间存在依赖的结构中, 至少有一个结构必须在另一个结构内部以指针的形式存在

### 4) 初始化
与数组相似, 位于一对花括号内部, 由逗号分隔
这些值根据结构成员列表的顺序写出. 如果初始列表的值不够, 剩余的结构成员将使用缺省值进行初始化.
```c
typedef struct {
    int a;
    char b;
    float c;
} Simple;
struct INIT_EX {
    int a;
    short b[10];
    Simple c;
} x = {
    10,
    {1, 2, 3, 4, 5},
    {25, 'x', 1.9}
};
```
- `x`是一个结构, 包含三个成员, 成员一是一个整数, 成员二是一个短整型数组, 成员三是一个包含三个成员的结构.
- `x`紧跟的初始化列表对`x`进行了初始化
## 2. 结构成员
### 1) 成员类型
结构成员可以是标量, 数组, 指针甚至是其他结构.
```c
struct COMPLEX {
    float f;
    int a[20];
    long *lp;
    struct SIMPLE s;
    struct SIMPLE sa[10];
    struct SIMPLE *sp;
};
```
一个结构的成员可以和其他结构的成员的名字相同, 所以这个结构的成员a并不会与struct SIMPLE s中的成员a冲突.
### 2) 访问成员
#### 直接访问
通过点操作符(`.`)访问, 其接受两个操作数: 左操作数就是结构变量的名字; 右操作数就是需要访问的成员的名字. 这个表达式的结果就是指定的成员.
以上一节的声明为例:
```c
struct COMPLEX comp;
comp.f;    // 访问成员f
comp.a[3];    // 访问成员a的第4个元素
*comp.lp;    // 访问成员lp并对其进行解引用操作
comp.sa[5].a;    // 访问成员sa第6个元素中的成员a
```
#### 间接访问
如果有一个指向结构的指针, 可以先对其解引用然后再使用直接访问的方法, 或者通过间接访问操作符(`->`)访问, 其接受两个操作数: 左操作数是一个指向结构的指针; 右操作数就是需要访问的成员的名字. 这个表达式的结果就是指定的成员.
同样以上一节的声明为例:
```c
struct COMPLEX *pcomp;
pcomp = &comp;
pcomp->f;    // 访问pcomp指向的结构comp的成员f
pcomp->a[3];    // 访问comp的成员a的第4个元素
*(pcomp->lp);    // 访问comp的成员lp并对其进行解引用操作
pcomp->sa[5].a;    // 访问成员sa第6个元素中的成员a
```

# 二. 结构的内存分配
**当存储成员需要满足正确的边界对齐要求时, 成员之间可能出现用于填充的额外内存空间.**

假设有如下的一个结构:

```c
struct ALIGN {
    char a;
    int b;
    char c;
};
```
如果某个机器的整型值长度为4字节, 并且它的起始存储位置必须能够被4整除, 那么这一个结构的成员在内存中的位置应该如下:
- `a`从一个能被4整除的地址开始, 占据一个字节
- `b`由于`a`只占据了一个字节, 后续3个字节都无法被4整除, 所以`b`和`a`之间留了3个字节的空隙, 然后开始存储`b`, 一共占据4个字节
- `c`在`b`后面刚好是一个能被4整除的地址, 所以`c`紧靠着`b`存储, 占据1个字节
- 如果声明了相同类型的第2个变量, 它的起始存储位置也必须满足4这个边界, 所以第1个结构的后面还要再跳过3字节才能存储第2个结构. 因此, 每个结构将占据12字节的内存空间, 但实际只使用其中的六个. 可以通过对结构的成员列表重新排列, 来增加利用率:
    ```c
    struct ALIGN2 {
        int b;
        char a;
        char c;
    };
    ```
    - 这样, 一个结构变量只占用8字节的空间

# 三. 结构与函数
结构变量是一个标量, 可以用于其他标量可以使用的任何场合. 因此, 把结构作为参数传递给一个函数时合法的, 但其缺点也很明显:
1. 当不需要改变结构成员的值时, 可行, 但传入结构体大或者传入次数多时, 效率非常低
2. 当需要改变结构成员的值时, 不可行.

更快更好用的方法是: **声明一个指向待传递的结构的指针, 然后将指针传入到函数.**
需要注意两点:
1. 如果不需要修改结构成员的值, 可以使用`const`关键字来防止这类修改
2. 由于使用的是指针, 所以需要小心.

> - **K&R C**：在非常早期的K&R C编译器中，无法把结构作为参数传递给函数。后期的K&R C编译器允许传递结构参数。但是这些编译器都不支持const，所以防止程序修改结构参数的唯一办法就是向函数传递一份结构的拷贝。

# 四. 位段
- 使用场合：当一个`int`类型的长度对程序来说太大，可以将一个`int`拆分成几个位段存储不同的值
- 使用方法：位段成员必须声明为`int`、`signed int`或`unsigned int`类型。其次，在成员名的后面是一个冒号和一个整数，这个整数指定该位段所占用的位的数目
- 例：
    ```c
    struct CHAR {
        unsigned ch    : 7;
        unsigned font  : 6;
        unsigned size  :19;
    };
    struct CHAR ch1;
    ```
    - 原本需要声明32位的整数来保存size，但现在只需要19位保存size，而另外两个根据实际的需要都比声明两个char来分别保存节省空间
- **注意**：如果把位段声明为int类型，它究竟被解释为有符号数还是无符号数是由编译器决定的。