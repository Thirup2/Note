# 一. 隐式转换

## 1. 发生时机

- 在大多数表达式中，比`int`类型小的整型值首先提升为较大的整数类型
- 在条件中，非布尔值转换为布尔类型
- 初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型
- 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型
- 函数调用时也会发生类型转换

## 2. 算术转换

**算术转换**(arithmetic conversion)的含义是把一种算术类型转换成另一种算术类型。一个算术类型的类型转换包含以下步骤：

### 1）浮点型

对于包含浮点数的运算来说：首先将运算涉及的整型和`float`类型转换为`double`，若涉及到的对象含有`long double`，则再将`double`转换为`long double`。

### 2）整型

对于只有整数的运算，主要包括下面几步：

1. 整型提升
2. 类型同步

#### 整型提升

- `bool`、`char`、`signed char`、`unsigned char`、`short`和`unsigned short`转换为`int`，若`int`无法保存，则转换为`unsigned int`
- `bool`值提升之后的值为1(`true`)或0(`false`)
- `wchar_t`、`char16_t`和`char32_t`转换为`int`、`unsigned int`、`long`、`unsigned long`、`long long`和`unsigned long long`中能容纳其值的最小的一种类型

#### 类型同步

当运算涉及的运算对象整型提升之后，当前运算中涉及的对象的类型可能是：`int`、`unsigned int`、`long`、`unsigned long`、`long long`以及`unsigned long long`，它们将按照下面的规则进行同步：

- 如果两个类型匹配，则无需进行进一步的转换

- 如果两个运算对象的类型都是带符号的或无符号的，则小类型的运算对象转换为较大的类型

- 若两个运算对象的类型一个是带符号的，另一个是无符号的，而且其中的无符号类型不小于带符号类型，则带符号的运算对象转换为无符号类型并提升(如果需要的话)。

  **注意**：如果带符号类型的对象原本是负值将带来不好的影响

- 若两个运算对象的类型一个是带符号的，另一个是无符号的，而且其中的带符号类型不小于无符号类型，如果该无符号类型的值能够被该带符号类型容纳，则无符号类型提升(如果需要的话)然后转换为该带符号类型；如果该无符号类型的值不能被该带符号类型容纳，则该带符号类型转换为无符号类型，然后另一个对象提升至该类型。

  **注意**：如果带符号类型的对象原本是负值将带来不好的影响

## 3. 其他转换

### 1）数组转换为指针

在大多数时候，数组名会自动转换为指向数组首元素的指针。

以下是一些例外情况：

- 当数组被用作`decltype`关键字的参数时
- 当数组作为取地址符`&`的运算对象时
- 当数组作为`sizeof`运算符的运算对象时
- 当数组作为`typeid`运算符的运算对象时

### 2）指针的转换

- `0`、`nullptr`能转换为任意指针类型
- 指向任意非常量的指针能转换为`void *`
- 指向任意对象的指针能转换成`const void *`
- 在有继承关系的类型间还有另外一种指针转换的方式

### 3）转换成布尔类型

当某个地方需要一个布尔值时，算术类型或指针类型可以转换为布尔类型：

- 当算术类型或指针类型的值为0时，转换为`false`
- 当算术类型不为零或指针类型指向某个地址时，转换为`true`

### 4）转换成常量

可以将指向非常量类型的指针或引用转换为指向相应的常量类型的指针或引用，反之不行：

```c++
int i;
const int &j = i;
const int *p = &i;
int &r = j, *q = p;			// 错误
```

### 5）类类型定义的转换

类类型能定义由编译器自动执行的转换，编译器每次只能执行一种类类型的转换。

如：C风格字符串与`string`对象之间的转换，`cin`与布尔值之间的转换……



# 二. 显式转换

**显式转换**也叫强制类型转换(cast)，对一个对象进行显式转换有两种方式：

- 命名的强制类型转换，其格式如下：

  ```c++
  cast-name<type>(expression)
  ```

  - `cast-name`：被命名的类型转换方式，表示转换的方式
  - `type`：转换的目标类型
  - `expression`：要转换的值
  - **注意**：如果`type`是引用类型，则结果是左值。

- 旧式的强制类型转换，其格式如下：

  ```c++
  type (expr);		// 函数形式的强制类型转换
  (type) expr;		// C语言风格的强制类型转换
  ```

## 1. static_cast

只要对象不包含底层`const`，都可以使用`static_cast`，可以转换成任何具有明确定义的类型。

```c++
int i;
void *p = &i;

double slope = static_cast<double>(i) / 2;
int *ip = static_cast<int *>(p);
```

## 2. const_cast

`const_cast`只能用于去掉或者添加运算对象的底层`const`。

```c++
const char *pc;
char *p = const_cast<char *>(pc);
```

## 3. reinterpret_cast

`reinterpret_cast`可以将一个对象重新解释为另一个类型，但其保存的内容不会改变。

```c++
int *ip;
char *pc = reinterpret_cast<char *>(ip);		// 将ip重新解释为了一个指向字符的指针
											    // 可以使用pc来显示原来ip中每个字节转换为字符的效果
```

**注意**：该方法非常危险，因为将一种类型按另一种类型使用很有可能会导致程序的崩溃