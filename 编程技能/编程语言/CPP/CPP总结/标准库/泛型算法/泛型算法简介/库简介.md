# 一. 简介

顺序容器只定义了很少的操作：在多数情况下，我们可以添加和删除元素、访问首尾元素、确定容器是否为空以及获得指向首元素或尾元素之后位置的迭代器。

我们还希望容器能做其他很多有用的操作：查找特定元素、替换或删除一个特定值、重排元素顺序等。

标准库并未给每个容器都定义成员函数来实现这些操作，而是定义了一组**泛型算法**（generic algorithm）：它们实现了一些经典算法的公共接口，如排序和搜索；同时它们还可以用于不同类型的元素和多种容器类型。



# 二. 使用算法

大多数算法都定义在头文件`<algorithm>`中。标准库还在头文件`<numeric>`中定义了一组数值泛型算法。

一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。

通常情况下，算法遍历范围，对其中每个元素进行一些处理。

以`find`算法为例，它查找一个容器中指定范围内指定的值并返回指向该元素的迭代器，假设对一个`int`的`vector`进行该算法：

```c++
int val = 42;
auto result = find(vec.cbegin(), vec.cend(), val);
cout << "The value " << val
     << (result == vec.cend() ? " is not present" : " is present") << endl;
```

****

**find 算法的工作方式**：

1. 访问序列中的首元素
2. 比较此元素与我们要查找的值
3. 如果此元素与我们要查找的值匹配，`find`返回标识此元素的值
4. 否则，`find`前进到下一个元素，重复执行步骤 2 和 3
5. 如果到达序列尾，`find`应停止
6. 如果`find`到达序列末尾，它应该返回一个指出元素未找到的值。此值和步骤 3 返回的值必须具有相容的类型

****

通过使用迭代器，这些算法几乎都不依赖于容器，但是算法会依赖于元素类型的操作，如`==`运算符和`<`运算符，大多数算法提供了一种方法，允许我们使用自定义的操作来替代默认的运算符。



# 三. 算法的特殊性

泛型算法本身不会执行容器的操作，它们是建立在迭代器之上的，执行迭代器的操作。

对于普通的迭代器而言，我们可以得到一个编程假定：算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素。

但标准库还定义了一类特殊的迭代器，称为**插入器**（inserter），与普通迭代器相比，插入器能做更多的事情。当给这类迭代器赋值时，它们会在底层的容器上执行插入操作。因此，当一个算法操作一个这样的迭代器时，迭代器可以完成向容器添加元素的效果。

但需要记住的是，算法永远是基于迭代器的，只会使用迭代器的操作。