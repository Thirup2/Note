# 一. 简介

很多算法都会比较输入序列中的元素。默认情况下，这类算法使用元素类型的`<`或`==`运算符来完成比较。标准库还为这些算法定义了额外的版本，允许我们提供自己定义的操作来代替默认运算符。

例如，`sort`算法默认使用元素类型的`<`运算符。但可能我们希望的排序顺序与`<`所定义的顺序不同，或是我们的序列可能保存的是未定义`<`运算符的元素类型（如`Sales_data`）。在这两种情况下，都需要重载`sort`的默认行为。



# 二. 谓词

`sort`的一个重载版本接受三个参数，第三个参数就是一个**谓词**（predicate）。

谓词是一个可调用的表达式，其返回结果是一个能用作条件的值。标准库算法所使用的谓词分为两类：**一元谓词**（unary predicate，意味着它们只接受单一参数）和**二元谓词**（binary predicate，意味着它们有两个参数）。

接受谓词参数的算法对输入序列中的元素调用谓词。因此，元素类型必须能转换为谓词的参数类型。

接受一个二元谓词参数的`sort`版本用这个谓词来代替`<`来比较元素。我们提供给`sort`的谓词必须满足一些条件。

此操作必须在输入序列中所有可能的元素值上定义一个一致的序。



# 三. 示例

首先定义一个函数作为后面需要的谓词：

```c++
bool isShorter(const string &s1, const string &s2)
{
    return s1.size() < s2.size();
}
```

这个函数按照字符串长度进行排序。

接下来传入接受三个参数的`sort`函数进行排序：

```c++
sort(words.begin(), words.end(), isShorter);
```

该调用将按照长度大小从小到大进行排序。

但由于`sort`排序是不稳定排序，不保证排序之后相等元素的相对位置。如果需要保证这个相对位置，可以使用`stable_sort`。

例如当我们首先需要其按照长度大小排序，在这基础上再按照字典序进行排序，那么我们就可以使用`stable_sort`，但首先我们需要保证传入的序列是已经按照字典序排列好的：

```c++
stable_sort(words.begin(), words.end(), isShorter);
```

我们首先需要保证传入的`words`序列是按照字典序排列好的，然后才能得到我们想要的结果。