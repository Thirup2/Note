# 一. 简介

`new`和`delete`运算符一次分配/释放一个对象，但某些应用需要一次为很多对象分配内存的功能。

为了支持这种需求，C++ 语言和标准库提供了两种一次分配一个对象数组的方法。其一就是 C++ 定义了另一种`new`表达式语法，可以分配并初始化一个对象数组。

需要注意的是，在有了标准容器库之后，大多数应用都应该使用标准库容器而不是动态分配的数组。因为使用容器更为简单、更不容易出现内存管理错误并且可能有更好的性能。



# 二. new 和数组

使用`new`表达式动态分配一个数组的语法如下所示：

```c++
int *pia = new int[get_size()];
```

其中`pia`指向动态分配的数组的第一个`int`。

与内置数组不同的是`[]`中的大小可以不是一个常量。

在上例中，`new`执行的操作是分配一个`int`数组，并返回指向第一个`int`的指针。

****

**注意**：

事实上，动态分配的数组**并非一个数组类型的对象**，而是一个数组元素类型的指针。

由于这一点，我们不能对动态数组调用`begin`或`end`，以及不能使用范围`for`语句来处理动态数组中的元素。

****

**初始化**：

- **默认初始化**：默认情况下，`new`分配的对象，不管是单个分配的还是数组中的，都是默认初始化的。

- **值初始化**：可以对数组的元素进行值初始化，方法是在大小之后跟一对空括号：

  ```c++
  int *pia = new int[10]();
  string *psa = new string[10]();
  ```

- **列表初始化**：和列表初始化一个内置数组一样：

  ```c++
  int *pia = new int[10]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  string *psa = new string[10]{"a", "an", "the", string(3, 'x')};
  ```

  与内置数组对象的列表初始化一样，初始化器会用来初始化动态数组中开始部分的元素。如果初始化器数组小于元素数目，剩余元素将进行值初始化。如果初始化器数目大于元素数目，则`new`表达式失败，不会分配任何内存。

****

**动态分配一个空数组**：

我们不能创建一个大小为 0 的静态数组对象，但是可以创建一个大小为 0 的动态数组。

当我们使用`new`分配一个大小为 0 的数组时，`new`返回一个合法的非空指针。此指针保证与`new`返回的其他任何指针都不相同。对于零长度的数组来说，此指针就像尾后指针一样，我们可以像使用尾后迭代器一样使用这个指针。可以用此指针进行比较操作、可以向此指针加上（或从此指针减去）0，也可以从此指针减去自身得到 0。但此指针不能解引用。



# 三. 释放动态数组

和分配数组的`new`一样，释放数组的`delete`也和普通的`delete`表达式不一样，具体语法如下：

```c++
delete[] pa;
```

该语句销毁`pa`指向的数组中的元素，并释放对应的内存。数组中的元素按逆序销毁，即最后一个元素首先被销毁，然后是倒数第二个，依次类推。

当我们释放一个指向数组的指针时，空括号对是必需的：它指示编译器指向一个数组对象的第一个元素。



# 四. 智能指针和动态数组

## 1. unique_ptr

标准库提供了一个可以管理`new`分配的数组的`unique_ptr`版本。为了用一个`unique_ptr`管理动态数组，我们必须在对象类型的后面跟一对方括号：

```c++
unique_ptr<int[]> up(new int[10]);
```

`up`指向一个包含 10 个未初始化`int`的数组。

当`up`调用析构函数时，会自动使用`delete[]`。

****

**操作**：

- 指向数组的`unique_ptr`不支持成员访问运算符

- 其他`unique_ptr`操作不变

- 新增的`unique_ptr`操作：

  | 操作                   | 描述                                                         |
  | ---------------------- | ------------------------------------------------------------ |
  | `unique_ptr<T[]> u`    | `u`可以指向一个动态分配的数组，数组元素类型为`T`             |
  | `unique_ptr<T[]> u(p)` | `u`指向内置指针`p`所指向的动态分配的数组。<br />`p`必须能转换为类型`T*` |
  | `u[i]`                 | 返回`u`拥有的数组中位置`i`处的对象<br />`u`必须指向一个数组  |



## 2. shared_ptr

与`unique_ptr`不同，`shared_ptr`不直接支持管理动态数组。如果希望使用`shared_ptr`管理一个动态数组，必须提供自己定义的删除器：

```c++
shared_ptr<int> sp(new int[10], [](int *p) { delete[] p; });
```

本例中我们传递给`shared_ptr`一个`lambda`作为删除器，它使用`delete[]`释放数组。

如果未提供删除器，这段代码将是未定义的。默认情况下，`shared_ptr`使用`delete`销毁它指向的对象。如果此对象是一个动态数组，对其使用`delete`所产生的问题与释放一个动态数组指针时忘记`[]`产生的问题一样。

另外，`shared_ptr`由于不支持动态数组管理，所以也没有提供基于`shared_ptr`的直接下标访问操作，而**必须使用`get`获取一个内置指针**，然后用它来访问数组。