# 一. 简介

我们知道`shared_ptr`的原理是创建一个控制块，用控制块控制指向的对象。实际上，这个控制块和被指对象一样都是动态分配的内存，在多数情况下，它们是同时被释放的，但这并不完全绝对，事实上，控制块和被指对象完全可以在不同的时间点被释放。

为了理解`weak_ptr`，我们可以想象一下：在`shared_ptr`的部分，我们说它用一个引用计数控制对象的生存，而其实除了引用计数之外，还有一个计数器，用来保存指向控制块的指针个数。这二者的关系大概是，引用计数保存所有指向控制块的`shared_ptr`个数，而另一个计数器用来保存所有指向控制块的`shared_ptr`和`weak_ptr`的个数，也就是说，第二个计数器减去引用计数就是指向控制块的`weak_ptr`个数。

那么`weak_ptr`有什么用呢？`weak_ptr`是一种不控制所指向对象生存期的智能指针，它指向由一个`shared_ptr`管理的对象。将一个`weak_ptr`绑定到一个`shared_ptr`不会改变`shared_ptr`的引用计数。一旦最后一个指向对象的`shared_ptr`被销毁，对象就会被释放。即使有`weak_ptr`指向对象，对象也还是会被释放。而当所有指向对象的`weak_ptr`都被销毁时，被观察的控制块才会被销毁。

所以`weak_ptr`事实上只起到一个观察的作用，当真正用来管理对象的智能指针被销毁后，对象被释放；而所有用来观察对象的智能指针被销毁后，控制块被释放。



# 二. 操作

| 操作                | 描述                                                         |
| ------------------- | ------------------------------------------------------------ |
| `weak_ptr<T> w`     | 空`weak_ptr`可以指向类型为`T`的对象                          |
| `weak_ptr<T> w(sp)` | 与`shared_ptr sp`指向相同对象的`weak_ptr`。<br />`T`必须能转换为`sp`指向的类型 |
| `w = p`             | `p`可以是一个`shared_ptr`或一个`weak_ptr`。<br />赋值后`w`与`p`共享对象 |
| `w.reset()`         | 将`w`置空                                                    |
| `w.use_count()`     | 与`w`共享对象的`shared_ptr`数量                              |
| `w.expired()`       | 若`w.use_count()`为 0，返回`true`，否则返回`false`           |
| `w.lock()`          | 如果`expired`为`true`，返回一个空`shared_ptr`；<br />否则返回一个指向`w`的对象的`shared_ptr` |

## 1. 构造

当我们创建一个`weak_ptr`时，要用一个`shared_ptr`来初始化它：

```c++
auto p = make_shared<int>(42);
weak_ptr<int> wp(p);
```

本例中`wp`和`p`指向相同的对象。由于是弱共享，创建`wp`不会改变`p`的引用计数；`wp`指向的对象可能被释放掉。



## 2. lock 函数

由于对象可能不存在，我们不能使用`weak_ptr`直接访问对象，而必须调用`lock`。

此函数检查`weak_ptr`指向的对象是否仍存在。如果存在，`lock`返回一个指向共享对象的`shared_ptr`。与任何其他`shared_ptr`类似，只要此`shared_ptr`存在，它所指向的底层对象也就会一直存在。

可以理解为`lock`在函数内创建一个`shared_ptr`，如果对象存在，则用指向该对象的控制块初始化这个`shared_ptr`（因为`weak_ptr`本身指向控制块），并使引用计数加 1，然后返回，交给或不交给另一个`shared_ptr`，销毁函数内创建的`shared_ptr`对象。

