# 一. 分配和初始化

在自由空间分配的内存是无名的，因此`new`无法为其分配的对象命名，而是返回一个指向该对象的指针：

```c++
int *pi = new int;
```

此`new`表达式在自由空间构造一个`int`型对象，并返回指向该对象的指针。

****

**初始化**：

默认情况下，动态分配的对象是**默认初始化**的，这意味着内置类型或组合类型的对象的值将是未定义的，而类类型对象将用默认构造函数进行初始化：

```c++
string *ps = new string;			// 初始化为空 string
int *pi = new int;				// pi 指向一个未初始化的 int
```

我们可以使用**直接初始化**方式来初始化一个动态分配的对象，允许的初始化器有圆括号初始化器`()`和花括号初始化器`{}`：

```c++
int *pi = new int(1024);
string *ps = new string(10, '9');
vector<int> *pv = new vector<int>{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
```

也可以对动态分配的对象进行**值初始化**，只需在类型名之后跟一对空括号即可：

```c++
string *ps = new string();
int *pi = new int();
```

对于定义了自己的构造函数的类类型来说，要求值初始化是没有意义的；不管采用什么方式，对象都会通过默认构造函数来初始化。但对于内置类型，两种形式的差别就很大了。

另外，如果我们提供了一个括号包围的初始化器，就可以使用`auto`从此初始化器来推断我们想要分配的对象的类型。但是由于编译器要用初始化器的类型来推断要分配的类型，只有当括号中仅有单一初始化器时才可以使用`auto`：

```c++
auto p1 = new auto(obj);		// p 指向一个与 obj 类型相同的对象，该对象用 obj 进行初始化
auto p2 = new auto{a, b, c};		// 错误：括号中只能有单个初始化器
```

****

**分配 const 对象**：

用`new`分配`const`对象是合法的：

```c++
const int *pci = new const int(1024);
const string *pcs = new const string;
```

类似于其他任何`const`对象，一个动态分配的`const`对象必须进行初始化。对于一个定义了默认构造函数的类类型，其`const`动态对象可以隐式初始化，而其他类型的对象就必须显式初始化。由于分配的对象是`const`的，`new`返回的指针是一个指向`const`的指针。

****

**内存耗尽**：

一旦一个程序用光了它所有可用的内存，`new`表达式就会失败。默认情况下，如果`new`不能分配所要求的内存空间，它会抛出一个`bad_alloc`的异常。我们可以改变使用`new`的方式来阻止它抛出异常：

```c++
int *p1 = new int;		// 如果分配失败，new 抛出 std::bad_alloc
int *p2 = new (nothrow) int;	// 如果分配失败，new 返回一个空指针
```

我们称这种形式的`new`为**定位 new**（placement new）。定位`new`表达式允许我们传递额外的参数。在此例中，我们传递给它一个由标准库定义的名为`nothrow`的对象。如果将`nothrow`传递给`new`，我们的意图是告诉它不能抛出异常。如果这种形式的`new`不能分配所需内存，它会返回一个空指针。`bad_alloc`和`nothrow`都定义在头文件`new`中



# 二. 释放内存

为了防止内存耗尽，在动态内存使用完毕后，必须将其归还给系统。我们通过 **delete 表达式**来将动态内存归还给系统。

`delete`表达式接受一个指针，只像我们想要释放的对象：

```c++
delete p;
```

与`new`类型类似，`delete`表达式也执行两个动作：销毁给定的指针指向的对象；释放对应的内存。

****

**传递的指针值**：

我们传递给`delete`的指针**必须指向动态分配的内存或一个空指针**。释放一块并非`new`分配的内存，或者将相同的指针值释放多次，其行为是未定义的：

****

**动态对象的生存期**：

由`shared_ptr`管理的内存在最后一个`shared_ptr`销毁时会被自动释放。但对于通过内置指针类型来管理的内存，就不是这样了。对于一个内置指针管理的动态对象，直到被显式释放之前它都是存在的。

返回指向动态内存的指针的函数给其调用者添加了一个额外负担——调用者必须记得释放内存，但不幸的是，调用者经常忘记释放对象。



# 三. 常见错误

使用`new`和`delete`管理动态内存存在三个常见问题：

1. 忘记`delete`内存。可能导致内存泄漏的问题，因为这种内存永远不可能被归还给自由空间了。
2. 使用已经释放掉的对象。通过在释放内存后将指针置为空，有时可以检测出这种错误。
3. 同一块内存释放两次。当有两个指针指向相同的动态分配对象时，可能发生这种错误。如果对其中一个指针进行了`delete`操作，对象的内存就被归还给自由空间了。如果我们随后又`delete`第二个指针，自由空间就可能被破坏。

