# 一. 简介

一个使用了动态分配内存的程序需要确保在异常发生后资源能够被正确地释。

一个简单的确保资源被释放的方法是使用智能指针，这个方法在程序正常运行的时候非常有用。并且在遭遇异常时，如果程序块过早结束，智能指针类也能确保在内存不再需要时将其释放（因为如果遇到异常中断退出，那么所有非动态分配的对象都会被销毁，在销毁智能指针时会执行其析构函数，可以控制动态分配的内存的释放）。

而如果我们使用的是直接管理的动态内存。如果在`new`之后`delete`之前程序发生异常中断退出，那么此时动态内存将不会被释放。此时我们就需要使用到异常管理。



# 二. 哑类

**哑类**即没有任何数据成员也没有虚函数的类，自然也就不包括析构函数。

包括所有标准库类在内的很多 C++ 类都定义了析构函数，负责清理对象使用的资源。但是，不是所有的类都是这样良好定义的。特别是那些为 C 和 C++ 两种语言设计的类，通常都要求用户显式地释放所使用的任何资源。

那些分配了资源，而又没有定义析构函数来释放这些资源的类，可能会遇到与使用动态内存相同的错误——程序员非常容易忘记释放资源。类似的，如果在资源分配和释放之间发生了异常，程序也会发生资源泄漏。

与管理动态内存类似，我们通常可以使用类似的技术来管理不具有良好定义的析构函数的类。例如，假定我们正在使用一个 C 和 C++ 都使用的网络库，使用这个库的代码可能是这样的：

```c++
struct destination;
struct connection;
connection connect(destination*);
void disconnect(connection);
void f(destination &d /* 其他参数 */)
{
    // 获得一个连接，记住使用完之后要关闭它
    connection c = connect(&d);
    // 使用连接
    // 如果我们在 f 退出之前忘记调用 disconnect，就无法关闭 c 了
}
```

如果`connection`有一个析构函数，就可以在`f`结束时由析构函数自动关闭连接。但是，`connection`没有析构函数。为了应对这种情况，我们仍然可以使用`shared_ptr`来保证`connection`被正确关闭，方法参考下一节。



# 三. 使用我们自己的释放操作

默认情况下，`shared_ptr`假定它们指向的是动态内存。因此，当一个`shared_ptr`被销毁时，它默认地对它管理的指针进行`delete`操作。为了用`shared_ptr`来管理一个`connection`，我们必须首先定义一个函数来代替`delete`。这个**删除器**（deleter）函数必须能够完成对`shared_ptr`中保存的指针进行释放的操作。在本例中，我们的删除器必须接受单个类型为`connection*`的参数：

```c++
void end_connection(connection *p) { disconnect(*p); }
```

当我们创建一个`shared_ptr`时，可以传递一个（可选的）指向删除器函数的参数：

```c++
void f(destination &d /* 其他参数 */)
{
    connection c = connect(&d);
    shared_ptr<connection> p(&c, end_connection);
    // 使用连接
    // 当 f 退出时（即使是由于异常而退出），connection 会被正常关闭
}
```

当`p`被销毁时，它不会对自己保存的指针执行`delete`，而是调用`end_connection`。接下来，`end_connection`会调用`disconnect`，从而确保连接被关闭。