# 一. 容器类型成员

| 类型                     | 描述                                                   |
| ------------------------ | ------------------------------------------------------ |
| `iterator`               | 此容器类型的迭代器类型                                 |
| `const_iterator`         | 可以读取元素，但不能修改元素的迭代器类型               |
| `size_type`              | 无符号整数类型，足够保存此种容器类型最大可能容器的大小 |
| `difference_type`        | 带符号整数类型，足够保存两个迭代器之间的距离           |
| `value_type`             | 元素类型                                               |
| `reference`              | 元素的左值类型；与`value_type &`含义相同               |
| `const_reference`        | 元素的`const`左值类型（即`const value_type &`）        |
| `reverse_iterator`       | 按逆序寻址元素的迭代器**（`forward_list`除外）**       |
| `const_reverse_iterator` | 不能修改元素的逆序迭代器**（`forward_list`除外）**     |



# 二. 构造函数

`C`表示一个实例化的容器类型

| 操作                                            | 描述                                                         |
| ----------------------------------------------- | ------------------------------------------------------------ |
| `C c`                                           | 默认构造函数，构造空容器。**（`array`除外）**                |
| `C c1(c2)`<br />`C c1 = c2`                     | 构造`c2`的拷贝`c1`。<br />**（对于`array`类型，两者必须具有相同大小）** |
| `C c(b, e)`                                     | 构造`c`，将迭代器`b`和`e`指定的范围内的元素拷贝到`c`**（`array`除外）** |
| `C c{a, b, c, ...}`<br />`C c = {a, b, c, ...}` | 列表初始化`c`。<br />**（对于`array`类型，列表中元素数目必须小于等于`array`的大小；如果小于，则遗漏的元素值初始化）** |
| `C seq(n)`                                      | `seq`包含`n`个元素，这些元素进行了值初始化；此构造函数是`explicit`的<br />**（`string`、`array`不适用）** |
| `C seq(n, t)`                                   | `seq`包含`n`个初始值为值`t`的元素**（`array`不适用）**       |

****

**注**：

- 拷贝有两种方式：直接拷贝整个容器或传递迭代器范围。其中：

  - 直接拷贝整个容器时，两个容器的类型及其元素类型必须匹配。
  - 当传递迭代器范围时，不要求容器类型相同，且元素类型也可以不同，但需要被拷贝的元素能转换为目标容器的元素类型

- 列表初始化同时指定了容器的大小（除`array`外）以及每个元素的值

- 标准库`array`具有固定大小，`array`类模板在实例化时就必须提供容器的大小：

  ```c++
  array<int, 42>			// 保存 42 个 int 的数组
  array<string, 10>		// 保存 10 个 string 的数组
  ```
  
  且在后续使用的时候，也必须加上容器的大小才是能表示数组的类型，如：
  
  ```c++
  array<int, 42>::size_type i;
  ```
  
- 另外，一个默认构造的`array`，其元素初始值为默认初始化的而不是值初始化的。如果元素是一个类类型，那么该类必须有一个默认构造函数。



# 三. 赋值与swap

| 操作                  | 描述                                                         |
| --------------------- | ------------------------------------------------------------ |
| `c1 = c2`             | 将`c1`中的元素替换为`c2`中元素。`c1`和`c2`必须具有相同的类型（注意`array`的类型包括大小） |
| `c1 = {a, b, c, ...}` | 将`c1`中的元素替换为列表中元素**（`array`除外）**            |
| `c1.swap(c2)`         | 交换`c1`和`c2`的元素                                         |
| `swap(c1, c2)`        | 与`c1.swap(c2)`等价                                          |
| `seq.assign(b, e)`    | 将`seq`中的元素替换为迭代器`b`、`e`范围中的元素。<br />迭代器`b`和`e`不能指向`seq`中的元素**（`array`除外）** |
| `seq.assign(i1)`      | 将`seq`中的元素替换为初始值列表`il`中的元素**（`array`除外）** |
| `seq.assign(n, t)`    | 将`seq`中的元素替换为`n`个值为`t`的元素**（`array`除外）**   |

****

**注**：

`swap`操作用于交换两个容器的所有内容，被交换的两个容器类型必须相同。

另外，除了`array`外，在其他容器上的`swap`操作不对任何元素进行拷贝、删除或插入操作，可以保证在常数时间内完成。

同时，之前指向容器的迭代器并不会失效，但是在交换之后，应该指向了不同的容器，`string`除外。



# 四. 大小

| 操作           | 描述                                           |
| -------------- | ---------------------------------------------- |
| `c.size()`     | `c`中元素的数目**（`forward_list`除外）**      |
| `c.max_size()` | `c`可保存的最大元素数目                        |
| `c.empty()`    | 若`c`中存储了元素，返回`false`，否则返回`true` |



# 五. 添加/删除元素

**以下操作都不适用于`array`**；另外，在不同容器中，这些操作的接口都不同

| 操作                                           | 描述                                                         |
| ---------------------------------------------- | ------------------------------------------------------------ |
| `c.insert(args)`                               | 将`args`中的元素拷贝进`c`                                    |
| `c.emplace(inits)`                             | 使用`inits`构造`c`中的一个元素                               |
| `c.erase(args)`                                | 删除`args`指定的元素                                         |
| `c.clear()`                                    | 删除`c`中的所有元素，返回`void`                              |
| `c.push_back(t)`<br />`c.emplace_back(args)`   | 在`c`的尾部创建一个值为`t`或由`args`创建的元素。返回`void`**（`forward_list`不支持）** |
| `c.push_front(t)`<br />`c.emplace_front(args)` | 在`c`的头部创建一个值为`t`或由`args`创建的元素。返回`void`**（`vector`、`string`不支持）** |
| `c.insert(p, t)`<br />`c.emplace(p, args)`     | 在迭代器`p`指向的元素之前创建一个值为`t`或由`args`创建的元素。返回指向新添加的元素的迭代器<br />**（`forward_list`有自己专有版本的`insert`和`emplace`）** |
| `c.insert(p, n, t)`                            | 在迭代器指向的元素之前插入`n`个值为`t`的元素。返回指向新添加的第一个元素的迭代器；若`n`为 0，则返回`p` |
| `c.insert(p, b, e)`                            | 将迭代器`b`和`e`指定的范围内的元素插入到迭代器`p`指向的元素之前。`b`和`e`不能指向`c`中的元素。<br />返回指向新添加的第一个元素的迭代器；若范围为空，返回`p` |
| `c.insert(p, il)`                              | `il`是一个花括号包围的元素值列表。将这些给定值插入到迭代器`p`指向的元素之前。<br />返回指向新添加的第一个元素的迭代器；若列表为空，则返回`p` |

****

**注**：

- 向一个`vector`、`string`或`deque`插入元素会使所有指向容器的迭代器、引用和指针失效

- `emplace`系列的函数是在容器的某个位置直接根据参数和元素的构造函数构造一个元素的对象，而`push`和`insert`操作提供的参数首先会创建一个临时对象，然后再压入容器；

  `emplace`函数的参数`args`与容器的元素的构造函数需要的参数数量和类型是相同的，`emplace`系列的函数会自动调用对应的构造函数在容器中构造一个元素。



# 六. 关系运算符

| 操作                 | 描述               |
| -------------------- | ------------------ |
| `==`、`!=`           | 相等性和不定性判断 |
| `<`、`<=`、`>`、`>=` | 关系运算符         |

****

**注**：

- 参与比较的两个容器类型必须相同

- 比较两个容器实际上是进行元素的逐对比较

- 容器的关系运算符使用元素的关系运算符完成比较。只有当其元素类型也定义了相应的比较运算符时，我们才可以使用关系运算符来比较两个容器。

  容器的相等运算符使用元素的`==`运算符实现比较，而其他关系运算符是使用元素的`<`运算符。



# 七. 获取迭代器

| 操作                       | 描述                                                         |
| -------------------------- | ------------------------------------------------------------ |
| `c.begin()`、`c.end()`     | 返回指向`c`的首元素和尾元素之后位置的迭代器                  |
| `c.cbegin()`、`c.cend()`   | 返回`const_iterator`                                         |
| `c.rbegin()`、`c.rend()`   | 返回指向`c`的尾元素和首元素之前位置的迭代器**（`forward_list`除外）** |
| `c.crbegin()`、`c.crend()` | 返回`const_reverse_iterator`                                 |

****

**注**：

其中不带前缀`c`的成员函数如果调用的对象`c`是一个`const`对象时，与调用带前缀`c`的成员函数的效果相同，否则不相同，即：

```c++
list<string> a = {"Milton", "Shakespeare", "Austen"};
auto beg1 = a.begin();		// 仅当 a 是 const 时，beg 是 const_iterator
auto beg2 = a.cbegin();		// beg2 永远是 const_iterator
```



# 八. 访问元素

| 操作        | 描述                                                         |
| ----------- | ------------------------------------------------------------ |
| `c.back()`  | 返回`c`中尾元素的引用。若`c`为空，函数行为未定义**（`forward_list`不适用）** |
| `c.front()` | 返回`c`中首元素的引用。若`c`为空，函数行为未定义             |

**以下操作只适用于`string`、`vector`、`deque`和`array`：**

| 操作      | 描述                                                         |
| --------- | ------------------------------------------------------------ |
| `c[n]`    | 返回`c`中下标为`n`的元素的引用，`n`是一个无符号整数。<br />若`n>=c.size()`，则函数行为未定义 |
| `c.at(n)` | 返回下标`n`的元素的引用。<br />如果下标越界，则抛出一个`out_of_range`异常 |

