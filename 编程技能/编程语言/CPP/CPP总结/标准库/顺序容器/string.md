# 一. 简介

标准库类型`string`表示可变长的字符序列，使用`string`类型必须首先包含`string`头文件。作为标准库的一部分，`string`定义在命名空间`std`中。所以如果要使用`string`类型，需要下面的准备：

```c++
#include <string>
using std::string;
```

`std::string`类型是针对`char`类型的字符串，而在`string`头文件中，还包含针对其他字符类型的字符串，分别是`std::wstring`、`std::u16string`和`std::u32string`，它们分别是对`wchar_t`、`char16_t`和`char32_t`类型的字符串。

实际上所有的字符串类型都是`std::basic_string`类模板的实例，我们不用再从模板开始自己创建实例，因为字符的类型是有限的，所以无论怎么创建实例，都只有上面的几个类型，我们只需要使用现有的类型即可。



# 二. 成员类型

| 成员类型                 | 定义                                                 |
| ------------------------ | ---------------------------------------------------- |
| `traits_type`            | 指定字符类型上操作的特性类，指定了字符类型后自动指定 |
| `value_type`             | 指定字符类型，`std::string`中的`value_type`为`char`  |
| `allocator_type`         | 指定分配器类型，在指定了字符类型后自动指定           |
| `size_type`              | 表示字符串中字符的个数                               |
| `difference_type`        | 表示指向字符串中两元素的迭代器相减的值的类型         |
| `reference`              | 对字符串元素类型的引用                               |
| `const_reference`        | 对字符串元素类型的常量引用（具有底层 const）         |
| `pointer`                | 对字符串元素类型的指针                               |
| `const_pointer`          | 对字符串常量元素类型的指针（具有底层 const）         |
| `iterator`               | 指向`value_type`的迭代器                             |
| `const_iterator`         | 指向`const value_type`的迭代器（具有底层 const）     |
| `reverse_iterator`       | 指向`value_type`的反向迭代器                         |
| `const_reverse_iterator` | 指向`const value_type`的反向迭代器（具有底层 const） |



# 三. 操作

## 1. 构造

| 操作                  | 效果                                                      |
| --------------------- | --------------------------------------------------------- |
| `string s1`           | 默认初始化，`s1`是一个空串                                |
| `string s2(s1)`       | `s2`是`s1`的副本                                          |
| `string s2 = s1`      | 等价于`s2(s1)`                                            |
| `string s3("value")`  | `s3`是字面值`"value"`的副本，除了字面值最后的那个空字符外 |
| `string s3 = "value"` | 等价于`s3("value")`                                       |
| `string s4(n, 'c')`   | 把`s4`初始化为由连续`n`个字符`c`组成的串                  |



## 2. 其他操作

| 操作                                               | 效果                                                         |
| -------------------------------------------------- | ------------------------------------------------------------ |
| `os<<s`（`os`为输出流对象，`s`为一个`string`对象） | 将`s`写到输出流`os`当中，返回`os`                            |
| `is>>s`（`is`为输入流对象）                        | 从`is`中读取字符串赋给`s`，字符串以空白分隔，返回`is`        |
| `getline(is,s)`                                    | 从`is`中读取一行赋给`s`，返回`is`                            |
| `s.empty()`                                        | `s`为空返回`true`，否则返回`false`                           |
| `s.size()`                                         | 返回`s`中字符的个数，`std::string::size_type`类型            |
| `s[n]`                                             | 返回`s`中第`n`个字符的引用，位置`n`从 0 计起                 |
| `s1+s2`                                            | 返回`s1`和`s2`连接后的结果                                   |
| `s1=s2`                                            | 用`s2`的副本代替`s1`中原来的字符                             |
| `s1==s2`<br />`s1!=s2`                             | 如果`s1`和`s2`中所含的字符完全一样，则它们相等；`string`对象的相等性判断对字母的大小写敏感 |
| `<`，`<=`，`>`，`>=`                               | 利用字符在字典中的顺序进行比较，且对字母的大小写敏感         |



# 四. 注意

## 1. 读写 string 对象

可以通过标准库中的`iostream`来读写`string`对象，如：

```c++
int main()
{
    std::string s;
    std::cin >> s;
    std::cout << s << std::endl;
    return 0;
}
```

这段程序将读取一段连续的非空白字符到`s`中，也就是说，如果我们输入 “	 Hello World! 	”，则输出将是 “Hello”，输出结果中没有任何空格。即`std::cin`对字符串的读取将只读取从第一个非空白字符开始连续读取非空白字符，直到遇到空白字符，且不读取结束时的空白字符。

某些时候我们需要读取一次读取更多更完整的输入，此时可以使用`getline`函数代替原来的`>>`运算符。`getline`函数的参数是一个输入流和一个`string`对象，函数从给定的输入流中读如内容，直到遇到换行符为止（**换行符被读取至给定的输入流中，但是不保存到指定的`string`对象中**）。

**注意**：如果一开始就输入的换行符，则所得的结果是一个空`string`。

另外，`getline`的返回值也是它的流参数，在需要布尔值的地方使用`getline`将会自动将返回的流的状态转换为布尔值，如：

```c++
int main()
{
    std::string line;
    while (getline(std::cin, line))
        std::cout << line << std::endl;
    return 0;
}
```



## 2. 比较 string 对象

按照字典顺序比较是指：

1. 如果两个`string`对象的长度不同，而且较短的`string`对象的每个字符都与较长`string`对象对应位置上的字符相同，就说较短`string`对象小于较长`string`对象
2. 如果两个`string`对象在某些对应的位置上不一致，则`string`对象比较的结果其实是`string`对象中第一对相异字符比较的结果。



## 3. string 对象与字面值相加

标准库允许把字符字面值和字符串字面值转换成`string`对象，所以在需要`string`对象的地方就可以用这两种字面值来替代，如：

```c++
std::string s1 = "Hello";
s1 = s1 + " World!";
s1 = s1 + '\n';
```

最后保存在`s1`中的字符串就是：`"Hello World!\n"`。

**注意**：只允许`string`对象之间的加法或`string`对象与字面值相加，不允许两个字面值相加。

也就是说，下面这种加法就是错误的：

```c++
std::string s1 = "world";
std::string s2 = "hello" + ", " + s1;
```

要理解这种加法为什么错，首先我们需要知道加法的结合顺序是从左至右的结合，所以最先进行加法的应该是`"hello"`和`", "`，而不是`", "`和`s1`。 



## 4. string 中字符的处理

对于单个字符而言，我们有时需要去判断该字符的类型，以及可能需要将某些字符进行转换，如大小写的转换等。

我们可以使用`<cctype>`和`<cwctype>`这两个头文件，前者提供对`char`类型的字符的处理函数，后者提供对`wchar_t`类型字符的处理函数。