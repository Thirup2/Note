# 一. 容器类型

下表列出了标准库中的顺序容器，所有顺序容器都提供了快速顺序访问元素的能力。但是，这些容器在以下方面都有不同的性能折中：

- 向容器添加或从容器中删除元素的代价
- 非顺序访问容器中元素的代价

| 容器类型       | 描述                                                         |
| -------------- | ------------------------------------------------------------ |
| `vector`       | 可变大小数组。<br />支持快速随机访问。<br />在尾部之外的位置插入或删除元素可能很慢 |
| `deque`        | 双端队列。<br />支持快速随机访问。<br />在头尾位置插入/删除速度很快 |
| `list`         | 双向链表。<br />只支持双向顺序访问<br />在`list`中任何位置进行插入/删除操作速度都很快 |
| `forward_list` | 单向链表。<br />只支持单向顺序访问。<br />在链表任何位置进行插入/删除操作速度都很快 |
| `array`        | 固定大小数组。<br />支持快速随机访问<br />不能添加或删除元素 |
| `string`       | 字符串<br />随机访问快<br />在尾部插入/删除速度快            |



# 二. 区别

- 只有`list`、`forward_list`不支持快速随机访问，即下标访问操作；且在任何位置插入/删除速度快
- 只有`array`大小固定，不能添加或删除元素
- `vector`、`string`只在尾部插入/删除快；`deque`在头尾插入/删除快
- 除了`string`外，其余类型都是类模板，需要实例化才能使用；而`string`也来自于类模板`basic_string`，但由于字符串的基础元素已知且有限，所以标准库已经定义好了所需要的所有字符串类型，分别是：`string`（`char`）、`wstring`（`wchar_t`）、`u16string`（`char16_t`）、`u32string`（`char32_t`）。它们都定义在头文件`<string>`中，且在命名空间`std`中。



# 三. 顺序容器的选择

以下是一些选择容器的基本原则：

- 除非有很好的理由选择其他容器，否则应使用`vector`
- 如果程序有很多小的元素，且空间的额外开销很重要，则不要使用`list`或`forward_list`
- 如果程序要求随机访问元素，应使用`vector`或`deque`
- 如果程序要求在容器的中间插入或删除元素，应使用`list`或`forward_list`
- 如果程序需要在头尾位置插入或删除元素，但不会在中间位置进行插入或删除操作，则使用`deque`
- 如果程序只有在读取时才需要在容器中间位置插入元素，随后需要随机访问元素，则
  - 首先，确定是否真的需要在容器中间位置添加元素。当处理输入数据时，通常可以很容易地向`vector`追加数据，然后再调用标准库的`sort`函数来重排容器中的元素，从而避免在中间位置添加元素
  - 如果必须在中间位置插入元素，考虑在输入阶段使用`list`，一旦输入完成，将`list`中的元素拷贝到一个`vector`中。
- 如果程序既需要随机访问元素，又需要在容器中间位置插入元素，则取决于在`list`或`forward_list`中访问元素与在`vector`或`deque`中插入/删除元素的相对性能。一般来说，应用中占主导地位的操作（执行的访问操作更多还是插入/删除更多）决定了容器类型的选择。在此情况下，对两种容器分别测试应用的性能可能就是必要的了。



# 四. 元素类型的限制

顺序容器几乎可以保存任意类型的元素，甚至是一个容器的容器。

但某些容器操作对元素类型有其自己的特殊要求。我们可以为不支持特定操作需求的类型定义容器，但这种情况下就只能使用那些没有特殊要求的容器操作了。

例如，顺序容器构造函数的一个版本接受容器大小参数，它使用了元素类型的默认构造函数。但某些类没有默认构造函数。我们可以定义一个保存这种类型对象的容器，但我们在构造这种容器时不能只传递给它一个元素数目参数：

```c++
// 假定 noDefault 是一个没有默认构造函数的类型
vector<noDefault> v1(10, init);					// 正确：提供了元素初始化器
vector<noDefault> v2(10);					// 错误：必须提供一个元素初始化器
```

