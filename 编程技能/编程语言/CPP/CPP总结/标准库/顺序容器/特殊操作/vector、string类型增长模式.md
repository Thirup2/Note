# 一. 简介

`vector`、`string`都是顺序容器，支持快速随机访问，我们不难想象它们应该是用数组来实现的。

但同时，它们又都几乎没有容量限制，这看上去跟动态内存分配有关。

看上去我们没必要关心这一点，因为这是类的实现所负责的内容。但事实上，对于`vector`和`string`，它们的部分实现渗透到了接口中。

我们首先考虑动态内存分配，如果每向容器中添加一个元素，就需要将所有元素从旧的位置移动到新的空间中，然后添加新元素，释放旧存储空间，那这将会导致性能慢到不可接受。为了避免这种代价，标准库实现者采用了可以减少容器空间重新分配次数的策略。

当不得不获取新的内存空间时，`vector`和`string`的实现通常会分配比新的空间需求更大的内存空间。容器预留这些空间作为备用，可用来保存更多的新元素。这样，就不需要每次添加新元素都重新分配容器的内存空间了。



# 二. size和capacity

`size`函数和`capacity`函数都返回一个容量，前者返回的是容器中已存储的元素数量，而`capacity`则是容器当前的容量大小，包括还未使用的元素位置。

这种区别只在`string`和`vector`类型中存在，这是因为它们的实现的特殊性。

`size`和`capacity`的关系如下图所示：

![临时](https://user-images.githubusercontent.com/91216205/230116428-33cb885e-77ea-471a-817c-08bccd822cc9.jpg)



# 三. 相关操作

**下面的操作只适用于**`vector`、`string`和`deque`：

| 操作                | 描述                                     |
| ------------------- | ---------------------------------------- |
| `c.shrink_to_fit()` | 将`capacity()`减少为与`size()`相同的大小 |

**下面的操作只适用于**`vector`和`string`：

| 操作           | 描述                                              |
| -------------- | ------------------------------------------------- |
| `c.capacity()` | 如果不重新分配内存空间，`c`可以保存的最大元素数量 |
| `c.reserve(n)` | 分配至少能容纳`n`个元素的内存空间                 |

****

**注**：

- `reserve`操作并不改变容器中元素的数量，它仅影响`vector`预先分配多大的内存空间

- 只有当需要的内存空间超过当前容量时，`reserve`调用才会改变`vector`的容量；

  如果需求大小小于当前容量，`reserve`至少分配与需求一样大的内存空间（可能更大）；

  如果需求大小小于当前容量或等于当前容量，`reserve`什么也不做。
  
- `shrink_to_fit`可以要求`deque`、`vector`或`string`退回不需要的内存空间。使用这个函数也表示我们不再需要任何多余的内存空间。但是，具体的实现可以选择忽略此请求。也就是说，调用`shrink_to_fit`也不保证一定退回内存空间。