# 一. 简介

标准库类型`vector`表示对象的集合，其中所有对象的类型都相同。集合中的每个对象都有一个与之对应的索引，索引用于访问对象。使用`vector`之前需要做以下准备：

```c++
#include <vector>
using std::vector;
```

`vector`与`string`相比稍稍有些区别，`string`是一个已经实例化的类型，其前身是`basic_string`类模板，而`basic_string`就与`vector`类似了，它们都是类模板。

我们可以通过类模板创建实例化的类型，其方法是：`类模板名<实例化类型>`，对于`vector`而言，如果想要创建一个`int`类型的`vector`，就可以如下操作：

```c++
std::vector<int> vi;
```

该操作将创建一个`vector<int>`类型对象`vi`，这个类型表示对`vector`类模板的`int`类型实例化，也就是说，由于`vector`是一个容器，所以`vector<int>`将是一个基本元素为`int`类型的容器类型。

另外，我们还可以将`vector`实例化为`string`的`vector`，以及`vector`的`vector`，如：

```c++
std::vector<std::vector<string>>;
```

该例将创建一个`vector<vector<string>>`类型，其基本元素是：`vector<string>`。



# 二. 成员类型

| 成员类型                 | 定义                                                         |
| ------------------------ | ------------------------------------------------------------ |
| `value_type`             | 元素类型，实例化指定的元素类型                               |
| `allocator_type`         | 分配器类型，在指定元素类型之后自动指定                       |
| `size_type`              | 表示元素数量，通常是无符号整数类型，通常为`std::size_t`      |
| `difference_type`        | 表示指向该类型对象元素的两个迭代器相减后值的类型，通常是`std::ptrdiff_t` |
| `reference`              | 表示对`value_type`的引用                                     |
| `const_reference`        | 表示对`const value_type`的引用（具有底层 const）             |
| `pointer`                | 表示对`value_type`的指针                                     |
| `const_pointer`          | 表示对`const value_type`的指针（具有底层 const）             |
| `iterator`               | 指向`value_type`的迭代器                                     |
| `const_iterator`         | 指向`const value_type`的迭代器                               |
| `reverse_iterator`       | 指向`value_type`的反向迭代器                                 |
| `const_reverse_iterator` | 指向`const value_type`的反向迭代器                           |



# 三. 操作

## 1. 构造

| 操作                        | 效果                                                         |
| --------------------------- | ------------------------------------------------------------ |
| `vector<T> v1`              | `v1`是一个空`vector`，它潜在的类型是`T`类型的，执行默认初始化 |
| `vector<T> v2(v1)`          | `v2`中包含有`v1`所有元素的副本                               |
| `vector<T> v2 = v1`         | 等价于`v2(v1)`                                               |
| `vector<T> v3(n, val)`      | `v3`用`n`个元素构成，每个元素都是`val`                       |
| `vector<T> v4(n)`           | `v4`包含了`n`个重复地执行了值初始化的对象                    |
| `vector<T> v5{a, b, c...}`  | `v5`包含了初始值个数的元素，每个元素被赋予相应的初始值       |
| `vector<T> v5 = {a,b,c...}` | 等价于`v5{a, b, c...}`                                       |

**注意**：对于使用圆括号`()`的初始化方式，没有任何歧义。但是对于使用花括号`{}`的初始化方式，可能会产生歧义。如果使用`{}`进行初始化，首先会认为该语句想使用列表初始化对对象进行初始化，如果提供的值又不能用来列表初始化，就要考虑将`{}`中给出的值用来构造`vector`对象。



## 2. 其他操作

| 操作                                    | 效果                                                         |
| --------------------------------------- | ------------------------------------------------------------ |
| `v.empty()`（`v`是一个`vector<T>`对象） | 如果`v`不含有任何元素，返回真；否则返回假                    |
| `v.size()`                              | 返回`v`中元素的个数，`std::vector<T>::size_type`类型         |
| `v.push_back(t)`                        | 向`v`的尾端添加一个值为`t`的元素                             |
| `v[n]`                                  | 返回`v`中第`n`个位置上元素的引用                             |
| `v1 = v2`                               | 用`v2`中元素的拷贝替换`v1`中的元素                           |
| `v1 = {a, b, c...}`                     | 用列表中的元素的拷贝替换`v1`中的元素                         |
| `v1 == v2`<br />`v1 != v2`              | `v1`和`v2`相等当且仅当它们的元素数量相同且对应位置的元素值都相同 |
| `<`，`<=`，`>`，`>=`                    | 以字典顺序进行比较                                           |



# 四. 注意

## 1. 添加元素注意事项

- 在使用范围`for`循环时，不能向`vector`中添加元素
- 不能使用下标向`vector`对象中添加元素
- 不能操作越界下标