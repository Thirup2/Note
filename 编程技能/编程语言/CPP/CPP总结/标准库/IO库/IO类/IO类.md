# 一. 简介

## 1. 头文件

一般的IO类型和对象都是操纵`char`数据的。默认情况下，这些对象都是关联到用户的控制台窗口的。当然，我们不能限制实际应用程序仅从控制台窗口进行IO操作，应用程序常常需要读写命名文件。而且，使用IO操作处理`string`中的字符会很方便。此外，应用程序还可能读写需要宽字符支持的语言。

下表是IO库使用的头文件和头文件中定义的类型（含有前缀`w`的为对宽字符类型`wchar_t`的支持）：

| 头文件     | 类型                                                         |
| ---------- | ------------------------------------------------------------ |
| `iostream` | `istream`，`wistream`：从流中读取数据<br />`ostream`，`wostream`：向流中写入数据<br />`iostream`，`wiostream`：读写流 |
| `fstream`  | `ifstream`，`wifstream`：从文件读取数据<br />`ofstream`，`wofstream`：向文件写入数据<br />`fstream`，`wfstream`：读写文件 |
| `sstream`  | `istringstream`，`wistringstream`：从`string`读取数据<br />`ostringstream`，`wostringstream`：向`string`写入数据<br />`stringstream`，`wstringstream`：读写`string` |

- `<iostream>`：标准IO库，无法使用其中的类型创建对象，只能使用已经准备好的对象进行标准输入输出，如`char`类型的`cin`、`cout`、`cerr`等，以及`wchar_t`类型的`wcin`、`wcout`、`wcerr`等
- `<fstream>`：文件IO库，可以使用其中的类型创建对象



## 2. 读写操作

通过`>>`和`<<`运算符以及`getline`函数进行读写操作，这些操作都需要指定输入输出流的对象。

在标准IO库中，常用的输入输出对象有：`cin`、`cout`、`cerr`、`clog`、`wcin`、`wcout`、`wclog`、`wcerr`；

在文件IO库以及`string`IO库中，需要自行通过库提供的类型及操作创建对应类型的对象。

### 1）`>>`运算符

通过`>>`运算符可以从一个输入流对象读取输入数据并保存到右侧运算对象

运算符左侧为输入流对象，右侧为要读取数据的变量

`>>`的结合律从左至右，返回其左侧运算对象，若读取了内容，则返回`true`，否则返回`false`

例：

```c++
int a, b;
std::cin >> a >> b;
```

### 2) `<<`运算符

通过`<<`运算符可以将右侧运算对象的值写入到左侧的输出流对象中

运算符左侧为输出流对象，右侧对象提供写入内容

`<<`的结合律从左至右，返回其左侧运算对象

例：

```c++
std::cout << "a = " << a << "; b = " << b << std::endl;
```

**注**：`endl`是一个被称为**操纵符**(manipulator)的特殊值。写入`endl`的效果是结束当前行，并将与设备关联的**缓冲区**(buffer)中的内容刷到设备中

### 3）`getline`函数

通过`getline`函数可以一次读取一行内容到输入流对象中（如果是其他输入流对象则只能一次读取一个单词，遇到空白就结束）

`getline`函数的参数是一个输入流，一个`string`或`wstring`对象

`getline`函数的效果是从输入流读取一行内容（如果一开始就是一个换行符，则是一个空串），然后将其保存到那个`string`或`wstring`对象中

`getline`函数的返回值是参数中的输入流，若读取了内容，则返回`true`，若未读取内容，则返回`false`

```c++
string line;
getline(std::cin, line);
```

### 4）注意

**IO对象无拷贝或赋值**。

我们可以创建一个输入输出对象，但是不能在IO对象之间进行拷贝或赋值。

如：

```c++
ofstream out1, out2;
out1 = out2;				// 错误：不能对流对象赋值
ofstream print(ofstream);	 // 错误：不能初始化ofstream参数
out2 = print(out2);			// 错误：不能拷贝流对象
```



## 3. IO类型间的关系

**IO对象的具体IO类型可能不同，但都可以使用`<<`、`>>`和`getline`函数来进行读写操作。**

因为在所有的IO类型中，类型`ifstream`和`istringstream`都继承自`istream`；`ofstream`和`ostringstream`都继承自`ostream`，所以我们可以用相同的方法来实现文件读取和`string`读取，只需要使用对应的类型即可。



# 二. 条件状态

IO操作一个与生俱来的问题是可能发生错误。一些错误是可恢复的，而其他错误则是发生在系统深处，已经超出了应用程序可以修正的范围。

IO类定义了一些函数和标志，可以帮助我们访问和操纵流的**条件状态**(condition state)，其具体内容如下表(`strm`表示一种IO类型，`s`表示一个IO对象)：

| 函数及标志          | 条件状态                                                     |
| ------------------- | ------------------------------------------------------------ |
| `strm::iostate`     | `iostate`是一种机器相关的类型，提供了表达条件状态的完整功能  |
| `strm::badbit`      | `badbid`用来指出流已崩溃                                     |
| `strm::failbit`     | `failbit`用来指出一个IO操作失败了                            |
| `strm::eofbit`      | `eofbit`用来指出流到达了文件结束                             |
| `strm::goodbit`     | `goodbit`用来指出流未处于错误状态。此值保证为零              |
| `s.eof()`           | 若流`s`的`eofbit`置位，则返回`true`                          |
| `s.fail()`          | 若流`s`的`failbit`或`badbit`置位，则返回`true`               |
| `s.bad()`           | 若流`s`的`badbid`置位，则返回`true`                          |
| `s.good()`          | 若流`s`处于有效状态，则返回`true`                            |
| `s.clear()`         | 若流`s`中所有条件状态位复位，将流的状态设置为有效。返回`void` |
| `s.clear(flags)`    | 根据给定的`flags`标志位，将流`s`中对应条件状态位复位。`flags`的类型为`strm::iostate`。返回`void` |
| `s.setstate(flags)` | 根据给定的`flags`标志位，将流`s`中对应条件状态位置位。`flags`的类型为`strm::iostate`。返回`void` |
| `s.rdstate()`       | 返回流`s`的当前条件状态，返回值类型为`strm::iostate`         |

**解释**：

对于上表而言，`iostate`是一种类型，可以理解为流类型的一个成员，用来表征流对象的状态。

然后有四个`iostate`类型的常量值，分别是`badbit`、`failbit`、`eofbit`、`goodbit`，它们用来表示流的四种状态，任意一个流在任意时刻都应该处于这四种状态之一，一般情况下处于`good`状态，当发生错误后，可能会使流处于另外三种状态之一。

另外，我们可以通过流类型中的四个成员函数来查询当前流的状态，分别是`eof()`、`fail()`、`bad()`和`good()`函数；以及我们可以通过最后四个函数来管理当前流的条件状态。



## 1. 查询流的状态

`iostate`类型的值可以看作一个位集合，不同的位模式表示不同的含义：

- `badbit`表示系统级错误，如不可恢复的读写错误。通常情况下，一旦`badbit`被值为，流就无法再使用了。
- `failbit`在发生可恢复错误后被置位，如期望读取数值却读出一个字符等错误。这种问题通常是可以修正的，流还可以继续使用。
- `eofbit`在到达文件结束位置时会被置位，同时`failbit`也会被置位。
- `goodbit`的值为0，也就是所有位都为0，表示流未发生错误，一般情况下流都处于该状态

查询流的状态有两种方法：

1. 将流作为条件：即将流转换为`bool`类型，很明显，该方法只能区分出两种状态，是`goodbit`还是非`goodbit`状态，如下：

   ```c++
   int ival;
   while (cin >> ival) {
       /* ... */
   }
   ```

2. 通过成员函数：有四个成员函数来查询流的状态，当流处于对应的状态时，该成员函数会返回`true`，如下：

   ```c++
   int ival;
   cin >> ival;
   if (cin.eof()) {
       /* ... */
   } else if (cin.fail()) {
       /* ... */
   } else if (cin.bad()) {
       /* ... */
   } else if (cin.good()) {
       /* ... */
   }
   ```



## 2. 管理条件状态

通过四个成员函数来管理流的条件状态：`clear()`、`clear(flags)`、`setstate(flags)`、`rdstate()`

- `rdstate()`：返回一个`iostate`的值，对应当前流的状态
- `setstate(flags)`：将流中给定条件位置位，`flags`是一个`iostate`类型的参数，用来指定流中需要置位的位
- `clear()`：将所有标志位复位，即恢复到`goodbit`状态
- `clear(flags)`：将流按照新的状态进行复位，`flags`是一个`iostate`类型的参数，用来表示流的新状态

如下例所示，将`failbit`和`badbit`复位，其他位保持不变：

```c++
cin.clear(cin.rdstate() & ~cin.failbit & ~cin.badbit);
```



# 三. 管理输出缓冲

## 1. 缓冲区

每个输出流都管理一个缓冲区，用来保存程序读写的数据。例如一个输出操作：

```c++
os << "please enter a value: ";
```

可能立即打印出来，也可能被操作系统保存在缓冲区中，随后再打印。

通过缓冲机制，操作系统就可以将程序的多个输出操作组合成单一的系统级写操作。由于设备的写操作可能很耗时，允许操作系统将多个输出操作组合为单一的设备写操作可以带来很大的性能提升。

缓冲区也可能会导致一些问题，我们常常需要确定缓冲区是否已经为空，即**缓冲刷新**。导致缓冲刷新的原因有很多：

- 程序正常结束，作为`main`函数的`return`操作的一部分，缓冲刷新被执行。
- 缓冲区满时，需要刷新缓冲，而后新的数据才能继续写入缓冲区
- 我们可以使用操纵符如`endl`来显式刷新缓冲区
- 在每个输出操作之后，我们可以用操纵符`unitbuf`设置流的内部状态，来清空缓冲区。默认情况下，`cerr`是设置为`unitbuf`的，因此写到`cerr`的内容都是立即刷新的
- 一个输出流可能会被关联到另一个流。在这种情况下，当读写被关联到的流时，关联到的流的缓冲区会被刷新。例如，默认情况下，`cin`和`cerr`都关联到`cout`。因此，读`cin`或写`cerr`都会导致`cout`的缓冲区被刷新。



## 2. 刷新输出缓冲区

和`endl`的使用方法相同，`flush`和`ends`也可以实现刷新缓冲区。

- `endl`：输出`endl`之前的内容和一个换行符，然后刷新缓冲区
- `flush`：输出`flush`之前的内容，然后刷新缓冲区
- `ends`：输出`ends`之前的内容和一个空字符，然后刷新缓冲区



## 3. `unitbuf`操纵符

通过`unitbuf`操纵符设置一次流状态，在此之后的每次写操作之后都会进行一次`flush`操作。通过`nounitbuf`操纵符可以重置流状态，使其恢复使用正常的系统管理的缓冲区刷新机制：

```c++
cout << unitbuf;
// 任何输出都立即刷新，无缓冲
cout << nounitbuf;
```



## 4. 关联输入和输出流

当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。如标准库将`cout`和`cin`关联在一起，这是因为交互式系统通常应该关联输入流和输出流，因为在读操作之前所有用户提示信息都应该提前打印出来。

流之间通过成员函数`tie`进行关联，该函数有两个重载的版本。

1. 第一个版本不带参数，返回指向输出流的指针。如果本对象当前关联到一个输出流，则返回的就是这个指向流的指针，如果对象未关联到流，则返回空指针。所以这个版本是查询当前流所关联的流的函数
2. 第二个版本接收一个指向`ostream`的指针，将自己关联到此`ostream`（如果之前有相关联的流，则与其的关联会解除），同时返回之前所关联的流的指针。即`x.tie(&o)`将流`x`关联到输出流`o`，不论是`istream`还是`ostream`对象都可以关联到另一个`ostream`。

**例**：

```c++
ostream *old_tie = cin.tie(nullptr);		// old_tie指向cout，因为cin最初和cout相关联；同时使cin不再与其他流相关联
cin.tie(&cerr);							 // 使cin和cerr相关联
cin.tie(old_tie);						   // 重建cin和cout间的正常关联
```

