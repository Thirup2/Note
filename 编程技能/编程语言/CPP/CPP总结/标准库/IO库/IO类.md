# 一. IO类简介

最常用的 IO 类型应该是标准 IO 类型，通常情况下这些类型的对象都是关联到用户的控制台窗口的，并且它们都操纵`char`数据。

而比较复杂的 IO 类型可能将 IO 对象与某个文件或某个`string`对象关联在一起，另外还有可能是操纵宽字符的。

C++ 所有的 IO 库的头文件和对应的类型如下表所示：

| 头文件       | 类型                                                         |
| ------------ | ------------------------------------------------------------ |
| `<iostream>` | `istream`、`wistream`：从流中读取数据<br />`ostream`、`wostream`：从流中写入数据<br />`iostream`、`wiostream`：读写流 |
| `<fstream>`  | `ifstream`、`wifstream`：从文件读取数据<br />`ofstream`、`wofstream`：从文件写入数据<br />`fstream`、`wfstream`：读写文件 |
| `<sstream>`  | `istringstream`、`wistringstream`：从`string`读取数据<br />`ostringstream`、`wostringstream`：从`string`写入数据<br />`stringstream`、`wstringstream`：读写`string` |

- 上表中每一个类型都有一个带有前缀`w`的类型，它们是操纵`wchar_t`类型字符的 IO 类型。
- 每一种 IO 都有 3 种 IO 方式：只读、只写、读写

****

要理解 IO 类型之间的区别和联系，我们应该理解 C++ 中 IO 的过程：

以标准 IO 为例，`cin`是一个`istream`的对象，`cout`是一个`ostream`的对象。

当我们执行输入过程的时候，`cin`首先从（一般是）控制台（与输入流对象关联的设备或程序）获取流的内容，然后将内容写入到`>>`后面的对象；当我们执行输出过程的时候，`cout`首先将数据从程序保存到`cout`本身当中，然后将流内容输出到（一般是）控制台（与输出流对象关联的设备或程序）中。

所以实际上 IO 类型之间的区别就在于与可以与流对象关联的对象不同：

标准 IO 类型的流基本上是与计算机系统本身的硬件或程序相关联，而实际上 IO 已经定义好了我们所需要的输入流和输出流的对象，并且不再允许我们使用标准 IO 类型定义其他的对象。这是因为标准 IO 类型所能关联的对象比较底层，且通常比较固定，所以不需要改变。如果要关联到其他的对象，需要使用终端本身的重定向功能。

文件 IO 类型的流就是与某个文件相关联，从文件中读取内容到文件输入流对象，从文件输出流对象向文件写入内容。在创建文件 IO 对象的时候需要为对象绑定一个文件。

而`string`类型的流就是与某个字符串相关联，从`string`对象中读取内容到`string`输入流对象，从`string`输出流对象向`string`对象写入内容。和文件 IO 一样，在创建`string` IO 对象的时候需要为对象绑定一个`string`对象。



# 二. 通用 IO 操作

## 1. 输入操作`>>`

通过`>>`运算符将内容从输入流对象写入到`>>`右侧的运算对象。

需要注意：在执行上一步之前，还有一步从与输入流对象关联的某个设备、程序、文件或`string`对象中将内容拷贝到输入流对象的过程。

`>>`运算符执行上述过程，并返回`>>`的左侧运算对象的引用，即输入流对象本身。被返回的输入流对象中保存着上一次输入的结果状态，如果将输入流对象用于一个需要`bool`类型值的地方，则其会根据这个状态转换为对应的`bool`值。

另外，`>>`运算符的结合律是从左至右的，并且由于它返回左侧运算对象，所以我们可以串联多个`>>`运算符。



## 2. 输出操作`<<`

通过`<<`运算符将内容从`<<`右侧的运算对象写入到`<<`左侧的输出流对象中，然后在这之后才将内容从输出流对象写入到与该对象关联的设备、程序、文件或`string`对象。

`<<`运算符和`>>`运算符相同，它们都返回左侧的运算对象，并且是从左至右的结合律，所以意味着我们也可以串联多个`<<`运算符。



## 3. 注意：IO 对象无拷贝或赋值

我们不能拷贝或对 IO 对象赋值，这意味着：

- 我们不能将形参或返回类型设置为流类型（但可以设置为引用类型）
- 在不注意时对 IO 对象使用了拷贝或赋值操作之后将会出错
- 读写一个 IO 对象会改变其状态，因此传递和返回的引用不能是`const`的



# 三. 条件状态

IO 对象每次执行 IO 操作的结果可能成功也可能失败，而 IO 对象通过类中定义的一个类型成员`iostate`以及该类型的一些实际的数据成员来标识操纵流的**条件状态**（condition state），以下是 IO 类所定义的一些函数和标志（其中`strm`是一种 IO 类型如`istream`，`s`是一个具体的 IO 类型的对象）：

| 类型、函数或标志    | 说明                                                         |
| ------------------- | ------------------------------------------------------------ |
| `strm::iostate`     | **类型**：一种与机器相关的类型，提供了表达条件状态的完整功能 |
| `strm::badbit`      | **标志**：用来指出流已崩溃                                   |
| `strm::failbit`     | **标志**：用来指出一个 IO 操作失败了                         |
| `strm::eofbit`      | **标志**：用来指出流到达了文件结束                           |
| `strm::goodbit`     | **标志**：用来指出流未处于错误状态。此值保证为 0             |
| `s.eof()`           | **函数**：若流`s`的`eofbit`置位，则返回`true`                |
| `s.fail()`          | **函数**：若流`s`的`failbit`或`badbit`置位，则返回`true`     |
| `s.bad()`           | **函数**：若流`s`的`badbit`置位，则返回`true`                |
| `s.good()`          | **函数**：若流`s`处于有效状态，则返回`true`                  |
| `s.clear()`         | **函数**：将流`s`中所有条件状态复位，将流的状态设置为有效。返回`void` |
| `s.clear(flags)`    | **函数**：根据给定的`flags`标志位，将流`s`中对应条件状态位复位。`flags`的类型为`strm::iostate`。返回`void` |
| `s.setstate(flags)` | **函数**：根据给定的`flags`标志位，将流`s`中对应条件状态位置位。`flags`的类型为`strm::iostate`。返回`void` |
| `s.rdstate()`       | **函数**：返回流`s`的当前条件状态，返回值类型为`strm::iostate` |

## 1. 理解

可以把`iostate`看作一个大小只有 3 位二进制数据的类型，可以用来表示需要的 4 个状态。

用来标识当前流状态的就是一个不可见的`iostate`类型的数据成员，可以用`rdstate()`函数来获取当前流对象的状态，它所返回的就是这个数据成员的值。

****

假设`failbit`、`eofbit`、`badbit`这三个状态分别对应从最高位到最低位的每个位，它们的值就应该是

- `failbit`：100
- `eofbit`：010
- `badbit`：001

还有一个状态`goodbit`用全是 0 的位模式来表示。

这些状态位是固定不变的（`constexpr`的），它们用 1 所在的位置来标识一个`iostate`类型的对象中 3 个位分别所对应的含义，这些状态位可以通过位运算符来设置后面可能需要的`flags`。

****

而`eof`、`fail`、`bad`、`good`这四个成员函数用于返回对应的状态是否置位，如果没有置位，那对应的值就是`false`；如果置位，就是`true`。

****

而后面的三个函数用来管理流的状态：

- `clear()`：将当前流状态复位，即修改为`goodbit`状态，无任何错误发生
- `clear(flags)`：按照`flags`进行复位
- `setstate(flags)`：按照`flags`进行置位



## 2. 查询流的状态

我们可以通过返回布尔值的那 4 个成员函数查询某个状态是否被置位了，那么各个状态被置位对应的状态具体是什么意思呢？

- `goodbit`

  如果当前流状态与`goodbit`值相同，那么没有任何错误发生。

  而如果当前流状态与`goodbit`值不相同，那么说明肯定有某种错误发生。

- `badbit`

  如果当前流状态的`badbit`位被置为 1，那么说明发生了系统级错误，如不可恢复的读写错误。

  通常情况下，一旦该位被置位，流就无法使用了。

- `failbit`

  如果当前流状态的`failbit`位被置为 1，表示发生了可恢复错误，如期望读取数值却读出一个字符等错误。

  这种问题通常是可以修正的，流还可以继续使用

- `eofbit`

  如果当前状态的`eofbit`位被置为 1，表示到达文件结束位置。

  同时，由于该错误是可恢复错误，所以如果`eofbit`位被置位，那么`failbit`位也将被置位

这 4 个状态的关系大概如下图所示：

![临时](https://user-images.githubusercontent.com/91216205/229710984-87dd1694-2a10-4ace-98da-686894944052.jpg)



## 3. 管理条件状态

IO 库中的`clear()`、`clear(flags)`、`setstate(flags)`和`rdstate`这 4 个函数用于管理 IO 流的条件状态。

它们的功能如前所述，主要是中间的两个函数的`flags`参数应该怎么设置。

首先这两个参数都是`iostate`类型的，也就是有 3 个位，分别用来指定各种状态。

****

我们以`clear`函数为例：

如果我们想将`failbit`和`badbit`复位，但保持`eofbit`不变，我们就应该：

```c++
cin.clear(cin.rdstate() & ~cin.failbit & ~cin.badbit);
```

首先`~cin.failbit`表示除了第 1 位（假设）之外的其他位都是 1，即 011；`~cin.badbit`表示除了第 3 位（假设）之外的其他位都是 1，即110；

然后`011 & 110`得到`010`。

然后将这个值与当前的流状态进行位与操作，其具体细节如下：

- 若当前状态的`eofbit`位（第 2 位（假设））被置位，那么保持被置位；若未被置位，那么保持未置位；
- 当前状态的`failbit`位和`badbit`位不论是否置位都恢复为 0（即未置位状态）

****

当我们使用`clear`函数时，它内部执行与参数的位与运算，即将设置为 0 的位复位，其他位保持不变；

当我们使用`setstate`函数时，它内部执行与参数的位或运算，即将设置为 1 的位置位，其他位保持不变。



# 四. 管理输出缓冲

每个输出流都管理一个缓冲区，用来保存程序读写的数据，这个缓冲区应该是`string`或`wstring`类型的。

当有了缓冲区之后，如下的代码：

```c++
os << "please enter a value: ";
```

这行文本串可能立即打印出来，也可能被操作系统保存在缓冲区中，随后再打印。

有了缓冲机制，操作系统就可以将程序的多个输出操作组合成但一的系统级写操作。由于设备的写操作可能很耗时，允许操作系统将多个输出操作组合为单一的设备写操作可以带来很大的性能提升。

而导致缓冲刷新（即数据真正写到输出设备或文件）的原因有很多：

- 程序正常结束，作为`main`函数的`return`操作的一部分，缓冲刷新被执行。
- 缓冲区满时，需要刷新缓冲，而后新的数据才能继续写入缓冲区
- 我们可以使用操纵符如`endl`来显式刷新缓冲区
- 在每个输出操作之后，我们可以用操纵符`unitbuf`设置流的内部状态，来清空缓冲区。默认情况下，对`cerr`是设置`unitbuf`的，因此写到`cerr`的内容都是立即刷新的
- 一个输出流可能被关联到另一个流。在这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。例如，默认情况下，`cin`和`cerr`都关联到`cout`。因此，读`cin`或写`cerr`都会导致`cout`的缓冲区被刷新

## 1. 使用操纵符

**单次输出操作：**

和`endl`类似的还有几个操纵符：

- `endl`：先向缓冲区插入一个换行，然后刷新缓冲区
- `flush`：直接刷新缓冲区
- `ends`：先向缓冲区插入一个空字符（`'\0'`），然后刷新缓冲区

****

**设置后的每次输出操作：**

可以通过设置输出流的某个状态让其在后面每次输出操作都执行一次`flush`操作，这个状态就是`unitbuf`，具体使用方法如下：

```c++
std::cout << std::unitbuf;		// 所有输出操作后都会立即刷新缓冲区
std::cout << std::nounitbuf;		// 回到正常的缓冲方式
```



## 2. 关联输入和输出流

当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。标准库将`cout`和`cin`关联在一起。

主要通过两个成员函数来关联流和管理已关联的流（`s`表示一个流对象）：

| 成员函数     | 效果                                                         |
| ------------ | ------------------------------------------------------------ |
| `s.tie(pos)` | `pos`是一个指向输出流的指针，将`s`关联到`pos`所指的输出流，并返回`s`之前所关联的输出流的指针 |
| `s.tie()`    | 无参数。返回指向与`s`关联的输出流的指针；若`s`未与任何输出流关联，则返回空指针 |

如果要断开一个流对象与另一个相关联的输出流的关联，则传入一个空指针，即：

```c++
s.tie(nullptr);
```

另外，每个流同时最多关联到一个输出流，但多个流可以同时关联到同一个输出流。
