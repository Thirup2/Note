除了为每个容器定义的迭代器之外，标准库在头文件`iterator`中还定义了额外几种迭代器。这些迭代器包括以下几种：

- **插入迭代器**（insert iterator）：这些迭代器被绑定到一个容器上，可用来向容器插入元素
- **流迭代器**（stream iterator）：这些迭代器被绑定到输入或输出流上，可用来遍历所关联的 IO 流
- **反向迭代器**（reverse iterator）：这些迭代器向后而不是向前移动。除了`forward_list`之外的标准库容器都有反向迭代器
- **移动迭代器**（move iterator）：这些专用的迭代器不是拷贝其中的元素，而是移动它们。

# 一. 插入迭代器

插入器是一种迭代器适配器，它接受一个容器，生成一个迭代器，能实现向给定容器添加元素。当我们通过一个插入迭代器进行赋值时，该迭代器调用容器操作来想给定容器的指定位置插入一个元素。

## 1. 分类

插入器有三种类型，差异在与元素插入的位置：

- **back_inserter**：创建一个使用`push_back`的迭代器，返回的迭代器类型为`std::back_insert_iterator<container_class>`
- **front_inserter**：创建一个使用`push_front`的迭代器，返回的迭代器类型为`std::front_insert_iterator<container_class>`
- **inserter**：创建一个使用`insert`的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前，返回的迭代器类型为`std::insert_iterator<container_class>`

**需要注意的是**：只有在容器支持`push_front`的情况下，我们才可以使用`front_inserter`。类似的，只有在容器支持`push_back`的情况下，我们才能使用`back_inserter`。



## 2. 操作

其支持的操作如下：

| 操作                  | 描述                                                         |
| --------------------- | ------------------------------------------------------------ |
| `it = t`              | 在`it`指定的当前位置插入值`t`。<br />假定`c`是`it`绑定的容器，依赖于插入迭代器的不同种类<br />此赋值会分别调用`c.push_back(t)`、`c.push_front(t)`或`c.insert(t, p)`，<br />其中`p`为传递给`inserter`的迭代器位置 |
| `*it`，`++it`，`it++` | 这些操作虽然存在，但不会对`it`做任何事情，每个操作都返回`it` |



# 二. 流迭代器

虽然`iostream`类型不是容器，但标准库定义了可以用于这些 IO 类型对象的迭代器。`istream_iterator`读取输入流；`ostream_iterator`向一个输出流写数据。这些迭代器将它们对应的流当作一个特定类型的元素序列来处理。通过使用流迭代器，我们可以用泛型算法从流对象读取数据以及向其写入数据。

## 1. istream_iterator 操作

| 操作                           | 描述                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| `istream_iterator<T> in(is)`   | `in`从输入流`is`读取类型为`T`的值                            |
| `istream_iterator<T> end`      | 读取类型为`T`的值的`istream_iterator`迭代器，表示尾后位置    |
| `in1 == in2`<br />`in1 != in2` | `in1`和`in2`必须读取相同类型。如果它们都是尾后迭代器，或绑定到相同的输入，则两者相等 |
| `*in`                          | 返回从流中读取的值                                           |
| `in->mem`                      | 与`(*in).mem`的含义相同                                      |
| `++in`，`in++`                 | 使用元素类型所定义的`>>`运算符从输入流中读取下一个值。<br />与以往一样，前置版本返回一个指向递增后迭代器的引用，后置版本返回旧值 |

我们可以从一个`istream`获取迭代器来作为参数传递给其他函数：
```c++
istream_iterator<int> in_iter(cin), eof;
vector<int> vec(in_iter, eof);
```

在上例中，将从迭代器给出的范围构造`vec`。这个操作是从`cin`中读取数据，直至遇到文件尾或者遇到一个不是`int`的数据为止。从流中读取的数据被用来构造`vec`。

****

**使用算法操作流迭代器**：

由于算法使用迭代器操作来处理数据，而流迭代器又至少支持某些迭代器操作，因此我们至少可以用某些算法来操作流迭代器。

如下所示，我们可以用一对`istream_iterator`来调用`accumulate`：

```c++
istream_iterator<int> in(cin), eof;
cout << accumulate(in, eof, 0) << endl;
```

此调用会计算出从标准输入读取的值的和。

****

**istream_iterator 允许使用懒惰求值**：

当我们将`istream_iterator`绑定到一个流时，标准库并不保证迭代器立即从流中读取数据。具体实现可以推迟从流中读取数据，直到我们使用迭代器时才真正读取。标准库中的实现所保证的是，在我们第一次解引用迭代器之前，从流中读取数据的操作已经完成了。对于大多数程序来说，立即读取还是推迟读取没什么差别。但是，如果我们创建了一个`istream_iterator`，没有使用就销毁了，或者我们正在从两个不同的对象同步读取同一个流，那么何时读取可能就很重要了。



## 2. ostream_iterator 操作

| 操作                             | 描述                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| `ostream_iterator<T> out(os)`    | `out`将类型为`T`的值写到输出流`os`中                         |
| `ostream_iterator<T> out(os, d)` | `out`将类型为`T`的值写到输出流`os`中，每个值后面都输出一个`d`。`d`指向一个空字符结尾的字符数组 |
| `out = val`                      | 用`<<`运算符将`val`写入到`out`所绑定的`ostream`中。`val`的类型必须与`out`可写的类型兼容 |
| `*out`，`++out`，`out++`         | 这些运算符是存在的，但不对`out`做任何事情。每个运算符都返回`out` |

