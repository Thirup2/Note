# 一. 简介

`string`和`vector`都属于容器类型，而所有的容器类型都可以使用迭代器。

迭代器就类似于指针类型，可以使用和指针相同的操作方法对对象进行间接访问。同时迭代器也能从一个元素移动到另外一个元素。

另外，迭代器有有效和无效之分：有效迭代器指向某个实际存在的元素或容器中最后一个元素的下一位置（尾后位置），其他所有情况都属于无效。

对于含有迭代器类型的类来说，我们不需要做任何其他的准备。而如果我们是想单独使用迭代器类型，就需要做下面的准备：

```c++
#include <iterator>
using std::iterator;
using std::const_iterator;
```

迭代器的类型可能为`std::iterator`或`std::const_iterator`，前者指向非常量元素，后者指向常量元素。



# 二. 获取迭代器

有迭代器的类型通常都有返回迭代器的成员，如`string`和`vector`都有拥有名为`begin`和`end`的成员函数，其中`begin`返回指向容器中第一个元素的位置，`end`返回指向容器最后一个元素的下一位置（**尾后迭代器**）。如果容器为空，`begin`和`end`返回同一个迭代器。

迭代器的类型为：`className::iterator`或`className::const_iterator`（若对象是常量，则返回后者）。也可以用`cbegin`和`cend`成员函数强制返回具有底层`const`的类型。

如：

```c++
std::vector<int> vi(10, 5);	// 10 个值为 5 的元素
std::vector<int>::iterator beg = vi.begin();
std::vector<int>::const_iterator end = vi.cend();
```

其中`beg`将指向`vi`中第 1 个元素，`end`将指向`vi`中第 11 个元素（一个不存在的元素，尾后位置，所以声明为`const_iterator`表示不能修改）。

