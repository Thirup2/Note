# 一. 简介

`string`和`vector`都属于容器类型，而所有的容器类型都可以使用迭代器。

迭代器就类似于指针类型，可以使用和指针相同的操作方法对对象进行间接访问。同时迭代器也能从一个元素移动到另外一个元素。

另外，迭代器有有效和无效之分：有效迭代器指向某个实际存在的元素或容器中最后一个元素的下一位置（尾后位置），其他所有情况都属于无效。

对于含有迭代器类型的类来说，我们不需要做任何其他的准备。而如果我们是想单独使用迭代器类型，就需要做下面的准备：

```c++
#include <iterator>
using std::iterator;
using std::const_iterator;
```

迭代器的类型可能为`std::iterator`或`std::const_iterator`，前者指向非常量元素，后者指向常量元素。



# 二. 获取迭代器

有迭代器的类型通常都有返回迭代器的成员，如`string`和`vector`都有拥有名为`begin`和`end`的成员函数，其中`begin`返回指向容器中第一个元素的位置，`end`返回指向容器最后一个元素的下一位置（**尾后迭代器**）。如果容器为空，`begin`和`end`返回同一个迭代器。

迭代器的类型为：`className::iterator`或`className::const_iterator`（若对象是常量，则返回后者）。也可以用`cbegin`和`cend`成员函数强制返回具有底层`const`的类型。

如：

```c++
std::vector<int> vi(10, 5);	// 10 个值为 5 的元素
std::vector<int>::iterator beg = vi.begin();
std::vector<int>::const_iterator end = vi.cend();
```

其中`beg`将指向`vi`中第 1 个元素，`end`将指向`vi`中第 11 个元素（一个不存在的元素，尾后位置，所以声明为`const_iterator`表示不能修改）。



# 三. 迭代器范围

一个迭代器范围由一对迭代器表示，两个迭代器分别指向同一个容器中的元素或者是尾元素之后的位置。这两个迭代器通常被称为`begin`和`end`，它们标记了容器中元素的一个范围。

而容器用迭代器表示的范围应该如下：

$[begin,\ end)$

表示范围从`begin`开始，在`end`之前结束，称为**左闭合区间**。

迭代器`begin`和`end`必须指向相同的容器。`end`可以和`begin`指向相同的位置，但不能指向`begin`之前的位置。

****

在这种范围规定下，可以得到三种方便的**性质**（假定`begin`和`end`构成一个合法的迭代器范围）：

- 如果`begin`和`end`相等，则范围为空
- 如果`begin`和`end`不等，则范围至少包含一个元素，且`begin`指向该范围中的第一个元素
- 我们可以对`begin`递增若干次，使得`begin == end`

这些性质意味着我们可以像下面的代码一样用一个循环来处理一个元素范围，且是安全的：



# 四. 迭代器失效

向容器中添加元素和从容器中删除元素的操作可能会使指向容器元素的指针、引用或迭代器失效。

一个失效的指针、引用或迭代器将不再表示任何元素。使用失效的指针、引用或迭代器是一种严重的程序设计错误，很可能引起与使用未初始化指针一样的问题。

## 1. 失效情形

迭代器失效可能发生于以下情形：

**在向容器添加元素后**：

- 如果容器是`vector`或`string`，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。

  如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用将会失效

- 对于`deque`，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。

  如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效

- 对于`list`和`forward_list`，指向容器的迭代器（包括尾后迭代器和首前迭代器）、指针和引用仍有效

**当我们从一个容器中删除元素后**：

- 指向被删除元素的迭代器、指针和引用会失效

- 对于`list`和`forward_list`，指向容器其他位置的迭代器（包括尾后迭代器和首前迭代器）、引用和指针仍有效

- 对于`deque`，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、引用和指针会失效。

  如果是删除`deque`的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不受影响；

  如果是删除首元素，这些也不会受影响。

- 对于`vector`和`string`，指向被删元素之前元素的迭代器、引用和指针仍有效。

  而尾后迭代器总是会失效



## 2. 管理迭代器

当使用迭代器（或指向容器元素的引用或指针）时，最小化要求迭代器必须保持有效的程序片段是一个好的方法。

由于向迭代器添加元素和从迭代器删除元素的代码可能会使迭代器失效，因此**必须保证每次改变容器的操作之后都正确地重新定位迭代器**。这个建议对`vector`、`string`和`deque`尤为重要。
