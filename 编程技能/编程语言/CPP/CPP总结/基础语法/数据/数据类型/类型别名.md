# 一. 定义方法

## 1. typedef

**类型别名**（type alias）是一个名字，它是某种类型的同义词。有两种方法可用于定义类型别名，其中比较传统的方法是使用关键字`typedef`：

```c++
typedef double wages;		// wages 是 double 的同义词
typedef wages base, *p;		// base 是 double 的同义词，p 是 double* 的同义词
```

使用`typedef`的类型别名定义格式通常是：`typedef` + 原来的类型 + 类型别名。作为类型别名的往往只有一个单词，不包含任何的类似于`*`、`&`等的符号但在定义时可能会需要这些符号，在`typedef`和类型别名中间所夹的内容就是原来的类型。当然，有些原本的类型会有一些符号出现在类型别名之后，如数组或函数指针，用以说明该类型别名将创建一个数组或函数指针，如：

```c++
typedef int iarr[20];			// iarr 是一个包含 20 个元素的 int 数组的类型，使用 iarr 将直接创建一个拥有 20 个元素的 int 类型数组
typedef void (*sfun)(int, char);	// sfun 是一个函数指针类型，指向的函数接受一个 int 参数和一个 char 参数，且无返回值
```



## 2. using

另外一种方法是使用**别名声明**（alias declaration）的方法来定义类型的别名，这种方法使用关键字`using`作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名，如：

```c++
using wages = double;		// 等价于 typedef double wages;
using base = wages;			// 等价于 typedef wages base;
using p = wages *;			// 等价于 typedef wages *p;
using iarr = int[20];		// 等价于 typedef int iarr[20];
using ifun = int (*)(int);	// 等价于 typedef int (*ifun)(int);
```

从这些例子上来看，使用`using`的别名声明比起`typedef`来说要清晰简洁很多，理解起来也更简单。



# 二. 指针、常量和类型别名

## 1. 指针

在变量声明时我们使用`类型说明符 + 声明符列表`的形式，使用类型别名时同样采用这样的形式。

其中类型说明符就是我们的类型别名，而声明符列表中的所有声明符都将是该类型说明符（也就是我们的别名）所表示的类型。说的更明白一点，如果这个类型别名是一个指针，那么声明符列表中的所有声明符都将是一个指针，如：

```c++
using ip = int *;

ip p1, p2, *p3;		// p1 是一个 int * 类型，p2 也是一个 int * 类型，而 p3 是一个指向 int * 类型的指针即 int ** 类型
```

而如果我们不使用别名，将会有所区别：

```c++
int * p1, p2, *p3;	// p1 是一个 int * 类型，p2 是一个 int 类型，p3 是一个 int * 类型
```



## 2. 常量

我们知道指针有顶层`const`和底层`const`之分，那么如果一个类型别名是一个指针类型，那么`const`在该类型别名之前应该表示这个指针是顶层`const`还是底层`const`呢？

结论是表示该指针具有顶层`const`属性，即指针无法修改其指向。

如下所示：

```c++
using pstring = char *;

const pstring cstr = 0;		// 创建一个指向非常量对象的常量指针
```

请注意不能把该别名展开观察：

```c++
const char * cstr = 0;		// 创建一个指向常量对象的非常量指针
```

之所以会这样，实际上类型别名相当于把一个复杂类型独立开了，即`pstring`就表示指向字符的指针类型，“指向字符的指针” 这一整个概念是独立的，不受任何影响的，它的主体是一个指针，所以在这个类型别名前添加`const`修饰的理所当然是指针本身而不是指针指向的对象。如果想要一个指向常量字符的指针类型就必须修改`pstring`本身，而不是在其外部添加`const`。