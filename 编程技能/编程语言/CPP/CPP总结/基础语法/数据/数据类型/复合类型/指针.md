# 一. 简介

**指针**（pointer）是 “指向” 另外一种类型的复合类型，指针所指的类型必须满足某些条件。指针和引用类似，也实现了对其他对象的间接访问。同时指针和引用也有很多不同点：

1. 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的声明周期内它可以先后指向几个不同的对象。
2. 指针无须在定义时赋初值。和其他内置类型一样，如果在块作用域内定义的指针没有被初始化，也将拥有一个不确定的值。



# 二. 指针的定义

声明一个指针同样是`类型说明符 + 声明符列表`，指针的声明符是一个`*`符号加上指针的名字，和引用相同，如果是一个声明符列表，每一个声明符都需要加上`*`符号，如果某个声明符不加，那么它的类型就是`类型说明符`的类型。

```c++
int ival1, ival2;
int *ip1, *ip2 = &ival2;
```

可以作为指针类型变量的右值的有：

- 对象的地址：即通过`&`符加上对象名可以获取对象的地址，如：`&ival2`（需要注意的是**指针的类型必须和右值对象的类型相同**）
- 另一个指针对象：一个相同类型（有两种例外情况）的指针对象也可以作为指针类型的右值。（注意此时不添加`&`符号，否则该右值的意义是获取该指针对象的地址，而不是指针对象所保存的值）
- 指针常量：如`nullptr`等

一个指针的值应该属于下列 4 中状态之一：

1. 指向一个对象
2. 指向紧邻对象所占空间的下一个位置
3. 空指针，意味着指针没有指向任何对象
4. 无效指针，即上述情况之外的其他值，试图拷贝或以其他方式访问无效指针的值都将引发错误。



# 三. 使用指针

## 1. 访问指针指向对象

如果指针指向了一个对象，则允许使用**解引用符**（`*`操作符）来访问该对象：

```c++
int ival = 42;
int *p = &ival;
cout << *p;
*p = 0;
```

上例将输出`ival`的值 42，而不是指针`p`的值（`ival`的地址）；以及是将`ival`值改为 0，而不是将`p`的值改为 0。

如果想要修改指针的值（即指针的指向），则直接使用指针的名字而不添加`*`操作符，如：

```c++
int ival2 = 32;
p = &ival2;
```

将`p`修改为指向`ival2`，需要注意：`ival`的值和地址都没有改变，改变的只有`p`的值，即`p`的指向。



## 2. 指针比较

若**两个指针类型相同且为合法指针**，则两个指针可以使用`==`或`!=`操作符进行比较。

如果两个指针存放的地址值相同，则它们相等；反之它们不相等。

如：

```c++
int ival1, ival2;
int *pi1 = &ival1;
int *pi2 = &ival2;
int *pi = &ival1;

pi == pi1;		// 返回 true
pi != pi2; 		// 返回 true
```





# 四. 复杂指针类型

## 1. 空类型指针

`void *`是一种特殊的指针类型，可用于存放任意对象的地址。

`void *`指针只能进行下面的操作：和别的指针比较、作为函数的输入或输出、赋值给另一个`void *`指针。不能直接操作`void *`指针所指的对象。

也就是说，以`void *`的视角来看内存空间就仅仅是内存空间，没办法访问内存空间中所存的对象。



## 2. 指向指针的指针

添加`*`的个数可以区分指针的级别。也就是说，`**`表示指向指针的指针，`***`表示指向指向指针的指针的指针，如下所示：

```c++
int ival = 1024;
int *pi = &ival;
int **ppi = &pi;
```

