# 一. 简介

**数组**用于声明一个包含多个相同类型元素的容器，所有元素所使用的内存是连续的，可以用`[]`进行下标访问，同时在声明时也需要使用该符号。

需要注意的是：数组的大小是固定的，一旦创建了数组，就无法修改数组的大小。

数组的元素类型几乎可以是任何类型，但**不能是引用类型**，因为数组的元素必须是对象。



# 二. 数组的定义

## 1. 一般数组

数组的声明形式是：`类型说明符 + 声明符`。这个形式和另外的类型声明形式都相同，但其声明符有不同，数组的声明符形式如下：`数组名[元素个数]`，其中`元素个数`和`类型说明符`共同决定了数组的大小。

另外，元素个数必须是一个常量表达式，如：

```c++
unsigned cnt = 42;
constexpr unsigned sz = 42;
int arr[10];		// 正确，含有 10 个整数的数组
int *parr[sz];		// 正确，含有 42 个整型指针的数组
string bad[cnt];	// 错误，cnt 不是常量表达式
```

**注意**：默认情况下，数组的元素被默认初始化

数组可以使用列表进行初始化，如：

```c++
int ial[3] = {0, 1, 2};		// 包含 3 个元素，元素值分别是 0, 1, 2
int a2[] = {0, 1, 2};		// 包含 3 个元素
int a3[5] = {0, 1, 2};		// 包含 5 个元素，元素值分别是 0, 1, 2, 0, 0
int a5[2] = {0, 1, 2};		// 错误：初始值过多
```



## 2. 多维数组

C++ 中不存在多维数组的类型，所谓的多维数组，实际上是数组的数组，其定义方法如下：

```c++
int arr[10][42];
```

其中`arr`就是一个所谓的二维数组，`arr`包含 10 个元素，每个元素都是一个包含 42 个整型数值的数组。

多维数组的初始化允许使用花括号括起来的一组值初始化多维数组，这点和普通的数组一样。下面的初始化形式中，多维数组的每一行分别用花括号括了起来：

```c++
int ia[3][4] = {
    {0, 1, 2, 3},
    {4, 5, 6, 7},
    {8, 9, 10, 11}
};
```

这种内层嵌套的花括号并非必需的，也可以将多维数组当作一维数组进行初始化，如：

```c++
int ia[3][4] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};
```

这和上一个初始化语句完全相同。

使用内层嵌套的花括号与不使用该形式的初始化不同在于：首先从观感上更清晰，其次是对于没提供所有元素的初始值来说，内层的花括号能够约定范围：

```c++
int ia[3][4] = {{0}, {4}, {8}}；
```

上面的初始化语句将每行的首元素初始化，其他未列出的元素执行值初始化。这种情况下如果省略内层的花括号，其意义就发生了改变：

```c++
int ia[3][4] = {0, 4, 8};
```

这一条语句表示初始化第一行的前三个元素，其余所有元素执行值初始化。



## 3.字符串

字符的数组再加上一个空字符`'\0'`即构成字符串，严格来说是 C 风格字符串。

可以使用一般数组的初始化方式初始化字符数组，如：

```c++
char a1[] = {'C', '+', '+'};
```

`a1`中包含 3 个字符，需要注意的是此时的`a1`并不是一个字符串，而只是一个单纯的字符数组，如果要创建一个字符串，还需要添加一个`'\0'`，如：

```c++
char a2[] = {'C', '+', '+', '\0'};
```

`a2`中包含 4 个字符，包括末尾的`'\0'`字符，是一个字符串，另外，字符串还有另外一种初始化方式：

```c++
char a3[] = "C++";
```

`a3`与`a2`包含相同的元素，都是 4 个字符。

需要注意的是，如果我们指定了字符数组的元素个数，但是在初始化时提供的初始值超过需要个数，会引发错误，如：

```c++
char a4[6] = "Daniel";
```

此例中，由于没有位置存放`'\0'`字符，所以产生错误。



# 三. 使用数组

## 1. 不允许拷贝和赋值

不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值：

```c++
int a[] = {0, 1, 2};
int a2[] = a;		// 错误
a2 = a;			// 错误
```



## 2. 访问数组元素

访问数组元素可以通过下标进行访问，数组的下标类型是`size_t`类型，定义在`<cstddef>`头文件中，如：

```c++
constexpr size_t size = 10;
int arr[size];
for (size_t i = 0; i < size; i++) {
    arr[i] = i + 1;
}
```

**注意**：使用下标时需要时刻检查下标的值。



## 3. 指针与数组

### 数组名和指针

指针与数组的联系非常紧密，在很多时候，数组名将会被转换为指向其元素类型的指针类型（顶层`const`），如：

```c++
string nums[] = {"one", "two", "three"};
string *p2 = nums;	// 等价于 string *p2 = &nums[0];
```

**注意**：不要把指向数组的指针和指向数组元素的指针搞混了，下面的这个例子将创建一个指向数组的指针而不是指向数组元素的指针：

```c++
string (*pa)[3] = &nums;
```

此时，作为初始值的数组名必须添加`&`符，表示对数组整体取地址。

总的说来，也就是要区分`&nums[n]`和`&nums`的区别，当`n`等于 0 时，二者虽然指向相同的地址，但是对于它们的解释却不同，也就是指针的类型不同。

**注意**：数组名作为初始值将给予被初始化对象一个非顶层`const`的指针，但是如果要将数组名本身作为一个指针使用，请注意它是一个具有顶层`const`的指针，即无法更改数组名的指向。

### 指针作为迭代器

我们可以像使用一个迭代器一样使用一个指向数组元素的指针，指针允许所有迭代器本身的操作和`vector`以及`string`支持的额外的操作。

用来充当迭代器的指针可以人工计算来获取，如：

```c++
int arr[10];
int *pbegin = arr;		// 指向第一个元素的指针
int *pend = &arr[10];		// 尾后指针
```

也可以使用`<iterator>`标准库提供的函数获取，如：

```c++
int arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
int *pbegin = std::begin(arr);
int *pend = std::end(arr);
```

然后就可以将获取的指针当作迭代器一样使用了。

### 下标和指针

在一些场景，数组名会转换为指向其元素类型的指针。反过来我们也可以将一个指针当作一个数组名使用，如：

```c++
int ia[] = {0, 2, 4, 6, 8};
int *p = ia;
p[4] = 0;		// 等价于 ia[4] = 0
```

需要注意的是，我们将一个指针当作数组使用，必须确保我们访问的地址是一个有效地址。

### 指针差与下标类型

与`vector`和`string`等标准库类型相比，指针和数组下标的一些地方和标准库不同。

首先指向同一数组两个元素的指针之差的类型应该是：`ptrdiff_t`类型，定义在`<cstddef>`头文件中；

另外，对于数组的下标类型`size_t`，和标准库的下标类型`className::size_type`不同：标准库的下标类型必须是无符号类型，但数组的下标类型可以处理负值，如：

```c++
int ia[] = {0, 2, 4, 6, 8};
int *p = &ia[2];
int k = p[-2];		// 访问 ia[0]
```



## 4. C 风格字符串

操纵 C 风格字符串并不像操纵`string`对象那么轻松，我们可以使用`<cstring>`头文件提供的几个函数来操纵 C 风格字符串：

| 函数                                                       | 效果                                                         |
| ---------------------------------------------------------- | ------------------------------------------------------------ |
| `strlen(p)`（`p`是一个字符串，其表现形式为指向字符的指针） | 返回`p`的长度，空字符不计算在内                              |
| `strcmp(p1, p2)`                                           | 比较`p1`和`p2`的相等性。如果`p1==p2`，返回 0；如果`p1>p2`，返回一个正值；如果`p1<p2`，返回一个负值 |
| `strcat(p1, p2)`                                           | 将`p2`附加到`p1`之后，返回`p1`                               |
| `strcpy(p1, p2)`                                           | 将`p2`拷贝给`p1`，返回`p1`                                   |



## 5. 数组与 string 对象的接口

### C 风格字符串转换为 string 对象

主要按照下面的原则进行转换：

- 允许使用以空字符结束的字符数组（字符串字面值也属于该类）来初始化`string`对象或为`string`对象赋值
- 在`string`对象的加法运算中允许使用以空字符结束的字符数组作为**其中一个**运算对象（不能两个运算对象都是）；在`string`对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象。

### string 对象转换为 C 风格字符串

如果程序的某处需要一个 C 风格字符串，无法直接用`string`对象来代替它。例如，不能用`string`对象直接初始化指向字符的指针。

为了完成该功能，`string`提供了一个名为`c_str`的成员函数，它返回一个`const char *`类型的指针，可以像下面这样使用：

```c++
string s("Hello World");
const char *str = s.c_str();
```

需要注意的是：我们无法保证`c_str()`函数返回的数组一直有效，事实上，如果后续的操作改变了`s`的值就可能让之前返回的数组失去效用。



## 6. 数组与 vector 对象的接口

在初始化`vector`时，可以使用数组对`vector`对象进行初始化，具体办法是提供两个指向同一数组元素的指针，如下所示：

```c++
int int_arr[] = {0, 1, 2, 3, 4, 5};
std::vector<int> ivec(std::begin(int_arr), std::end(int_arr));
```

当然，用于初始化`vector`对象的值也可能仅是数组的一部分：

```c++
std::vector<int> subVec(int_arr + 1, int_arr + 4);
```

这条语句将用`int_arr[1]`、`int_arr[2]`、`int_arr[3]`这三个元素初始化`subVec`，注意：不包含`int_arr[4]`。



## 7. 多维数组

对于多维数组来说，我们给定的下标可以小于数组的维数，如：

```c++
int arr[3][4][5];
int i = arr[0][0][0];
int *pi = arr[1][2];
int (*ppi)[5] = arr[2];
int （*pppi)[4][5] = arr;
```

- `arr[0][0][0]`是一个`int`类型值
- `arr[1][2]`是一个`int`类型的数组，包含 5 个元素，可转换为`int*`类型的指针
- `arr[2]`是一个数组，包含 4 个元素，其每一个元素都是一个`int[5]`类型的数组，可转换为`int (*)[5]`类型的指针
- `arr`是一个数组，包含 3 个元素，其每一个元素都是一个`int[4][5]`类型的数组，可转换为`int (*)[4][5]`类型的指针

需要注意的是，**多维数组的指针**不是单纯的指针的指针以及指向指针的指针的指针，而**是指向数组的指针**。



# 四. 复杂数组类型

## 1. 指针数组和数组指针

一个指针数组（元素为指针的数组）声明如下：

```c++
int *arr[10];
```

而一个数组指针（数组的指针）声明如下：

```c++
int (*parr)[10];
```



## 2. 数组引用

数组引用的声明形式如下：

```c++
int arr[10];
int (&rarr)[10] = arr;		// 注意必须初始化
```

**注意**：不能按下面的形式声明数组引用：

```c++
int &rarr[10];
```

该声明的意图是创建一个引用的数组，但是不存在引用的数组



## 3. 指针与引用的复合数组

声明一个指针数组的引用：

```c++
int *arr[10];
int *(&rarr)[10] = arr;
```

声明一个数组指针的引用：

```c++
int (*parr)[10];
int (*(&rpa))[10] = parr;
```



# 五. 注意

在很多情况下，我们可以将一个指向数组首元素的指针当作一个数组来使用，比如下标访问等操作。

但需要牢记的是，**一个指向数组首元素的指针并不是一个数组类型**，即使数组可以向下退化成这种指针类型，但是这种指针类型并不能向上升为指针类型。

在很多情况下，我们都在使用指向数组首元素的指针而不是一个数组，比如：将数组赋值给一个指向其元素类型的指针后（元素指针类型参数传递、元素指针类型函数返回）、动态数组等。

在我们把一个指向数组首元素的指针当作数组使用时，必须注意下面几点：

- 不能对其调用`begin`或`end`。

- 不能使用范围`for`语句来处理其元素

- 最好将这个指针设置为常量指针（顶层`const`），因为当数组退化成指向其元素的指针类型时就是常量指针，我们不能修改这个指针的指向（这是当然的）。

  当然，为了应对更加灵活的情况，这种指针也可以设置为非常量的指针，但需要时刻注意我们到底是在使用一个数组还是在使用一个指针。特别是在使用动态数组的时候，我们需要注意我们的数组是否还有其他方式访问而不至于无法释放内存；以及在使用函数传递的时候，我们需要保证在函数中是否还需要访问这个数组，在需要访问的时候是否还能访问到这个数组，当这些都能保证的时候才能去改变这个指针的指向。

  当然，在没有特殊使用要求的情况下，我们还是将这个指针设置为常量指针最好
