# 一. 简介

有时我们希望定义这样一种变量，它的值不能被改变。例如，用一个变量来表示缓冲区的大小。使用变量的好处是当我们觉得缓冲区大小不再合适时，很容易对其进行调整。。另一方面，也应随时警惕防止程序一不小心改变了这个值。为了满足这一要求，可以用关键字`const`对变量的类型加以限定：

```c++
const int bufSize = 512;
```

这样就把`bufSize`定义成了一个常量，任何试图为`bufSize`赋值的行为都将引发错误。

因为`const`对象一旦创建后其值就不能再改变，所以`const`对象必须初始化。初始值可以是任意复杂的表达式：

```c++
const int i = get_size();
const int j = 42;
```

当以编译时初始化的方式定义一个`const`对象时，编译器将在编译过程中把用到该变量的地方都替换成对应的值，这一操作与宏定义类似。

另外，在默认状态下，`const`**对象仅在文件内有效，即不具有外部链接属性**。如果希望`const`对象拥有外部链接属性，能够被其他文件访问，解决办法是对于`const`变量不管是声明还是定义都添加`extern`关键字，包含初始化的那条声明是定义，在定义语句中的`extern`表示为对象添加外部链接属性，在声明语句中的`extern`表示使用其他文件定义的实体。



# 二. 引用与 const

## 1. 基本形式

可以把引用绑定到`const`对象上，就像绑定到其他对象上一样，我们称之为**对常量的引用**。如：

```c++
const int ci = 1024;
const int &r1 = ci;
```

由于引用实际上是为一个对象取了另外一个名字，所以我们不能通过引用修改被引用对象的值。



## 2. 引用可绑定的对象

另外，在一个引用初始化以及赋值时涉及到引用类型和被引用对象的类型，二者都可能是`const`类型，所以一条初始化有 4 种可能的形式：

```c++
int ival = 24;
const int ci = 1024;

int &ri = ival;		// 1
int &ri = ci;		// 2
const int &rci = ival;	// 3
const int &rci = ci;	// 4
```

其中可行的只有其中 3 种：1、3、4

即：

- 非常量引用只能绑定非常量对象
- 常量引用可以绑定任意对象



## 3. 引用绑定一般表达式

对于一个`const`引用来说，可以将一个一般表达式甚至一个其他类型的对象绑定，如：

```c++
int i = 42;
const int &r1 = i;			// 其他类型对象
const int &r2 = 42;			// 一般表达式
const int &r3 = r1 * 2;			// 一般表达式

double dval = 3.14;
const int &ri = dval;			// 其他类型对象
```

这二者实际是相同的原理：编译器在编译时会添加一个临时的中间量，以`const int &ri = dval;`为例：

```c++
const int temp = dval;		// 首先由双精度浮点数生成一个临时的整型常量
const int &ri = temp;		// 将 ri 与相同类型的 temp 相绑定
```

至于为常量引用绑定一般表达式或其他类型的意义在于函数传递参数时的一些提升。



# 三. 指针与 const

## 1. 基本形式

指针本身是一个对象，所以指针本身也可能存在`const`属性，而指针所指的对象也是实体，所以也可能存在`const`属性。所以一个指针可能有下面 4 种类型：

```c++
int *pi;		// 指向非常量对象的非常量指针
const int *cpi;		// 指向常量对象的非常量指针
int *const pci;		// 指向非常量对象的常量指针
const int *const cpci;	// 指向常量对象的常量指针
```

指向常量对象的指针无法通过指针修改所指对象的值，而常量指针无法修改其指向。如果二者兼具，则两个特性都应该具备。



## 2. 顶层与底层 const

指针本身是一个对象，它又可以指向另外一个对象。这二者都可以有常量类型修饰，我们用下面的概念来区分二者：

- **顶层 const**：表示指针本身是个常量
- **底层 const**：表示指针所指的对象是一个常量

这两个概念可以扩展到更一般的场景，顶层 const 可以表示任意的对象是常量，这一点对任何具有实体的数据类型都适用，如算术类型、类、指针等。底层 const 则与指针和引用等复合类型的基本类型部分有关。

当执行对象的拷贝操作时，常量是顶层 const 还是底层 const 区别明显。其中，顶层 const 不受什么影响，因为执行拷贝操作并不会改变被拷贝对象的值，因此，拷入和拷出的对象是否是常量都没什么影响。另一方面，底层 const 的限制却不能忽略。当执行对象的拷贝操作时，考入和拷出的对象必须具有相同的底层 const 资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换为常量，反之则不行。

**注意**：上述拷贝操作的限制**不适用于引用类型**，请不要在理解引用的拷贝操作上浪费时间。原因是**引用的初始化并非拷贝操作**。也就是说，存在底层 const 限制的拷贝操作只有指针的拷贝操作。