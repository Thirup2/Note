# 一. 调用过程

定义了一组重载函数后，我们需要以合理的实参调用它们。

而根据实参将函数调用与一组重载函数中的某一个关联起来，这个过程就叫做**函数匹配**（function matching），或者**重载确定**（overload resolution）。

编译器首先将调用的实参与重载集合中的每一个函数的形参进行比较，然后根据比较的结果决定到底调用哪个函数。

大多数情况下，函数匹配比较容易，但是在另外一些情况下要选择函数就比较困难了，比如当两个重载函数参数数量相同且参数类型可以相互转换时。

而调用重载函数时用三种可能的结果：

- **最佳匹配**（best match）：编译器找到一个与实参最佳匹配的函数，并生成调用该函数的代码
- **无匹配**（no match）：找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配的错误信息
- **二义性调用**（ambiguous call）：有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也将发生错误，称为二义性调用。

在这三种调用结果中，二义性调用应该是我们在定义重载的阶段就应该避免的，我们应该尽力避免有二义性调用的可能。



# 二. 函数匹配

函数匹配的整个过程有以下几个步骤：

1. 第一步是选定本次调用对应的重载函数集，集合中的函数称为**候选函数**（candidate function）。

   候选函数具有两个特征：一是与被调用的函数同名，二是其声明在调用点可见

2. 第二步是考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为**可行函数**（viable function）。

   可行函数也有两个特征：一是其形参数量与本次调用提供的实参数量相等（有默认实参的函数只要其未被赋予默认实参的形参都拥有实参值也算），二是每个实参的类型与对应的形参类型相同，或者能转换成形参的类型

   如果没找到可行函数，编译器将报告无匹配函数的错误。

3. 第三步是从可行函数中选择与本次调用最匹配的函数（如果有的话）

以上步骤中，最主要的就是第三步寻找最佳匹配。

## 寻找最佳匹配

寻找最佳匹配主要是要比较两个内容：

- 该函数每个实参的匹配都不劣于其他可行函数需要的匹配
- 至少有一个实参的匹配优于其他可行函数提供的匹配

如果在检查了所有实参之后没有任何一个函数脱颖而出，则该调用是错误的，编译器将报告二义性调用的信息。

****

为了确定最佳匹配，编译器将实参类型到形参类型的转换划分为几个等级，具体排序如下所示：

**转换等级**：

1. 精确匹配，包括以下情况：
   - 实参类型和形参类型相同
   - 实参从数组类型或函数类型转换成对应的指针类型
   - 向实参添加顶层`const`或者从实参中删除顶层`const`
2. 通过`const`转换实现的匹配（不具有`const`性质的类型转换为具有底层`const`类型）
3. 通过类型提升实现的匹配
4. 通过算术类型转换或指针转换实现的匹配
5. 通过类类型转换实现的匹配

****

**警惕类型提升**：

类型提升往往是我们比较不容易注意到的会自动发生的类型转换。

假设有两个函数：

```c++
void ff(int);
void ff(short);
```

然后这样调用这组重载函数：

```c++
ff('a');
```

由于`'a'`是`char`类型的字面值，程序首先查找有没有接受一个`char`类型的函数；

由于没有，所以`char`进行提升，成为`int`类型，然后与`void ff(int)`函数匹配

****

**所有算术类型转换的级别都一样**：

从`int`向`unsigned int`的转换并不比从`int`向`double`的转换级别高，如：

```c++
void manip(long);
void manip(float);
```

然后如下调用：

```c++
manip(3.14);
```

可能会误以为接受`float`类型参数的函数更匹配，但事实上二者的匹配度相同，所以调用具有二义性。

