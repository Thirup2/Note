# 一. 前提

定义重载函数有几个前提：

- 多个被重载的函数应该在**同一作用域**（定义在内层作用域的函数会覆盖掉外层作用域所有同名函数）
- 被重载函数名字应该相同
- 被重载函数的参数列表不同

满足这样的前提条件下定义的多个函数就是**重载函数**（overloaded function），例如：

```c++
void print(const char *cp);
void print(const int *beg, const int *end);
void print(const int ia[], size_t size);
```

这样的几个函数就是重载函数，这些函数接受的形参类型不一样，但是执行的操作非常类似。当调用这些函数时，编译器会根据传递的实参类型推断想要的是哪个函数。

需要注意的是：`main`函数不能重载。



# 二. 定义重载函数

定义重载函数时还有一项注意点：不允许两个函数除了返回类型外其他所有的要素都相同。

意思是返回类型可以不同，但实际上返回类型并不影响函数匹配的判断，所以如果只有返回类型不同，是无法得到最匹配的函数的。所以不论返回类型是否相同，每个函数在形参列表上都应该有所区别。

如：

```c++
Record lookup(const Account &);
bool lookup(const Account &);
```

这样的两个重载函数就是错误的，它们形参列表完全相同，无法进行函数匹配。

****

**判断两个形参的类型是否相异**：

在定义重载函数时就需要注意两个形参的类型是否不同，如：

```c++
Record lookup(const Account &acct);
Record lookup(const Account &);
```

由于我们**只在意形参类型**，所以上面两个重载函数形参类型相同。还有：

```c++
typedef Phone Telno;
Record lookup(const Phone&);
Record lookup(const Telno&);
```

我们在判断两个形参类型是否相同时应该**将类型完全展开**进行判断，所以上面两个形参类型相同。

另外，对于**只有顶层`const`性质的区别的形参，我们认为两个形参是同一种类型**，如：

```c++
Record lookup(Phone);
Record lookup(const Phone);

Record lookup(Phone*);
Record lookup(Phone* const);
```

而对于**具有底层`const`性质的区别的形参，我们认为两个形参是不同类型**，如：

```c++
Record lookup(Account &);
Record lookup(const Account &);

Record lookup(Account *);
Record lookup(const Account *);
```

对于常量实参，只能与具有底层`const`的形参匹配；而非常量实参，虽然能与任何类型的形参匹配，但优先与不具有底层`const`的形参匹配。



# 三. const_cast与重载

某些情况下，我们需要用到`const_cast`进行重载，如：

首先我们实现了一个函数：

```c++
const string &shorterString(const string &s1, const string &s2)
{
    return s1.size() <= s2.size() ? s1 : s2;
}
```

这个函数可以对于非常量的实参也可以接受，但是会返回一个常量的引用，如果我们想函数在接收两个非常量形参时可以返回一个非常量的引用，我们可以重新单独实现下面的函数：

```c++
string &shorterString(string &s1, string &s2)
{
    return s1.size() <= s2.size() ? s1 : s2;
}
```

但如果是重新实现，对于这个只有一条语句的函数还好说，但是如果一个函数很长，重写起来既麻烦又容易出错，此时需要复用原有的那个函数就需要用到`const_cast`，如：

```c++
string &shorterString(string &s1, string &s2)
{
    auto &r = shorterString(const_cast<const string&>(s1), const_cast<const string &>(s2));
    return const_cast<string &>(r);
}
```

这样就可以了。