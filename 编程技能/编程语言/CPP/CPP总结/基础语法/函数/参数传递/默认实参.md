# 一. 简介

C++ 允许在函数第一次声明时（可能是定义）为其形参赋予默认值，称为**默认实参**（default argument）。

如：

```c++
typedef string::size_type sz;
string screen(sz ht = 24, sz wid = 80, char backgrnd = ' ');
```

在函数调用时，如果不提供参数，将使用默认实参作为值。

****

函数只能从形参列表的最后开始依次往前为形参赋予默认实参，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。

如：

```c++
string screen(sz ht, sz wid = 80, char backgrnd = ' ');		// 正确
string screen(sz ht, sz wid = 80, char backgrnd);		// 错误
```

****

另外，函数可以多次声明，在后续声明时不能为已经赋予过默认实参的形参多次赋予默认实参，但可以为没有赋予过默认实参的形参赋予默认实参，顺序和之前一样，需要从后面往前面赋予，如：

```c++
string screen(sz, sz, char = ' ');

string screen(sz, sz, char = '*');		// 错误：试图修改已经存在的默认值
string screen(sz = 24, sz, char);		// 错误：顺序错误，应该从第二个参数开始添加默认实参
string screen(sz = 24, sz = 80, char);		// 正确
```

****

**默认实参初始值**：

可以作为默认实参的值不能是局部变量。

除此之外，只要表达式的类型能够转换成形参所需的类型，该表达式就能作为默认实参。

如果添加默认实参时使用的是表达式，那么需要注意：用作默认实参的名字在函数声明所在的作用域内解析，而这些**名字的求值过程发生在函数调用时**：

```c++
sz wd = 80;
char def = ' ';
sz ht();
string screen(sz = ht(), sz = wd, char = def);
```

在这种情况下，如果直接调用`screen`函数，那么实际的调用就相当于：`screen(ht(), 80, ' ')`

而如果像下面这样调用：

```c++
void f2()
{
    def = '*';			// 全局变量中的 def
    sz wd = 100;		// 新的局部变量 wd
    window = screen();		// 将调用 screen(ht(), 80, '*')
}
```

首先`def`修改了声明中提供默认实参的变量的值，由于在调用时才求值，所以，实际调用时`def`被修改为了`'*'`；

而`wd`虽然有一个新的局部变量，但是它并不是用于函数声明的那个变量，所以即使在调用时才求值，但由于新的变量并不是声明处所用的变量，所以没有影响。



# 二. 调用函数

调用具有默认实参的函数时，如果函数的每个形参都有默认实参，那么可以不再提供实参；

如果函数只有部分有默认实参（肯定是覆盖了整个后半部分的），那么至少需要为前面几个没有默认实参的形参提供实参；

如果想要覆盖某个已有默认实参的形参的实参值，那么需要**从第一个形参开始依次为形参添加实参**，不能只覆盖中间某个形参的默认实参（在语义上也无法实现）。