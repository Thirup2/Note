# 一. 命名的强制类型转换

一个命名的强制类型转换具有如下形式：
```c++
cast-name<type>(expression);
```

其中`cast-name`就是使用的类型转换名，`type`是转换的目标类型，而`expression`是要转换的值。如果`type`是引用类型，则结果是左值。

## 1. static_cast

`static_cast`用于任何具有明确定义的类型转换（即转换时执行的操作已定义，如`float`转换为`int`），只要不包含底层`const`，都可以使用`static_cast`。

****

如将一个运算对象强制转换成`double`类型用以执行浮点数除法：

```c++
int a, b;
cin >> a >> b;
double slope = static_cast<double>(j) / i;
```

如主要用于将较大算术类型转换为较小算术类型，用以取消警告信息：

```c++
double a;
int b;
cin >> a;
b = static_cast<int>(a);
```

也可以将`void *`指针转换为任意类型的指针：

```c++
void *p = &d;
double *dp = static_cast<double *>(p);		// 注意：我们必须确保 p 指向的类型与转换后的类型相同，否则将产生未定义的后果
```



## 2. const_cast

`const_cast`只能用于改变（去除或增加）运算对象的**底层**`const`性质，去掉`const`性质之后，就可以对该对象进行写操作了。

如果对象本身不是一个常量，使用强制类型转换获得写权限是合法的行为；而如果一个对象是一个常量，再使用`const_cast`执行写操作就会产生未定义的后果。（根据这条规定，我们可以看出`const_cast`的原本用意并不是让我们用在一般使用中改变常量的底层`const`性质，而是在有函数重载的上下文中使用）

****

用例如下：

```c++
const char *pc;
char *p = const_cast<char *>(pc);		// 正确，但是通过 p 写值是未定义的行为
```

**注意**：

1. 只能用于具有底层`const`的指针或引用，而不能用于具有顶层`const`的对象
2. `const_cast`只能用于改变底层`const`性质，而不能改变其类型

****

`const_cast`的用意是用于有函数重载的上下文中，如下所示：

```c++
const string &shorterString(const string &s1, const string &s2)
{
    return s1.size() <= s2.size() ? s1 : s2;
}
const string &shorterString(string &s1, string &s2)
{
    auto &r = shorterString(const_cast<const string&>(s1), const_cast<const string&>(s2));
    return const_cast<string&>(r);
}
```



## 3. reinterpret_cast

`reinterpret_cast`通常为运算对象的位模式提供较低层次上的重新解释（与`static_cast`相反，即语言未定义转换时操作的转换类型，如指向`int`的指针转换为指向`char`的指针，这种转换是非常危险的）。

****

如：

```c++
int *ip;
char *pc = reinterpret_cast<char *>(ip);
```

该例将一个指向`int`的指针`ip`解释成了指向`char`的指针并赋值给`pc`，这种操作可能是为了完成某种特殊的要求。

需要注意的是，如果想要不发生错误，就要牢记`pc`虽然是一个指向`char`的指针，但是它实际上原本是一个指向`int`的指针，假设`pc`的值为`0x0010`（单位为字节）、`int`的大小为 4 字节，那么`pc`可用的有效范围应该是`0x0010`到`0x0014`。如果试图访问这个有效范围外的数据，程序就可能产生异常，如：

```c++
string str(pc);			// 用字符指针指向的 C 风格字符串初始化 string 对象
```

此时，如果在有效范围内没有遇到`'\0'`，那么就会开始访问有效范围外的内容。



## 4. dynamic_cast



# 二. 旧式的强制类型转换

****

**形式**：

在早期版本的 C++ 语言中，显式地进行强制类型转换包含两种形式：

```c++
type (expr);
(type) expr;
```

这两者的效果相同

****

**作用**：

根据所涉及的类型不同，旧式的强制类型转换分别具有与`const_cast`、`static_cast`或`reinterpret_cast`相似的行为。

当我们在某处执行旧式的强制类型转换时，如果换成`const_cast`和`static_cast`也合法，则其行为与对应的命名转换一致。

如果替换后不合法，则旧式强制类型转换执行与`reinterpret_cast`类似的功能，如：`char *pc = (char *) ip;`

****

**缺点**：

与命名的强制类型转换相比，旧式的强制类型转换从表现形式上来说不那么清晰明了，容易被看漏，所以一旦转换过程出现问题，追踪起来也更加困难。