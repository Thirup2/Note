# 一. 算术转换

## 1. 发生情形

如果某个运算符的运算对象类型不一致，这些运算对象将转换成同一种类型（如果类型相同，则不进行任何转换操作）



## 2. 转换规则

1. 如果需要整型提升则首先执行**整型提升**

   > ## 注1：整型提升
   >
   > **发生情形**：
   >
   > - 所有小于`int`或`unsigned int`类型的对象将会提升（前提是某个运算符的两个运算对象类型不相同，若都为`short`或都为`char`类型等情况就不需要提升）
   > - 较大的`char`类型将会提升（前提是某个运算符的两个运算对象类型不相同）
   >
   > **转换规则**：
   >
   > 对于`bool`、`char`、`signed char`、`unsigned char`、`short`和`unsigned short`等类型来说，只要它们所有可能的值都能存在`int`里，它们就会提升成`int`类型；否则，提升成`unsigned int`类型
   >
   > 对于较大的`char`类型（`wchar_t`、`char16_t`、`char32_t`）提升成`int`、`unsigned int`、`long`、`unsigned long`、`long long`和`unsigned long long`中能容纳其数据的最小的一种类型。

   > ## 注2：布尔类型的提升
   >
   > - `true`：转换为 1
   > - `false`：转换为 0

2. 如果整型提升后两个运算对象的类型都是带符号的或都是无符号的，则**小类型的运算对象转换为较大的类型**

   > ## 注3：算术类型的大小
   >
   > 整型提升后且符号属性相同的算术类型的大小**从小到大**排列如下：
   >
   > **带符号类型**：
   >
   > - `int`
   > - `long`
   > - `long long`
   > - `float`
   > - `double`
   > - `long double`
   >
   > **无符号类型**：
   >
   > - `unsigned int`
   > - `unsigned long`
   > - `unsigned long long`
   > - `float`
   > - `double`
   > - `long double`

   > ## 注4：整数与浮点数之间的转换
   >
   > - 整数 $\longrightarrow$ 浮点：整数部分不变，小数部分记为 0。如果整数的二进制位数超过浮点类型的有效数字位数则可能损失精度。
   > - 浮点 $\longrightarrow$ 整数：只保留整数部分。如果整数部分大小超过目标整数类型大小可能产生截断。

3. 如果一个运算对象是无符号类型、另外一个运算对象是带符号类型，而且其中的无符号类型不小于带符号类型，那么**带符号的运算对象转换为该无符号类型**（如果带符号类型对象为负值，将带来**副作用**）

   > ## 注5：无符号与带符号的转换 & 整型的溢出
   >
   > - 无符号与有符号的转换
   >   - 有符号 $\longrightarrow$ 无符号：最终保存的数据是有符号值本身（非负数）或者加上该类型的可表示的数据个数（负数），如把 -32 (`signed char`) 转换为无符号则为 `-32 + 256 = 224`
   >   - 无符号 $\longrightarrow$ 有符号：若无符号数的数据在有符号数的范围内则直接保存，若无符号数的数据在有符号数的范围外则参考有符号数的溢出。
   > - 无符号与有符号的溢出
   >   - 无符号溢出：最终保存的数据是初始数据对无符号类型的大小取模，如把 256 赋给`unsigned char`则得到`256 % 255 = 1`
   >   - 有符号溢出：该结果是未定义的，程序可能继续工作、可能崩溃，也可能生成垃圾数据。

4. 如果一个运算对象是无符号类型、另外一个运算对象是带符号类型，而且其中的带符号类型大于无符号类型，此时**转换的结果依赖于机器**。

   如果无符号类型的所有值都能存在该带符号类型中，则无符号类型的运算对象转换为该带符号类型；

   如果不能，那么带符号类型的运算对象转换为该无符号类型。

   之所以说这步转换的结果依赖于机器是因为有些在逻辑上有大小关系的类型可能在实现上是相同大小，如`long`和`unsigned int`：如果二者的实现是相同大小，则`long`转换为`unsigned int`；如果`long`类型占用的空间比`int`多，则`unsigned int`类型的运算对象转换为`long`类型



## 3. 总结

在进行类型转换的时候，为确保程序的正确，最好不要让程序自己进行有符号整数与无符号整数之间的转换，即上一节的 3、4 部分。

在需要进行有符号整数和无符号整数的转换时，最好由程序员进行强制转换，且在强制转换前确保不会产生任何错误或已经做好接收错误的准备。



# 二. 其他隐式类型转换

## 1. 数组转换为指针

**发生情形**：在大多数用到数组的表达式中，数组自动转换为指向数组首元素的指针

**例外情况**：

1. 当数组被用作`decltype`关键字的参数时

2. 当数组作为取地址符（`&`）的对象时（注意是数组本身作为对象，写作表达式也就是：`&array`，而不是`&array[0]`，前者指向的是整个数组，如果对用该值初始化的指针执行`++`操作，则该指针应该向前移动 $n$ 个元素的位置，$n$ 为`array`的元素个数，同时用于指向该数组的指针应该写成`Type (*ptoa)[n] = &array`，而后者是`Type *ptot = &array[0]`等价于`Type *ptop = array`）

3. 当数组作为`sizeof`运算符的对象时

4. 当数组作为`typeid`运算符的对象时

5. 初始化数组的引用时的作为初始值的数组不会转换为指针

   ```c++
   int arr[10] = {};
   auto &rearr = arr;		// 此时 rearr 被推断为 int &[10] 类型，而不是 int *&
   ```



## 2. 指针的转换

- 常量整数值 0 或字面值`nullptr`能转换为任意指针类型
- 指向任意非常量的指针能转换为`void *`类型
- 指向任意对象的指针能转换成`const void *`类型
- 在有继承关系的类型间还有另外一种指针转换的方式



## 3. 转换为布尔类型

- 如果指针或算术类型的值为 0，转换为`false`
- 否则转换为`true`



## 4. 转换成常量

允许将指向非常量类型的指针转换成指向相应的常量类型的指针，对于引用有相同规则。

**注意**：相反的转换不存在，因为它试图删除掉底层`const`



## 5. 类类型定义的转换

类类型能定义由编译器自动执行的转换，不过编译器每次只能执行一种类类型的转换，如果同时提出多个转换请求，这些请求将被拒绝。

如在初始化`string`对象时使用 C 风格字符串：

```c++
string s = "a value";		// 将 C 风格字符串转换为 string 对象
```

如在条件部分读入`istream`：

```c++
int a;
while(cin >> a) {/* ... */}		// 将 istream 对象转换为 bool 值
```

