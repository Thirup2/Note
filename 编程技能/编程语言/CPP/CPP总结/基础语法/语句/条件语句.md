# 一. if语句

## 1. 单纯if语句

**语法**：

```c++
if (condition)
    statement;
```

其中`condition`是一个布尔表达式或是能转换成布尔值的表达式；

若该表达式为真则执行`statement`，否则跳过该`statement`。



## 2. if-else语句

**语法**：

```c++
if (condition)
    statement1;
else
    statement2;
```

其中`condition`的效果和前相同，但是当`condition`为假时，将进入`statement2`



## 3. if-else if语句

**语法**：

```c++
if (condition1)
    statement1;
else if (condition2)
    statement2;
/* ... */
else if (conditionx)
    statementx;
else
    statementend;
```

如果有多层条件则可以选择使用这种语句，它将按照顺序计算条件表达式，当遇到某个条件表达式为真时，就进入该分支，执行完对应的`statement`之后跳出整个`if`语句。

末尾的`else`分支如果确保前面的分支已经涵盖了所有情况，那么可以省略该分支。



## 4. 嵌套if语句

可以在`if`语句的任何分支里嵌套其他`if`语句：

```c++
if (condition1)
    if (subcondition1)
        statement1;
else
    if (subcondition2)
        statement2;
else
    statement3;
```

可以看到，我们在最外层的`if`语句中嵌套了另一个`if`语句，在下面的`else`分支里也嵌套了一个`if`语句。

可是在上面的例子中，最关键的不是嵌套`if`语句的逻辑，而是那两个`else`分别是和谁匹配的，这个问题通常称作**悬垂else**（dangling else）。

要解决这个问题就要知道：C++ 规定`else`与离它最近的尚未匹配的`if`匹配，所以上面的程序可以写成：

```c++
if (condition1) {
    if (subcondition1) {
        statement1;
    } else {
        if (subcondition2) {
            statement2;
        } else {
            statement3;
        }
    }
}
```

这样这个程序看起来就清晰多了，所以在使用到嵌套`if`语句时，最好在条件的右括号`)`和`else`后面都加上花括号。

另外，花括号的另一个作用是可以让`else`的匹配机制脱离 C++ 的规定，即自行控制执行路径，如：

```c++
if (condition1) {
    if (subcondition1) {
        statement1;
    }
} else {
    statement2;
}
```

在这个程序中`else`不与看上去最近的`if`语句匹配，而是与最外层的`if`语句匹配。



# 二. switch语句

概括来说，`switch`语句就是多层`if-else if`语句的另外一种实现形式。

**语法**：

```c++
switch (expr) {
    case label1:
        statements; /* 多条语句可以不用块聚合 */
    case label2:
        statements2;
    /* ... */
    case labeln:
        statementsn;
    default:
        statementsdefault;
}
```

其中`expr`必须是一个整数表达式，这是与`if`语句的区别；

当将`expr`输入给`switch`之后，`switch`将用它与每一个`case`后面的`label`进行比较，若遇到和`expr`值相同的`label`，则进入该分支，然后一直向下执行，**包括下面其他所有`case`里的语句，直到退出`switch`语句。**

其中`default`标签是当其上所有`case`都不与`expr`匹配时，将进入`default`标签下的语句。如果能确保上面所有`case`能够覆盖所有需要的情况，则`default`可以省略。

为了和多层`if-else if`语句的效果相同，**需要在每个`case`下的语句的最后添加一个`break`语句**，用于跳出`switch`语句。当然，如果要实现某些特殊的功能，也可以活用`switch`的效果和`break`语句，如：

```c++
unsigned vowelCnt = 0;
// ...
switch (ch) {
    case 'a':
    case 'e':
    case 'i':
    case 'o':
    case 'u':
        ++vowelCnt;
        break;
}
```

在上面的代码中，只要`ch`是元音字母，不管到底是五个中的哪一个都执行相同的代码。

****

**注意：switch 内部的变量定义**

`switch`的执行流程可能会跨过某些`case`标签。如果程序跳转到了某个特定的`case`，则`switch`结构中该`case`标签之前的部分会被忽略掉。这种忽略掉一部分的代码的行为引出了一个有趣的问题：**如果被略过的代码中含有变量的定义该怎么办？**

我们首先思考与之类似的`if`语句，它也会跳过一些分支，但是它不会出现相同的问题，这是因为`if`语句的每个分支都是独立的作用域，在其中定义的变量不会产生任何的歧义。

而`switch`语句首先它的分支并没有独立的作用域，其次是它的有效作用域应该是从与`expr`表达式匹配的`case`开始到`switch`结束，而不是整个`switch`，这就会产生问题。

这个问题的答案是：如果在某处一个带有初值的变量位于作用域之外，在另一处该变量位于作用域之内，则从前一处跳转到后一处的行为是非法行为，如：

```c++
switch (bool_val) {
    case true:
        string file_name;
        int ival = 0;
        int jval;
        break;
    case false:
        jval = next_num();
        if (file_name.empty())
            // ...
}
```

如果`bool_val`为`false`，那么将跳过`ival`的初始化过程以及另外两个变量的定义，但是对于`false`分支，`file_name`、`ival`、`jval`这三个名字都在作用域内，可以访问，所以在`false`分支下，将试图在尚未初始化的情况下使用它们，这是行不通的。

因此，C++ 规定：**不允许跨过变量的初始化语句直接跳转到该变量作用域的另一个位置**。

如果需要为某个`case`分支定义并初始化一个变量，我们应该把变量定义在块内，从而确保后面的所有`case`标签都在变量的作用域之外：

```c++
switch (bool_val) {
    case true:
        {
            string file_name = get_file_name();
            // ...
        }
        break;
    case false:
        if (file_name.empty())
            // ...
}
```

此时如果`switch`外层没有一个名为`file_name`的对象，程序也将会报错，但此时的错误是没有已定义的名为`file_name`的对象，而不是跳过了变量的定义。

