# 一. try语句块

**语法**：

```c++
try {
    program-statements;
} catch (exception-declaration) {
    handler-statements;
} catch (exception-declaration) {
    handler-statements;
} // ...
```

首先是`try`语句块的第一块，在这一块里，程序要执行一些需要异常处理的语句，程序需要在遇到异常时抛出（throw）**对应类型**的**标准异常临时量**（可能还需要初始值），被抛出的临时量会根据类型与下面的某一个`catch`子句匹配。

每一个`catch`子句后的圆括号里都需要有一条声明语句，但仅仅是声明（即只包含类型和名字），其中类型是 C++ 定义的标准异常类中的一种，名字任意。

当被抛出的临时量与某一个`catch`子句的声明语句中的类型相同时，被抛出的临时量就会用来初始化该`catch`声明的标准异常类型的名字，然后进入该`catch`子句的`handler-statements`，然后进行异常处理。

在执行完对应的异常处理语句后，程序的执行流将跳出整个`try`语句块。



# 二. throw表达式

**语法**：

```c++
throw runtime_error("Data must refer to same ISBN");
```

`throw`语句一般用在`try`语句块中（也可以不用），用于抛出错误并寻找对应的异常处理方案。

后面的`runtime_error`是一种标准异常类型，同时在使用该类型的时候，必须为对象提供`string`或 C 风格字符串充当的初始值并且不允许默认初始化。`throw`后的部分相当于创建了一个`runtime_error`类型的临时量，`throw`表达式会将其送到对应的`catch`子句的声明中充当初始值。

另外，也可以使用其他的标准异常类型，用于抛出不同的异常。对于某些标准异常类型，只允许进行默认初始化，除此之外的其他异常类型则只允许用`string`对象或 C 风格字符串初始化这些类型的对象而不允许默认初始化。



# 三. 标准异常

## 1. 标准异常类

C++ 标准库定义了一组异常类，用于报告标准库函数遇到的问题，它们分别定义在下面 4 个头文件中：

- `<exception>`头文件定义了最通用的异常类`std::exception`。它只报告异常的发生，不提供任何额外信息

- `<stdexcept>`头文件定义了几种常用的异常类，如下表所示：

  | 异常类                  | 异常描述                                       |
  | ----------------------- | ---------------------------------------------- |
  | `std::exception`        | 最常见的问题                                   |
  | `std::runtime_error`    | 只有在运行时才能检测出的问题                   |
  | `std::range_error`      | 运行时错误：生成的结果超出了有意义的值域范围   |
  | `std::overflow_error`   | 运行时错误：计算上溢                           |
  | `std::underflow_error`  | 运行时错误：计算下溢                           |
  | `std::logic_error`      | 程序逻辑错误                                   |
  | `std::domain_error`     | 逻辑错误：参数对应的结果值不存在               |
  | `std::invalid_argument` | 逻辑错误：无效参数                             |
  | `std::length_error`     | 逻辑错误：试图创建一个超出该类型最大长度的对象 |
  | `std::out_of_range`     | 逻辑错误：使用一个超出有效范围的值             |

- `<new>`头文件定义了`bad_alloc`异常类型

- `<type_info>`头文件定义了`bad_cast`异常类型



## 2. 操作

**构造函数**：

对于`exception`、`bad_alloc`、`bad_cast`对象来说，我们只能以默认初始化的方式初始化这几种对象，不允许为这些对象提供初始值；

对于其他的异常类型，必须使用`string`对象或者 C 风格字符串初始化这些类型的对象，但是不允许使用默认初始化的方式。当创建这类对象时，必须提供初始值，该初始值含有错误相关的信息。

**其他操作**：

除了**创建**、**拷贝**和**赋值**之外，所有的异常类型都有一个名为`what`的成员函数，该函数没有任何参数，返回值是一个指向 C 风格字符串的`const char *`。该字符串的目的是提供关于异常的一些文本信息。

对于有字符串初始值的异常类型来说，`what`返回该字符串；对于其他无初始值的异常类型来说，`what`返回的内容由编译器决定。



# 四. 案例

## 1. 案例

```c++
Sales_item item1, item2;
while (cin >> item1 >> item2) {
    try {
        if (item1.isbn() != item2.isbn())
            throw runtime_error("Data must refer to same ISBN");		// 抛出runtime_error异常
        cout << item1 + item2 << endl;
    } catch (runtime_error err) {						// runtime_error被这个catch子句接住用于初始化err
        cout << err.what()
             << "\nTry Again? Enter y or n" << endl;
        char c;
        cin >> c;
        if (!cin || c == 'n')
            break;
    }
}
```



## 2. 注意

在复杂系统中，程序在遇到抛出异常的代码前，其执行路径可能已经经过了多个`try`语句块。例如，一个`try`语句块可能调用了包含另一个`try`语句块的函数，新的`try`语句块可能调用了包含又一个`try`语句块的新函数，以此类推。

寻找处理代码的过程与函数的调用链刚好相反。当异常被抛出时，首先搜索抛出该异常的函数。如果没找到匹配的`catch`子句，终止该函数，并在调用该函数的函数中继续寻找。如果还是没有找到匹配的`catch`子句，这个新的函数也被终止，继续搜索调用它的函数。以此类推，沿着程序的执行路径逐层回退，直到找到适当类型的`catch`子句为止。

如果最终还是没能找到任何匹配的`catch`子句，程序转到名为 **terminate** 的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。

对于那些没有任何`try`语句块定义的异常，也按照类似的方式处理：毕竟，没有`try`语句块也就意味着没有匹配的`catch`子句。如果一段程序没有`try`语句块且发生了异常，系统会调用 **terminate** 函数并终止当前程序的执行。