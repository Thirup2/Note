# 一. 简介

访问控制是分离一个类的接口与实现的重要操作，类设计者可以随意修改接口实现而不影响用例代码，而类用户能够只了解接口就能使用一个类而不必在意其实施细节。

影响访问权限的部分有三个：访问说明符、类定义关键字、友元声明。



# 二. 访问说明符

- `public`：定义在`public`说明符之后到下一个说明符或类定义结束之前的成员在整个程序内可被访问，`public`成员定义类的接口
- `private`：定义在`private`说明符之后到下一个说明符或类定义结束之前的成员只能被类的成员函数访问，但是不能被使用该类的代码访问

一般来说，类的数据成员不需要用户了解，所以应该设置为`private`；类的所有构造函数应该是用户能使用的，所以应该是`public`；类的所有成员函数大部分应该是用户需要使用的，设置为`public`，当然可能还有一些成员函数是为了辅助其他函数而存在的，这一部分设置为`private`。



# 三. 类关键字

定义类的关键字有两个：`class`和`struct`。二者在语法上完全相同，主要区别只有以下的部分：

- `class`：在类的第一个访问说明符之前声明或定义的成员都是`private`的
- `struct`：在类的第一个访问说明符之前声明或定义的成员都是`public`的



# 四. 友元

## 1. 非成员函数友元

首先非成员函数一般是对用户可见的，但是由于其声明在类外，所以他不在类的作用域内，也就无法访问类中的`private`成员。

其解决方法就是**友元**，友元的使用方法如下：

- 首先需要在类内任意处（一般是类的开头或结尾统一声明）添加一条`friend 函数声明`这种格式的声明，其函数声明部分与类外函数的声明完全相同。之所以是任意位置，是因为友元声明不受访问说明符的限制。
- 然后仍然在类外进行与此前相同的函数声明或直接定义

需要注意的是：

- 友元的声明仅仅指定了非成员函数对类内成员的访问权限，其并非一个通常意义上的函数声明。所以如果要确保用户能够访问到这个非成员函数，必须在当前文件的类外再声明或直接定义该函数。
- 友元函数能定义在类的内部，这样的函数是隐式内联的

其格式如下：

```c++
class ClassName
{
    /* ... */
    friend RetType FunName(<Para-List>);
    /* ... */
}
RetType FunName(<Para-List>)
{
    /* 函数体 */
}
```



## 2. 类友元

有时在一个类中，某些功能需要访问另一个类的成员，很明显，在一般情况下，这是做不到的，所以就需要类友元。

假设现在有两个类，叫做`Class1`和`Class2`，现在`Class2`需要访问`Class1`中的成员，那么就需要在`Class1`中设置一个`Class2`的类友元，其格式如下：

```c++
class Class1
{
    /* ... */
    friend class Class2;
    /* ... */
};
```

这样，`Class2`就能顺利访问`Class1`的成员了。

另外，对于类`Class2`中定义的友元来说，看上去`Class1`有一个友元`Class2`，那么可能会认为`Class1`同时具有`Class2`中定义的友元，但事实上并非如此，**友元关系并不存在传递性**，所以`Class2`中的友元也并不能访问`Class1`中的成员。



## 3. 成员函数友元

如果使用类成员，那么对于友元类的每一个成员函数都能访问该类的成员，而成员函数友元则只将某个类中的一个成员函数作为友元，只有该成员函数能访问该类的成员。

对于成员函数友元来说，必须指定其作用域，其使用方法如下：

```c++
class Class1
{
    /* ... */
    friend RetType Class2::Function(<Para-List>);
    /* ... */
};
```

另外，要想另某个成员函数作为友元，必须按照以下结构来组织程序的结构：

- 首先定义`Class2`类，其中声明`Function`函数，但是不能定义它。在`Function`使用`Class1`的成员之前必须先声明`Class1`
- 接下来定义`Class1`，包括对于`Function`的友元声明
- 最后定义`Function`，此时它才可以使用`Class1`的成员

其大致结构如下：

```c++
class Class2
{
    /* ... */
    RetType Function(<Para-List>) <const>;					// 成员函数声明
    /* ... */
};
class Class1												  // Class1的声明与定义
{
    /* ... */
    friend Class2::Function(<Para-List>) <const>;			 // 成员函数友元声明
    /* ... */
};
RetType Class2::Function(<Para-List>) <const> {/* 函数体 */}   // 成员函数定义
```



## 4. 注意

### 1）重载函数与友元

对于重载函数，虽然其名字相同，但它们本质上是不同的函数，因此，如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明。

### 2）友元声明与作用域

对于类友元和非成员函数友元来说，他们的声明可以在友元声明之后；对于成员函数友元来说，它们的声明必须在友元声明之前，即需要先定义那个带成员函数声明的类。

它们的共性都是必须在友元声明之外再进行一次声明，其原因是友元声明只是假定该名字在当前作用域是可见的，我们要做的是让该假定变成确定。

比较特殊的是，函数友元（成员函数和非成员函数）可以在友元声明的同时定义，但是仍然需要再进行声明（成员函数友元不用，其声明在前面的类中）其格式如下：

```c++
class ClassName
{
    friend RetType Function(<Para-List>)
    {
        /* 友元函数可以定义在类的内部 */
    }
    /* ... */
};
RetType Function(<Para-List>);		// 声明
```

在函数友元的定义和函数声明这一段空间内，该函数仍然是不可见的，任何调用该函数的操作都将引起错误。
