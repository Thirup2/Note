# 一. 简介

每个类都分别定义了**它的对象被初始化的方式**，类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做**构造函数**（constructor）。

构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。

构造函数的基本结构是：

```c++
ClassName(<parameters>) :Initializer-list {/* ... */}
```

- 构造函数的名字和类名相同
- 构造函数没有返回类型
- 构造函数不能被声明成`const`的，当我们创建类的一个`const`对象时，直到构造函数完成初始化过程，对象才能真正取得其 “常量” 属性。因此，构造函数在`const`对象的构造过程中可以向其写值。 
- 其中`Initializer-list`跟在一个冒号后面，介于参数列表和函数体之间，它是构造函数的初始值列表



# 二. 默认构造函数

## 1. 合成的默认构造函数

如果我们的类没有显式地定义构造函数，那么编译器就会为我们隐式地定义一个默认构造函数，这个函数又被称为**合成的默认构造函数**（synthesized default constructor）。

对于大多数类来说，这个合成的默认构造函数将按照如下规则初始化类的数据成员：

- 如果存在类内的初始值，用它来初始化成员
- 否则，默认初始化该成员

****

**注意**：某些类不能依赖于合成的默认构造函数

- 一旦我们定义了一些其他的构造函数，那么除非我们再定义一个默认的构造函数，否则类将没有默认构造函数
- 合成的默认构造函数可能执行错误的操作：如内置类型或复合类型的对象被默认初始化，则它们的值是未定义的。
- 某些时候编译器不能为某些类合成默认的构造函数：例如，类中包含一个其他类类型的成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员



## 2. 定义的默认构造函数

定义默认构造函数需要注意：**函数的形参列表应该为空**。

定义默认构造函数有两种情况：

- 当定义了其他的构造函数之后还需要默认构造函数，可以使用：

  ```c++
  ClassName() = default;
  ```

  使用`=default`表示我们希望类有一个默认构造函数，并且这个函数的作用完全等同于合成的默认构造函数

- 需要一个不同于合成的默认构造函数的默认构造函数

  ```c++
  ClassName() :Initializer-list {/* ... */}
  ```



## 3. 使用默认构造函数

使用默认构造函数的时候需要注意两点：

- 首先是类是否有默认构造函数

- 其次是不要如下形式调用：

  ```c++
  Sales_data obj();
  ```

  因为这是一个函数而非对象，正确的调用默认构造函数的方式应该是：

  ```c++
  Sales_data obj;
  ```



# 三. 定义其他构造函数

一些示例的构造函数如下所示：

```c++
Sales_data() = default;
Sales_data(const std::string &s) : bookNo(s) { }
Sales_data(const std::string &s, unsigned n, double p) :
		   bookNo(s), units_sold(n), revenue(p*n) { }
Sales_data(std::istream &);		// 声明
```

## 1. 构造函数初始值列表

在冒号和左花括号前的部分就是**构造函数初始值列表**（constructor initialize list），它负责为新创建的对象的一个或几个数据成员赋初值。

需要注意构造函数初始值列表的**格式**：

- 构造函数初始值列表是成员名字的一个列表
- 每个名字后面紧跟圆括号或花括号括起来的成员初始值（不允许其他形式初始化）
- 不同成员的初始化通过逗号分隔开来

****

**部分构造函数的初始值列表也可以替换为函数体内赋值的形式**，但是初始化和赋值是有区别的。

如果没有在构造函数的初始值列表中显式地初始化成员，则该成员将在构造函数体之前执行默认初始化。例如：

```c++
Sales_data::Sales_data(const string &s, unsigned cnt, double price)
{
    bookNo = s;
    units_sold = cnt;
    revenue = cnt * price;
}
```

此时虽然最后的结果和使用初始值列表的效果是相同的，但是实际上该构造函数首先执行了一遍默认初始化，然后才进入函数体执行了赋值操作。

****

**没有初始值列表的构造函数在某些情况下是不可行的**：

- 如果成员是`const`或者是引用的话，必须将其初始化
- 如果成员属于某种未提供默认构造函数的类类型，必须将其初始化

****

**成员初始化的顺序**：

显然，在构造函数初始值中每个成员只能出现一次。而构造函数初始值列表**只说明用于初始化成员的值，而不限定初始化的具体执行顺序**。

成员的初始化顺序与它们在类定义中的出现顺序一致，即构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序

一般来说，初始化的顺序没什么特别要求。不过如果一个成员是用另一个成员来初始化的，那么这两个成员的初始化顺序就很关键了：

```c++
class X
{
    int i;
    int j;
public:
    X(int val) : j(val), i(j) { }		// 未定义行为：i 在 j 之前被初始化
};
```

由于`i`在`j`之前被初始化，所以作为初始值的`j`在此时还是一个未定义的值。



## 2. 在类的外部定义构造函数

和成员函数类似，在类外定义构造函数时，也需要通过类作用域运算符来表示构造函数的位置：

```c++
Sales_data::Sales_data(std::istream &is)
{
    read(is, *this);	// 从 is 中读取一条交易信息然后存入 this 对象中
}
```

在定义构造函数时需要注意：构造函数不应该轻易覆盖掉类内的初始值，除非新赋的值与原值不同。如果你不能使用类内初始值，则所有的构造函数都应该显式地初始化每个内置类型的成员。



# 四. 默认实参与构造函数

构造函数也可以接受默认实参，如果这样做，需要注意以下两点：

- 如果所有参数都具有默认实参，那么默认构造函数将使用该函数执行初始化操作
- 不能出现两个调用方式相同的构造函数，如上一点所述，如果提供了一个所有参数都具有默认实参的构造函数，那么就不能再重复定义一个默认构造函数

如：

```c++
class Sales_data
{
public:
    Sales_data(std::string s = "") : bookNo(s) { }		// 同时定义了默认构造函数
    /* ... */
};
```

