# 一. 简介

除了定义拷贝控制成员，管理资源的类通常还定义一个名为`swap`的函数。对于那些与重排元素顺序的算法一起使用的类，定义`swap`是非常重要的。这类算法在需要交换两个元素时会调用`swap`。

如果一个类定义了自己的`swap`，那么算法将使用自定义版本。否则，算法将使用标准库定义的`swap`。



# 二. 自定义 swap 函数

可以在我们的类上定义一个自己版本的`swap`来重载`swap`的默认行为。`swap`的典型实现如下：

```c++
class HasPtr {
    friend void swap(HasPtr&, HasPtr&);
    // ...
};

inline void swap(HasPtr &lhs, HasPtr &rhs)
{
    using std::swap;
    swap(lhs.ps, rhs.ps);
    swap(lhs.i, rhs.i);
}
```

因为默认的`swap`算法是一个非成员函数（这是理所当然的），所以我们如果要重载该函数，那应该也是定义一个同名的非成员函数。我们注意到标准库中的容器类型都有一个成员函数`swap`，这个函数的实现与否完全取决于类的定义者，因为有标准`swap`算法的存在，所以即使不定义`swap`成员函数也是完全可以的。

****

**swap 函数对 swap 的调用**：

当我们声明了自己的重载`swap`函数之后，对于当前的类来说，此时就有两个`swap`函数存在了，一个是当前类的`swap`函数，一个是标准库的`std::swap`函数。

对于没有定义自己的`swap`函数的类对象，应该使用`std::swap`函数进行调用；而对于定义了自己的`swap`函数的类对象，应该调用其类自定义的`swap`函数。

当然也可以根据每一个对象的具体类型详细选择调用的函数，但是我们可以有一个更好的方案，就是在调用之前先使用`using`将标准库的`swap`函数声明，此时两个函数都可以通过`swap`进行调用了，并且不会产生歧义。如果调用该函数时使用的参数没有定义自己的`swap`函数，那么该调用将自动调用`std::swap`，而如果调用该函数时提供的参数定义了自己的`swap`函数，那么该调用将自动调用该类自定义的`swap`函数。

`swap`函数中的`using`声明之后，相当于有两个对象同时使用了一个名字，但是实际上并不会隐藏类本身的`swap`声明。



# 三. 在赋值运算符中使用 swap

定义`swap`的类通常用`swap`来定义它们的赋值运算符。这些运算符使用了一种名为**拷贝并交换**（copy and swap）的技术。这种技术将左侧运算对象与右侧运算对象的一个副本进行交换：

```c++
HasPtr& HasPtr::operator=(HasPtr rhs)
{
    swap(*this, rhs);
    return *this;
}
```

在这个版本的赋值运算符中，参数并不是一个引用，我们将右侧运算对象以传值方式传递给了赋值运算符。因此，`rhs`是右侧运算对象的一个副本。参数传递时拷贝`HasPtr`的操作会分配该对象的`string`的一个新副本。

由于`HasPtr`是一个类似于智能指针的类，所以这个操作会完美执行。首先实参传给形参，`rhs`指向实参所指，并增加引用计数；`swap`交换当前对象和形参，即当前对象将指向`rhs`所指，而`rhs`将指向之前的`*this`所指；此时原本的`rhs`所指的引用计数增加了 1，原本的`*this`所指的引用计数不变。到函数结束，`rhs`被销毁，它现在指向的对象的引用计数减 1。所以最后的结果是原本`rhs`指向的引用计数增加 1，而原本`*this`指向的引用计数减少 1