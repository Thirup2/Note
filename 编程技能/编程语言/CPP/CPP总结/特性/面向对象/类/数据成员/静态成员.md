# 一. 简介

有时候类需要它的一些成员**直接与类本身相关**，而不是与类的各个对象保持关联。

例如，一个银行账户类可能需要一个数据成员来表示当前的基准利率。在此例中，我们希望利率与类关联，而非与类的每个对象关联。从实现效率的角度来看，没必要每个对象都存储利率信息。而且更加重要的是，一旦利率浮动，我们希望所有的对象都能使用新值。

另外一个例子是在数学函数库中，我们希望圆周率`pi`是在包含了数学库之后能够直接使用这个值，而不需要先创建一个对象然后才能获取这个值。

为了实现这种需求，需要用到类的**静态成员**，静态成员就是在包含了类头文件之后，**能够直接使用这个值**，而不需要先创建对象，它直接与类本身相关。



# 二. 声明静态成员

我们通过在成员的声明之前加上关键字`static`使得其与类关联在一起。和其他成员一样，静态成员可以是`public`的或`private`的。静态数据成员的类型可以是常量、引用、指针、类类型等。

如：

```c++
class Account
{
public:
    void calculate() { amount += amount * interestRate; }
    static double rate() { return interestRate; }
    static void rate(double);
private:
    std::string owner;
    double amount;
    static double interestRate;
    static double initRate();
};
```

类的静态成员**存在于任何对象之外**，对象中不包含任何与静态数据成员有关的数据。因此，每个`Account`对象将包含两个数据成员：`owner`和`amount`。只存在一个`interestRate`对象且它被所有`Account`对象共享。

类似的，静态成员函数也不与任何对象绑定在一起，它们**不包含`this`指针**。作为结果，静态成员函数**不能声明成 const 成员函数**，而且我们也不能在`static`函数体内使用`this`指针。这一限制既适用于`this`的显式使用，也对调用非静态成员的隐式使用有效。在上例中，两个重载的`rate`成员函数是用户可以调用的公开静态成员函数，而`initRate`是只能由作者调用的私有静态成员函数。



# 三. 使用类的静态成员

我们可以使用作用域运算符直接访问静态成员：

```c++
double r;
r = Account::rate();
```

另外，虽然静态成员不属于类的某个对象，但是我们仍然可以使用类的对象、引用或者指针来访问静态成员：

```c++
Account ac1;
Account *ac2 = &ac1;

r = ac1.rate();
r = ac2->rate();		// 等价于上一条语句
```

上例中后面的两条调用语句是等价的，并不会因为调用该函数的对象不同而产生区别。

****

另外，在**定义静态成员函数时**，虽然不能操作非静态的数据成员，但是可以操作静态成员，并且不需要通过作用域运算符（当然非静态成员函数也可以直接操作静态成员）：

```c++
class Account
{
public:
    void calculate() { amount += amount * interestRate; }
private:
    static double interestRate;
    // ...
};
```



# 四. 定义静态成员

和其他的成员函数一样，我们既可以在类的内部也可以在类的外部定义静态成员函数。当在类的外部定义静态成员时，不能重复`static`关键字，**该关键字只出现在类内部的声明语句**：

```c++
void Account::rat(double newRate)
{
    interestRate = newRate;
}
```

****

而对于数据成员，由于静态数据成员不属于类的任何一个对象，所以它们并不是在创建类的对象时被定义的，即它们**不是由类的构造函数初始化的**。而且一般来说，我们**不能在类的内部初始化静态成员**。而**必须在类的外部定义和初始化每个静态成员**，和其他对象一样，一个静态数据成员只能定义一次。

类似于全局变量，静态数据成员定义在任何函数之外。因此一旦它被定义，就将一直存在于程序的整个生命周期中。

我们定义静态数据成员的方式和在类的外部定义成员函数差不多。我们需要指定对象的类型名，然后是类名、作用域运算符以及成员自己的名字：

```c++
double Account::interestRate = initRate();
```

****

**静态成员的类内初始化**：

通常情况下，类的静态成员不应该在类的内部初始化。然而，我们可以为静态成员提供`const`**整数类型**的类内初始值，不过要求**静态成员**必须是**字面值常量类型的**`constexpr`。

初始值必须是常量表达式，因为这些成员本身就是常量表达式，所以它们能用在所有适合于常量表达式的地方。例如，我们可以用一个初始化了的静态数据成员指定数组成员的维度：

```c++
class Account
{
public:
    static double rate() { return interestRate; }
    static void rate(double);
private:
    static constexpr int period = 30;
    double daily_tbl[period];
};
```

总结而言：某个静态成员是否需要有定义语句，取决于它是否被除了类本身外的其他程序需要，如果不需要则可以省略定义，反之必须添加定义语句。如上例所示，如果`period`的唯一用途就是定义`daily_tbl`的维度，则不需要在`Account`外面专门定义`period`。而如果需要把例如`Account::period`传递给一个接受`const int &`的函数时，由于我们没有定义，所以程序找不到该成员的定义语句，此时就必须定义。

要理解这一点需要明确：**其他程序如果想要使用这个静态成员，那么它就必须在类外有定义，类内即使有初始值，但这对其他程序并不可见。**

记住：即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员。



# 五. 静态成员的用途

由于静态成员独立于任何对象。因此，在某些非静态数据成员可能非法的场合，静态成员却可以正常地使用。

如：

- 静态数据成员可以是不完全类型，如静态数据成员的类型可以就是它所属的类类型。而非静态成员则受到限制，只能声明成它所属类的指针或引用：

  ```c++
  class Bar
  {
  public:
      // ...
  private:
      static Bar mem1;
      Bar *mem2;
  };
  ```

- 我们可以使用静态成员作为默认实参，而非静态成员则不行，因为它的值本身属于对象的一部分。