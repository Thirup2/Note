# 一. 简介

每个类都定义了唯一的类型，对于两个类来说，即使它们的成员完全一样，这两个类也是不同的类型。例如：

```c++
struct First
{
    int memi;
    int getMem();
};
struct Second
{
    int memi;
    int getMem();
};
```

其中`First`和`Second`是两个完全不同的类型，不能使用拷贝或赋值等运算在两个类型之间拷贝或赋值。



# 二. 使用类

使用类的时候，既可以把类名本身当作类型说明符，也可以把类名跟在关键字`struct`或`class`后面：

```c++
Sales_data item1;
class Sales_data item1;
```

其中第二种方式从 C 语言继承而来，在 C++ 语言中也是合法的。



# 三. 声明与定义

类和函数一样，可以把它的声明和定义分离开来。

我们可以仅仅声明类而暂时不定以它：

```c++
class Screen;
```

这种声明有时被称作**前向声明**（forward declaration），它向程序中引入了名字`Screen`并且指明`Screen`是一种类类型。

对于`Screen`来说，在它声明之后定义之前是一个**不完全类型**（incomplete type），也就是说，此时我们已知`Screen`是一个类类型，但是不清楚它到底包含哪些成员。

****

不完全类型只能在非常有限的情境下使用：

- 可以定义指向这种类型的指针或引用
- 可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数

对于一个类来说，在我们创建它的对象之前必须被定义过，而不能仅仅被声明。否则，编译器就无法了解这样的对象需要多少存储空间。所以类也必须首先被定义，然后才能引用或者指针访问其成员。

一个例外是类的成员不能是该类自己（因为必须先完成定义才能使用），但是可以是它自身类型的引用或指针，如：

```c++
class Link_screen
{
    Screen window;
    Link_screen *next;
    Link_screen *prev;
};
```



# 四. 聚合类

**聚合类**（aggregate class）使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。当一个类满足如下条件时，我们说它是聚合的：

- 所有成员都是`public`的
- 没有定义任何构造函数
- 没有类内初始值
- 没有基类，也没有`virtual`函数

实际上，聚合类就是 C 语言中实现数据结构的方式。

如，下面的类是一个聚合类：

```c++
struct Data
{
    int ival;
    string s;
};
```

****

**初始化**：

我们可以提供一个**花括号括起来的成员初始值列表**，并用它初始化聚合类的数据成员：

```c++
Data val1 = { 0, "Anna" };
```

初始值的顺序必须与声明的顺序一致，也就是说，第一个成员的初始值要放在第一个，然后是第二个，以此类推，下面的例子是错误的：

```c++
Data val2 = { "Anna", 1024};		// 错误：初始值顺序错误
```

与初始化数组元素的规则一样，如果初始值列表中的元素个数少于类的成员数量，则靠后的成员被值初始化。**初始值列表的元素个数绝对不能超过类的成员数量**。

需要注意的是，显式地初始化类的对象的成员存在三个明显的缺点：

- 要求类的所有成员都是`public`的
- 将正确初始化每个对象的每个成员的重任交给了类的用户（而非类的作者）。因为用户很容易忘掉某个初始值，或者提供一个不恰当的初始值，所以这样的初始化过程冗长乏味且容易出错。
- 添加或删除一个成员之后，所有的初始化语句都需要更新



# 五. 字面值常量类

除了算术类型、引用和指针以及函数之外，类也可以定义成字面值常量类型的。

和其他类不同，字面值类型的类可能含有`constexpr`函数成员。这样的成员必须符合`constexpr`函数的所有要求，它们是隐式`const`（`const`成员函数）的。

数据成员**都是字面值类型的聚合类**是字面值常量类，如果一个类不是聚合类，但它符合下述要求，则它**也是**一个字面值常量类：

- 数据成员都必须是字面值类型（能被`constexpr`修饰的类型）
- 类必须至少含有一个`constexpr`构造函数
- 如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的`constexpr`函数
- 类必须使用析构函数的默认定义，该成员负责销毁类的对象

## 1. constexpr构造函数

构造函数不能是`const`的，但是字面值常量类的构造函数可以是`constexpr`函数，并且一个字面值常量类必须至少提供一个`constexpr`构造函数

`constexpr`构造函数可以声明成`=default`的形式（或者是删除函数的形式）。否则`constexpr`构造函数就必须既符合构造函数的要求（意味着不能包含返回语句），又符合`constexpr`函数的要求（意味着它能拥有的唯一可执行语句就是返回语句）。

综合以上条件可知，**`constexpr`构造函数体一般来说应该是空的**。

我们通过前置关键字`constexpr`就能声明一个`constexpr`函数了：

```c++
class Debug
{
public:
    constexpr Debug(bool b = true) : hw(b), io(b), other(b) { }
    constexpr Debug(bool h, bool i, bool o) : hw(h), io(i), other(o) { }
    constexpr bool any() { return hw || io || other; }
    void set_io(bool b) { io = b; }
    void set_hw(bool b) { hw = b; }
    void set_other(bool b) { hw = b; }
private:
    bool hw;
    bool io;
    bool other;
};
```



## 2. 注意

`constexpr`构造函数必须初始化所有数据成员，初始值或者使用`constexpr`构造函数，或者是一条常量表达式。

`constexpr`构造函数用于生成`constexpr`对象以及`constexpr`函数的参数或返回类型：

```c++
constexpr Debug io_sub(false, true, false);			// 初始值必须是常量表达式并且初始化所有成员
if (io_sub.any())
    cerr << "print appropriate error messages" << endl;
constexpr Debug prod(false);
if(prod.any())
    cerr << "print an error message" << endl;
```

