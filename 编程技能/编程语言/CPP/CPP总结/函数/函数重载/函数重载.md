# 一. 定义重载函数

定义于**同一作用域**内的几个**函数名字相同**但**形参列表不同**，称之为**重载**(overloaded)**函数**。

**注意**：`main`函数不能重载。

## 1. 重载函数的特点

要定义重载函数，需要满足下面这些条件：

- 它们处于同一个作用域
- 它们的函数名字相同
- 它们的形参列表不同

**注意**：不允许两个函数除了返回类型外其他所有的要素都相同。

## 2. 判断形参列表是否相同

1. 首先看形参列表的形参个数是否相同，如果不相同，则形参列表不相同
2. 若个数相同，则看参数的类型，如果存在类型不同的形参，则形参列表不相同；否则形参列表相同。而判断两个参数类型是否相同则根据以下三条判断：
   1. 首先看是否有`const`存在，如果不存在则直接判断类型是否相同
   2. 若两个参数之间的差异只是顶层`const`，则二者判断为相同，因为在调用函数时并不能根据实参判断是否是顶层`const`形参
   3. 若两个参数之间的差异有底层`const`，则二者判断为不同。

## 3. 重载函数调用过程

调用函数时，需要提供实参，而程序会根据提供的实参的数量以及类型来选择一个最合适的函数，这个过程称为**函数匹配**(function matching)，也叫作**重载确定**(overload resolution)。

调用一个重载函数时有三种可能的结果：

- 编译器找到一个与实参**最佳匹配**(best match)的函数，并生成调用该函数的代码
- 找不到任何一个函数与调用的实参匹配，此时编译器发出**无匹配**(no match)的错误信息
- 有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也将发生错误，称为**二义性调用**(ambiguous call)

## 4. 函数重载的实例

### 1）情景

当我们需要一个函数，它比较两个`string`对象的字符个数，然后返回字符个数少的那个对象。首先假设两个传入的`string`对象的引用都是非常量类型或者都是常量类型，那么它们返回的类型也应该是对应的非常量或常量类型。

如果我们只有一个函数，如果是用于处理非常量`string`对象的函数，那么此时传入常量`string`对象的引用将引发错误；如果是用于处理常量`string`对象的函数，那么传入非常量`string`对象的引用之后将返回一个常量`string`对象的引用，此时就需要用到重载函数，其定义分别如下。

### 2）函数

```c++
const string &shorterString(const string &s1, const string &s2)
{
    return s1.size() <= s2.size() ? s1 : s2;
}
```

```c++
string &shorterString(string &s1, string &s2)
{
    auto &r = shorterString(const_cast<const string&>(s1), const_cast<const string&>(s2));
    return const_cast<string&>(r);
}
```

当传入两个非常量`string`对象的引用时，进入第二个函数，然后先将两个参数设置为底层`const`，然后调用第一个函数，返回了更小的`string`对象的常量引用，但是由于传入的是非常量引用，所以我们最后去掉它的底层`const`属性，然后返回。



# 二. 函数匹配

函数匹配一共有三个步骤：

1. 选定本次调用对应的重载函数集，集合中的函数称为**候选函数**(candidate function)。候选函数有两个特征：

   - 与被调用的函数同名
   - 其声明在调用点可见

2. 考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为**可行函数**(viable function)。可行函数也有两个特征：

   - 其形参数量与本次调用提供的实参数量相等(默认实参也算数量)
   - 每个实参的类型与对应的形参类型相同，或者能转换成形参的类型

   如果这一步没有找出任何可行函数，则返回无匹配错误；如果只有一个可行函数，则该可行函数就是最佳匹配。

3. 如果可行函数有多个，则从可行函数中选择与本次调用最匹配的函数。在这一过程中，逐一检查函数调用提供的实参，寻找形参类型与实参类型最匹配的那个可行函数。如果在这一步没有找到最佳匹配，则返回二义性错误。

下面将主要说明第三个步骤。

## 1. 匹配条件

当一个函数满足下列条件，则匹配成功：

- 该函数每个实参的匹配都不劣于其他可行函数需要的匹配
- 至少有一个实参的匹配优于其他可行函数提供的匹配

## 2. 匹配的优劣度

实参类型如果不能转换到形参类型，则说明该函数一定不匹配，对于能转换的情况，按照从优到劣分为以下情况：

1. 精确匹配，包括以下情况：

   - 实参类型和形参类型相同
   - 实参从数组类型或函数类型转换成对应的指针类型
   - 向实参添加顶层`const`或者从实参中删除顶层`const`

2. 通过`const`转换实现的匹配

   当一对参数之间的区别是底层`const`时，如果实参是一个常量，则匹配具有底层`const`的函数；否则匹配不具有底层`const`的函数，因为不转换明显优于转换。

3. 通过类型提升实现的匹配

4. 通过算术类型转换或指针转换实现的匹配

   该情况可能出现一些错误判断，假如有以下两个重载函数：

   ```c++
   void ff(int);
   void ff(short);
   ```

   此时只有当调用提供的是`short`类型的值时才会选择`short`版本的函数，如果提供其他比`int`小的类型，如`char`类型等，首先会通过类型提升提升到`int`类型，所以调用的将会是`int`版本的函数

5. 通过类类型转换实现的匹配