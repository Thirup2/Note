# 一. 传值和传引用参数

当形参是引用类型时，它对应的实参被**引用传递**(passed by reference)或者说函数被**传引用调用**(called by reference)；

当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象，这样的实参被**值传递**(passed by value)或者说函数被**传值调用**(called by value)。

## 1. 传值参数

当初始化一个非引用类型的变量时，初始值被拷贝给变量。此时对变量的改动不会影响初始值。传值参数的机理与此完全相同，函数对形参做的所有操作都不会影响实参。

相对特殊的是**指针形参**，当传入一个指针形参时，实质上仍然是值的传递，因为指针对象本身保存的是一个地址，实参到形参的传递拷贝的是这个地址值，更改形参指针指向的地址并不会影响到实参的指向。但是它可以实现类似于传引用参数的功能，即对对象的值间接访问。对指针进行解引用操作之后就相当于得到了一个引用。

## 2. 传引用参数

把形参按照引用声明的形式进行声明，那么当传入一个实参时，在函数内创建的就是一个引用，引用的对象就是传入的实参。

传引用参数的用途主要有以下三个：

- 通过使用引用参数，允许函数改变一个或多个实参的值
- 使用引用来避免拷贝操作：因为拷贝大的类类型对象或者容器对象时比较低效，以及某些类类型根本不支持拷贝操作
- 使用引用形参返回额外信息：一个函数只能返回一个值，当函数需要同时返回多个值的时候，可以添加引用形参来返回多个结果



# 二. const参数

## 1. 顶层const

对于顶层`const`来说，不论是形参是顶层`const`还是实参是顶层`const`或二者都是，都对实际的传值过程没有影响，因为和顶层`const`的初始化类似：

```c++
int i = 42;
const int v = 30;

const int val1 = i;		// 正确
int val2 = v;			// 正确
const int val3 = v;		// 正确
```

顶层`const`只会出现于传值参数中，所以就算把一个常量传递给非常量也不会影响这个常量本身的值，这与变量是一样的

## 2. 底层const

同样与变量的声明定义等操作是一样的：

### 1）指针

- 指向常量的指针可以指向常量对象，也可以指向非常量对象，都不能通过指针更改对象值
- 指向非常量的指针只能指向非常量对象，可以通过指针更改对象值

### 2）引用

- 常量引用可以绑定常量对象，也可以绑定非常量对象以及字面值或表达式
- 非常量引用只能绑定非常量对象

## 3. 注意

当形参需要通过指针或引用来间接访问对象值时，需要慎重考虑。

当函数会通过指针或引用改变其指向或绑定的对象的值时，此时不需要将形参声明为底层`const`，此时只能接受非常量实参；

当函数明确不会改变指针或引用指向或绑定的对象的值时，此时最好将形参声明为底层`const`。

这么做的目的有以下三个：

1. 当使用底层`const`时，仍然能够接受非常量实参，并且同时还能接受常量实参。
2. 并且`const`能够为调用者提供不会更改对象值的信息
3. 不会因为一些误操作导致更改了对象的值，如果有这些误操作，编译器会给出错误



# 三. 数组形参

由于数组的两个性质：不允许拷贝数组、使用数组时会将其转换成指针。我们不能直接传递数组，但是可以传递指向数组的指针。

虽然使用的是指针，但是在形参中，也可以使用数组的形式：

```c++
void print(const int*);
void print(const int[]);
void print(const int[10]);
```

以上三种形参声明方式都是相同的，数组形式会转换为指针，数组形式中的数组大小对参数并没有影响。

## 1. 指针形参

因为数组是以指针的形式传递给函数的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外的信息。管理指针形参有三种常用的技术：

### 1）在数组本身添加一个结束标记

如C风格字符串就使用了这样的方法

```c++
void print(const char *cp)
{
    if (cp)					// 当cp为0时(空指针)结束
        while (*cp)
            cout << *cp++;
}
```

### 2）传递指向数组首元素和尾后元素的指针

只要调用者能正确地计算指针所指的位置，则下面的代码就是安全的：

```c++
void print(const int *beg, const int *end)
{
    while (beg != end)
        cout << *beg++ << endl;
}
```

### 3）定义一个表示数组大小的形参

```c++
void print(const int ia[], size_t size)
{
    for (size_t i = 0; i != size; ++i)
        cout << ia[i] << endl;
}
```

同样需要调用者了解数组的大小

## 2. 引用形参

除了将数组以指针的形式传递，还可以通过引用的形式传递。

声明一个数组的引用的方法是：

```c++
int ivals[10];
int (&arr)[10] = ivals;			// 数组的引用
```

应用到函数中形式如下：

```c++
void print(int (&arr)[10])
{
    for (auto elem : arr)
        cout << elem << endl;
}
```

**注意**：以这种方式声明的形参只能处理固定大小的数组，如上面的函数就只能用于处理`int[10]`的数组

## 3. 多维数组

传递多维数组同样可以通过指针和引用两种方式：

### 1）指针形式

将一个二维数组转换为指针如下：

```c++
int ivals[3][4];
int (*matrix)[4] = ivals;		// 指向一个包含4个int元素的数组
```

应用到函数时：

```c++
void print(int (*matrix)[4], int rowSize);			// 指针形式，下标运算符中的数组大小不能省略
void print(int matrix[][4], int rowSize);			// 数组形式，除了第一个下标，后续都不能省略
```

### 2）引用形式

将一个二维数组转换为引用如下：

```c++
int ivals[3][4];
int (&matrix)[3][4] = ivals;
```

应用到函数时：

```c++
void print(int (&matrix)[3][4]);
```

**注意**：同样，它只能处理3行4列的二维数组



# 四. 命令行参数

## 1. 使用准备

首先需要为`main`函数添加两个形参：

```c++
int main(int argc, char *argv[]) { /* ... */ }
// 或
int main(int argc, char **argv) { /* ... */ }
```

- `argc`：传入到`main`函数的参数(字符串)个数
- `argv`：传入参数组成的字符串数组

## 2. 参数内容

`argv`的元素是指向C风格字符串的指针，其包含至少一个元素，即`argv[0]`，其指向程序的名字或者一个空字符串。

传入`main`函数的字符串通过空白分隔，从前到后依次按照`argv[1]`、`argv[2]`...进行保存。

另外最后一个指针之后的元素值保证为0，如一共传入了4个参数，加上程序名，则`argv`是一个包含5个元素的字符串数组，那么它的最后一个元素`argv[4]`之后的一个元素`argv[5]`一定为0



# 五. 可变形参

当需要的形参数量或类型不确定时，就可以使用处理可变形参的方法：

- 如果所有的实参类型相同，可以传递一个名为`initializer_list`的标准库类型；
- 如果实参的类型不同，可以编写一种特殊的模板，也就是可变参数模板
- 与C函数交互使用的省略符形参

## 1. initailizer_list类型

### 1）使用准备

`initializer_list`是一种标准库类型，它定义在同名的头文件中，以及该类型定义在标准命名空间中

```c++
#include <initializer_list>
using std::initializer_list;
```

### 2）操作

`initializer_list`提供的操作如下表：

| 操作                                   | 效果                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| `initializer_list<T> lst;`             | 默认初始化：`T`类型元素的空列表                              |
| `initializer_list<T> lst{a, b, c...};` | `lst`的元素数量和初始值一样多；`lst`的元素是对应初始值的副本；列表中的元素是`const` |
| `lst2(lst)`<br />`lst2 = lst`          | 拷贝或赋值一个`initializer_list`对象但是不会拷贝列表中的元素；<br />拷贝后，原始列表和副本共享元素 |
| `lst.size()`                           | 列表中的元素数量                                             |
| `lst.begin()`                          | 返回指向`lst`中首元素的指针                                  |
| `lst.end()`                            | 返回指向`lst`中尾元素下一位置的指针                          |

### 3）注意

- `initializer_list`是一种模板类型，定义`initializer_list`对象时，必须说明列表中所含元素的类型
- `initializer_list`对象中的元素永远是常量值
- 含有`initializer_list`形参的函数也可以同时拥有其他形参

### 4）使用

```c++
// 函数
void error_msg(initializer_list<string> il)
{
    for (auto beg = il.begin(); beg != il.end(); ++beg)
        cout << *beg << " ";
    cout << endl;
}
// 调用方式
// expected和actual是string对象
if (expected != actual)
    error_msg({"functionX", expected, actual});
else
    error_msg({"functionX", "okey"});
```

## 2. 省略符形参

省略符形参是为了便于C++程序访问某些特殊的C代码而设置的，这些代码使用了名为`varargs`的C标准库功能。通常，省略符形参不应用于其他目的。

省略符形参只能出现在形参列表的最后一个位置，它的形式只有以下两种：

```c++
void foo(parm_list, ...);
void foo(...);
```

具体的使用方法参照C语言中的教程。



# 六. 默认实参

在形参列表中，我们可以给形参提供一个值，该值称为函数的**默认实参**(default argument)。调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。

其定义方式如下：

```c++
typedef string::size_type sz;
string screen(sz ht = 24, sz wid = 80, char background = ' ');	// 为每个参数都提供了一个默认实参
```

使用默认实参需要注意以下几点：

- 一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值

- 函数可以声明多次，在函数的多次声明中，同一个形参只能提供一次默认值，后续的函数声明只能为那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须都有默认值，加入给定：

  ```c++
  string screen(sz, sz, char = ' ');
  ```

  我们不能修改一个已经存在的默认值：

  ```c++
  string screen(sz, sz, char = '*');
  ```

  但是可以按照如下形式添加默认实参：

  ```c++
  string screen(sz = 24, sz = 80, char);
  ```

- 用作默认实参的变量需要在函数定声明所在的作用域

- 用作默认实参的名字在函数声明所在的作用域内解析，而这些名字的求值过程发生在函数调用时