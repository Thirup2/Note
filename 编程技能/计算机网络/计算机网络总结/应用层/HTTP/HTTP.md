# 一. 简介

**HTTP** 协议即**超文本传输协议**（HyperText Transfer Protocol, HTTP），主要应用于 Web 应用中。

HTTP 由两个程序实现：

1. 客户程序
2. 服务器程序

**Web 页面**（Web page）是由对象组成的。一个**对象**（object）只是一个文件，如一个 HTML 文件、一个 JPEG 图形、一个 Java 小程序或一个视频片段这样的文件，且它们可通过一个 URL 地址寻址。**Web 浏览器**（Web browser）实现了 HTTP 的客户端，**Web 服务器**（Web server）实现了 HTTP 的服务器端，它用于存储 Web 对象，每个对象由 URL 寻址。

HTTP 定义了 Web 客户向 Web 服务器请求 Web 页面的方式，以及服务器向客户传送 Web 页面的方式。当用户请求一个 Web 页面时，浏览器向服务器发出对该页面中所包含对象的 HTTP 请求报文，服务器接收到请求并用包含这些对象的 HTTP 响应报文进行响应。

需要注意下列现象：

- 服务器向客户发送被请求的文件，而不存储任何关于该客户的状态信息。假如某个特定的客户在短短的几秒内两次请求同一个对象，服务器并不会因为刚刚为客户提供了该对象就不再做出反应，而是重新发送该对象，就像服务器已经完全忘记不久之前所做过的事情一样。由于 HTTP 服务器并不保存客户的任何信息，所以我们称 HTTP 是一个 **无状态协议**（stateless protocol）。
- Web 使用了客户-服务器应用程序体系结构。Web 服务器总是打开的，具有一个固定的 IP 地址，且它服务于可能来自数以百万计的不同浏览器的请求。



# 二. HTTP 运输协议的选择

HTTP 使用 TCP 作为它的支撑运输协议（而不是在 UDP 上运行）。

HTTP 客户首先发起一个与服务器的 TCP 链接。一旦连接建立，该浏览器和服务器进程就可以通过套接字接口访问 TCP 。



# 三. HTTP 连接状态的选择

在许多因特网应用程序中，客户和服务器在一个相当长的时间范围内通信，其中客户发出一系列请求并且服务器对每个请求进行响应。依据应用程序以及该应用程序的使用方式，这一系列请求可以以规则的间隔周期性地或间断性地一以接一个发出。

当这种 客户-服务器 的交互是经 TCP 进行的，应用程序的研制者就需要做一个重要决定：

- 每个 请求/响应对 是经一个单独的 TCP 连接发送（即传输一个对象之后断开连接，下一次收到请求后又重新建立 TCP 连接）
- 还是所有的请求及其响应经相同的 TCP 连接发送（即通信时间内保持一个 TCP 连接不断开）

如果采用前一种方法，该应用程序被称为使用 **非持续连接**（non-persistent connection）；采用后一种方法，该应用程序被称为使用 **持续连接**（persistent connection）。

HTTP 既能够使用非持续连接，也能够使用持续连接。在默认方式下，HTTP 使用持续连接。

接下来对这两种连接方式的优点和缺点进行说明：

## 1. 采用非持续连接的 HTTP

首先了解一下非持续连接的实际传输过程，假设一共有 11 个要传输的对象，其中有一个 HTML 基本文件和 10 个 JPEG 图形，且这 11 个对象位于同一台服务器上，则实际传输过程如下：

**传输过程**：

1. HTTP 客户进程在端口号 80 发起一个到服务器的 TCP 连接，该端口号是 HTTP 的默认端口。在客户和服务器上分别有一个套接字与该连接相关联
2. HTTP 客户经它的套接字向该服务器发送一个 HTTP 请求报文。请求报文中包含了路径名。
3. HTTP 服务器进程经它的套接字接收该请求报文，从其存储器（RAM 或磁盘）中检索出对象，在一个 HTTP 响应报文中封装对象，并通过其套接字向客户发送响应报文
4. HTTP 服务器进程通知 TCP 断开该 TCP 连接。（但是直到 TCP 确认客户已经完整地收到响应报文为止，它才会实际中断连接。）
5. HTTP 客户接收响应报文，TCP 连接关闭。该报文指出封装的对象是一个 HTML 文件，客户从响应报文中提取出该文件，检查该 HTML 文件，得到对 10 个 JPEG 图形的引用。
6. 对每个引用的 JPEG 图形对象重复前 4 个步骤

**时间计算**：

从客户发起一个 TCP 连接开始到客户接收一个一个对象为结束，其中一共有两个主要阶段：连接阶段和传输阶段，当然将整个文件放入传输通道也需要一部分时间，但相对于前两个阶段来说，可以忽略。

首先连接阶段：

- 客户发起连接：浏览器在它和 Web 服务器之间发起一个 TCP 连接
- 服务器响应连接：服务器用一个小 TCP 报文段做出确认和响应

然后是传输阶段：

- 客户请求文件：客户向服务器返回确认，同时向该 TCP 连接发送一个 HTTP 请求报文
- 服务器响应请求：服务器在该 TCP 连接上发送客户请求的文件

这其中的每一个过程都需要花费一定的时间，我们将一个阶段定义为一个 **往返时间**（Round-Trip Time, RTT），那么这两个阶段也就是两个 RTT。

然后传输的每一个对象都是从头开始，到尾结束，也就是说，11 个对象一共将花费 22个 RTT，另外，由于对象的增加，传输文件所花的时间也不能再忽略。

**缺点**：

- 必须为每一个请求的对象建立和维护一个全新的连接。对于每个这样的连接，在客户和服务器中都要分配 TCP 的缓冲区和保持 TCP 变量，这给 Web 服务器带来了严重的复旦，因为一台 Web 服务器可能同时服务于数以百计不同的客户的请求
- 每一个对象经受两倍 RTT 的交付时延，一个 RTT 用于创建 TCP，另一个 RTT 用于请求和接收一个对象。



## 2. 采用持续连接的 HTTP

**传输过程**：

采用持续连接的 HTTP 在传输完一个对象之后不会立即关闭连接，在这段期间，客户可以直接向服务器请求文件而不需要重新连接。甚至客户可以持续发送请求而不需要等待响应，服务器会在接收到请求之后依次响应。

至于 TCP 连接的关闭时间，往往是在一条连接经过一定时间间隔（一个可配置的超时间隔）仍位被使用，HTTP 服务器就关闭该连接。

**时间计算**：

假设按照非并行方式进行请求和响应，那么计算下来也应该是 1 个连接阶段的 RTT 和 11 个传输阶段的 RTT，一共是 12 个 RTT，比起非持续连接少了太多。

而如果按照并行方式进行请求和响应（即发送请求之后不用等待响应继续发送请求），那么这个消耗的时间会变得更少。



# 四. HTTP 报文

HTTP 报文有两种：请求报文和响应报文。

## 1. HTTP 请求报文

下面提供了一个典型的 HTTP 请求报文：

```http
GET /somedir/page.html HTTP/1.1
Host: www.someschool.edu
Connection: close
User-agent: Mozilla/5.0
Accept-language: fr
```

**示例分析**：

- 报文使用普通的 ASCII 文本书写，这样有一定计算机知识的人都能够阅读它
- 上述报文由 5 行组成，每行由一个回车和换行符结束。最后一行再附加一个回车换行符。另外一个请求报文能够具有更多的行或者至少为一行
- HTTP 请求报文的第一行叫做 **请求行**（request line），其后继的行叫做 **首部行**（header line），以及在首部行之后还有一个 **实体体**（entity body）与首部行用一个空行隔开。
  - 请求行有三个字段：方法字段、URL 字段和 HTTP 版本字段
    - 方法字段可以取几种不同的值，包括：GET、POST、HEAD、PUT 和 DELETE。当浏览器请求一个对象时，使用 GET 方法
    - 以 GET 方法为例，URL 字段就是一个请求对象
    - HTTP 版本字段说明当前报文使用的 HTTP 版本
  - 首部行由一些首部字段名以及该字段的值构成
    - Host 表示对象的主机名，冒号后面就是该字段的值，也就是对象的主机名
    - Connection 表示连接方式，close 告诉服务器在发送完被请求对象后关闭连接
    - User-agent 指明用户代理，也就是向服务器发送请求的浏览器的类型。
    - Accept-language 表示用户想得到该版本的语言版本（如果服务器中有这样的对象的话，否则发送默认语言版本），本例中为法语
  - 实体体有时为空，如使用方法为 GET 方法的时候，当使用 POST 方法时使用该实体体，如当用户提交表单时。

**通用格式**：

根据上面的例子，我们可以得到一个 HTTP 请求报文的通用格式：

我们用`\sp`表示一个空格，`\cr`表示回车符，`\lf`表示换行符

```
<方法>\sp<URL>\sp<版本>\cr\lf
<首部字段名:>\sp<值>\cr\lf
...
<首部字段名>\sp<值>\cr\lf
\cr\lf
<实体体>
```



## 2. HTTP 响应报文

下面是一个典型的 HTTP 响应报文，同时是上例中请求报文的响应：

```http
HTTP/1.1 200 OK
Connection: close
Date: Tue, 18 Aug 2015 15:44:04 GMT
Server: Apache/2.2.3 (CentOS)
Last-Modified: Tue, 18 Aug 2015 15:11:03 GMT
Content-Length: 6821
Content-Type: text/html

(data data data data data ...)
```

**示例分析**：

- 报文一共三个部分：一个初始 **状态行**（status line），6个 **首部行**，然后是 **实体体**。实体体部分是报文的主要部分，即它包含了所请求的对象本身
  - 状态行有三个字段：协议版本字段、状态码和响应状态信息
    - 协议版本即当前使用的 HTTP 版本
    - 状态码和响应状态信息是一一对应的，本例中是 200 OK，表示请求成功，信息在返回的响应报文中。一些常见的状态码和相关的响应状态信息如下：
      - 200 OK：请求成功，信息在返回的响应报文中
      - 301 Moved Permanenty：请求的对象已经被永久转移了，新的 URL 定义在响应报文的 Location：首部行中。客户软件将自动获取新的 URL
      - 400 Bad Request：一个通用差错代码，指示该请求不能被服务器理解
      - 404 Not Found：被请求的文档不在服务器上
      - 505 HTTP Version Not Supported：服务器不支持请求报文使用的 HTTP 协议版本
  - 首部行的格式和请求报文相同
    - Connection: close 告诉客户，发送完报文后将关闭该 TCP 连接
    - Date 指示服务器产生并发送该响应报文的日期和时间（注意不是指对象创建或者最后修改的时间）
    - Server 指示该报文是由一台 Apache Web 服务器产生的，它类似于 HTTP 请求报文中的 User-agent
    - Last-modified 指示了对象创建或者最后修改的日期和时间。这一首部行对即可能在本地客户也可能在网络缓存服务器上的对象缓存来说非常重要
    - Content-Length 指示了被发送对象中的字节数
    - Content-Type 指示了实体体中的对象的类型是 HTML 文本
  - 实体体：在响应报文中，通常是客户所请求的文件内容

**通用格式**：

```
<版本>\sp<状态码>\sp<短语>\cr\lf
<首部字段名:>\sp<值>\cr\lf
...
<首部字段名:>\sp<值>\cr\lf
\cr\lf
<实体体>
```



# 五. 客户与服务器的交互：cookie

HTTP 服务器本身是无状态的，这简化了服务器的设计，并且允许工程师们去开发可以同时处理数以千计的 TCP 连接的高性能 Web 服务器。

然而一个 Web 站点通常希望能够识别用户，可能是因为服务器希望限制用户的访问，或者因为它希望把内容与用户身份联系起来。为此，HTTP 使用了 cookie。

cookie 技术有 4 个组件：

1. 在 HTTP 响应报文中的一个 cookie 首部行
2. 在 HTTP 请求报文中的一个 cookie 首部行
3. 在用户端系统中保留有一个 cookie 文件，并由用户的浏览器进行管理
4. 位于 Web 站点的一个后端数据库

一个使用 cookie 的 Web 应用的工作过程如下：

- 客户第一次访问该服务器时，服务器在后端数据库为用户创建 ID，然后服务器在响应报文中附加这个 cookie 首部行（Set-cookie）
- 当客户浏览器收到这个带 Set-cookie 首部行的响应报文后，用户的浏览器会在端系统中生成并保留一个 cookie 文件，并由该浏览器进行管理
- 当客户再次访问该服务器时，会在请求报文中添加 cookie 首部行。
- 当服务器收到带 cookie 首部行的请求报文之后，会根据该首部行的值在后端数据库中查找对应的用户信息，然后将这些信息和客户请求的对象一并传输给客户

需要注意的是，服务器的响应报文只在用户第一次请求的时候的响应报文中加入 Set-cookie 首部行，而后续再次请求时就不再添加该首部行；而用户发送的请求报文只有第一次请求不加入 cookie 首部行，而后续再次请求时都需要添加 cookie 首部行。

尽管 cookie 常常能够简化用户的因特网购物活动，但是它的使用仍具有争议，因为它们被认为是对用户隐私的一种侵害。结合 cookie 和用户提供的账户信息，Web 站点可以知道许多有关用户的信息，并可能将这些信息卖给第三方。



# 六. Web 缓存与条件 GET 方法

**Web 缓存器**（Web cache）也叫 **代理服务器**（proxy server），它是能够代表初始 Web 服务器来满足 HTTP 请求的网络实体。

Web 缓存器有自己的磁盘存储空间，并在存储空间中保存最近请求过的对象的副本。

如果使用代理服务器，首先需要在如浏览器中设置好代理服务器，然后实际的 请求/响应 过程如下：

1. 浏览器创建一个到 代理服务器 的 TCP 连接，并向 Web 缓存器中的对象发送一个 HTTP 请求
2. Web 缓存器进行检查，看看本地是否存储了该对象副本
   1. 如果有，Web 缓存器就向客户浏览器用 HTTP 响应报文返回该对象
   2. 如果没有，它就打开一个与该对象的初始服务器的 TCP 连接。Web 缓存器则在这个缓存器到服务器的 TCP 连接上发送一个对该对象的 HTTP 请求。在收到该请求后，初始服务器向该 Web 缓存器发送具有该对象的 HTTP 响应。当 Web 缓存器接收到该对象时，它首先在本地存储空间存储一份副本，并向客户的浏览器用 HTTP 响应报文发送该副本（通过现有的客户浏览器和 Web 缓存器之间的 TCP 连接）

Web 缓存器通常由用户或用户组（如 ISP）购买并安装，而非服务提供方置备。例如，一所大学可能在它的校园网上安装一台缓存器，并且将所有校园网上的用户浏览器配置为指向它。或者，一个主要的住宅 ISP 可能在它的网络上安装一台或多台 Web 缓存器，并且预先配置其配套的浏览器指向这些缓存器。

部署 Web 缓存器以下几个好处：

1. Web 缓存器可以大大减少对客户请求的响应时间，特别是当客户与初始服务器之间的瓶颈带宽远低于客户与 Web 缓存器之间的瓶颈带宽时更是如此
2. Web 缓存器能够大大减少一个机构的接入链路到因特网的通信量。通过减少通信量，该机构就不必急于增加带宽，因此降低了费用。
3. Web 缓存器能从整体上大大减低因特网上的 Web 流量，从而改善了所有应用的性能

通过使用 **内容分发网络**（Content Distribution Network, CDN），Web 缓存器正在因特网中发挥着越来越重要的作用。CDN 公司在因特网上安装了许多地理位置分散的缓存器，因而使大量流量实现了本地化。

但尽管高速缓存能减少用户感受到的响应时间，但也引入了一个新的问题，即存放在缓存器中的对象副本可能是陈旧的。而 HTTP 有一种机制，允许缓存器证实它的对象是最新的。这种机制就是 **条件GET**（conditional GET）方法。

如果：1. 请求报文使用的 GET 方法；并且 2. 请求报文中包含一个 “If-Modified-Since:” 首部行。那么这个 HTTP 请求报文就是一个条件 GET 请求报文。

当 Web 缓存器向初始服务器发送一个包含这个首部行的使用 GET 方法的请求报文时，首先在该首部行的值需要填写当前 Web 缓存器中副本的最后一次修改的时间，然后发送给初始服务器。初始服务器首先获取它所保存的请求对象的最后一次修改的时间，然后与首部行中的时间进行对比，如果相同，则发送一个不包含实体体的响应信息（状态为 304 Not Modified），Web 缓存器接收到这个响应信息之后，就直接把原有的副本发送给客户；如果不同，那么初始服务器将新的对象发送给 Web 缓存器，Web 缓存器收到之后首先更新自己的副本，然后再将这个新的副本发送给客户。