# 一. 简介

段寄存器包括：

- CS
- DS
- SS
- ES

这 4 个寄存器。当 8086 CPU 要访问内存时，由这 4 个段寄存器提供内存单元的段地址。



# 二. CS 和 IP

## 1. 简介

CS 和 IP 是 8086 CPU 中两个最关键的寄存器，他们指示了 CPU 当前要读取指令的地址。CS 为代码段寄存器，IP 为指令指针寄存器。

在 8086 PC 机中，任意时刻，假设 CS 中的内容为 M，IP 中的内容为 N，8086 CPU 将从内存 $M\times 16+N$ 单元开始，读取一条指令并执行。即任意时刻，CPU 将 CS:IP 指向的内容当作指令执行。

以下以一个指令的执行为例：

**前提条件**：

- 指令在内存中紧密依序排列，中间没有空位
- CS 指向代码段开始的位置，IP 指向第一个指令的起始位置偏移量

**执行过程**：

- 首先将 CS、IP 中的内容送入地址加法器，地址加法器完成计算
- 地址加法器将物理地址送入输入输出控制电路
- 输入输出控制电路将物理地址送上地址总线
- 从物理地址所在的位置将机器指令通过数据总线送入 CPU
- 输入输出控制电路将机器指令送入指令缓冲器
- 此时首先增加 IP 的值，如果此时指令缓冲器中是一个 3 字节的指令，则 IP 增加 3，如果此时指令缓冲器中是一个 2 字节的指令，则 IP 增加 2，以此类推。
- 然后将指令缓冲器中的指令送入执行控制器中执行
- 接下来循环完成以上步骤以执行其他指令

另外，在 8086PC 机加电启动或复位后，CS 和 IP 被设置为 CS=FFFFH，IP=0000H。



## 2. 相关指令

修改 CS、IP 的值不能使用`mov`指令，而应该使用`jmp`指令：

| 指令名称 | 用法                  | 效果                                         | 注意                      |
| -------- | --------------------- | -------------------------------------------- | ------------------------- |
| jmp      | `jmp 段地址:偏移地址` | 将 CS 修改为段地址值，将 IP 修改为偏移地址值 |                           |
| jmp      | `jmp 一个合法寄存器`  | 仅将 IP 修改为寄存器的值                     | `reg`必须是一个合法寄存器 |



## 3. 代码段

对于 8086 PC 机，在编程时，可以根据需要，将一组内存单元定义为一个段。我们可以将长度为 $N(N\leqslant 64KB)$ 的一组代码，存在一组地址连续、起始地址为 16 的倍数的内存单元中，我们可以认为，这段内存是用来存放代码的，是一个代码段，段地址即起始地址，长度为 $N$。

为了使这段代码得到执行，我们需要设置 CS、IP 的值，将其指向该代码段的第一个指令。



# 三. DS 和 [address]

## 1. 简介

 CS 是代码段的段地址，当我们想要执行特定内存段的指令时，就需要设置 CS 和 IP。而如果我们想要访问内存中的数据，那么就需要设置 DS 寄存器，它保存的是要访问数据在内存中的段地址。当设置好 DS 寄存器的值后，我们就可以用`[]`中填写偏移地址的方式来访问物理地址的数据了。

其中物理地址仍通过相同公式进行计算：$物理地址=段地址\times 16+偏移地址$



## 2. 相关指令

DS 寄存器可以用 `mov` 指令修改，例如：

```assembly
mov bx,1000H
mov ds,bx
mov al,[0]
```

该例中，首先将 DS 寄存器的值修改为 1000H，然后通过偏移地址`[0]`综合计算之后得到物理地址 10000H ，并将内存中该处的值移动到 AL 寄存器中。

**注意**：

- 8086 CPU 不支持直接将数值送入到段寄存器中，需要用其他寄存器作中转



## 3. 数据段

和代码段类似，我们可以将一组长度为 $N(N\leqslant 64KB)$、地址连续、起始地址为 16 的倍数的内存单元当作专门存储数据的内存空间，从而定一个数据段。

在具体操作时，用 DS 存放数据段的段地址，再根据需要，用相关指令即可访问数据段中的具体单元。



# 四. SS 和 SP

## 1. 简介

我们可以将一段内存当作栈来使用，我们可以使用`push`指令将数据送入这个指定的栈中，也可以使用`pop`指令将栈顶的数据送出到操作数指定的位置。

而作为栈的这段内存就由 SS 寄存器和 SP 寄存器来设置。

SS 存放栈内存段的段地址，SP 存放栈内存段的偏移地址。其中 SP 在第一次设置之后将会自动变化，当执行`push`和`pop`指令后它都会有变化，在任意时刻，SS:SP 都将指向栈顶元素。

在栈段中，有几个位置需要注意：

- **栈底**：栈将以栈段的最高地址作为栈底，当栈为空时，SS:SP 将指向这个地址的下一个内存单元，该位置在栈外。
- **栈顶**：即从栈底开始保存数据，所有数据中最顶端（已使用内存中地址最低）的一个存储单元作为栈顶，当栈满时，SS:SP 将指向栈段内存中最低地址的内存单元，该位置在栈内。
- **越界**：当 SS:SP 的位置不在从栈底到栈顶的空间内时，此时执行`push`指令将会导致其他未知位置的数据遭到覆盖，如果执行`pop`指令将会把未知位置的数据送入到指定位置中。



## 2. 相关指令

| 指令名称 | 使用方法                                                | 效果                                           |
| -------- | ------------------------------------------------------- | ---------------------------------------------- |
| push     | `push 寄存器`<br />`push 内存单元`<br />`push 段寄存器` | 将操作数中的值入栈                             |
| pop      | `pop 寄存器`<br />`pop 内存单元`<br />`push 段寄存器`   | 将栈顶元素出栈，并将其送入到操作数指定的位置中 |

**注意**：

- `push`和`pop`指令都只适用于字宽的操作，不能用于字节宽的操作



## 3. 栈段

和其他内存段类似，我们可以将长度为 $N(N\leqslant 64KB)$ 的一组地址连续、起始地址为 16 的倍数的内存单元，当作栈空间来用，从而定义了一个栈段。

我们需要调整 SS、SP 的值将其指向该栈段的栈底，才能开始使用该栈段。