# 一. 简介

**过程**是软件中一种很重要的抽象。它提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现了某种功能。然后，可以在程序中不同的地方调用这个函数。设计良好的软件用过程作为抽象机制，隐藏某个行为的具体实现，同时又提供清晰简洁的接口定义，说明要计算的是哪些值，过程会对程序状态产生什么样的影响。

在不同的编程语言中，过程的形式不同，有：函数（function）、方法（method）、子例程（subroutine）、处理函数（handler）等等，但是它们有一些共同的特性。

假设过程 P 调用过程 Q，Q 执行后返回到 P。这些动作包括下面一个或多个机制：

- **传递控制**：在进入过程 Q 的时候，程序计数器必须被设置为 Q 的代码的起始地址，然后在返回时，要把程序计数器设置为 P 中调用 Q 后面那条指令的地址
- **传递数据**：P 必须能够向 Q 提供一个或多个参数， Q 必须能够向 P 返回一个值
- **分配和释放内存**：在开始时，Q 可能需要为局部变量分配空间，而在返回前，又必须释放这些存储空间。



# 二. 控制

## 1. 运行时栈

C 语言过程调用机制的一个关键特性（大多数其他语言也是如此）在于使用了栈数据结构提供的后进先出的内存管理原则。在过程 P 调用过程 Q 的例子中，可以看到当 Q 在执行时，P 以及所有在向上追溯到 P 的调用链的过程中，都是暂时被挂起的。当 Q 运行时，它只需要为局部变量分配新的存储空间，或者设置到另一个过程的调用。另一方面，当 Q 返回时，任何它所分配的局部存储空间都可以被释放。因此，程序可以用栈来管理它的过程所需要的存储空间，栈和程序寄存器存放着传递控制和数据、分配内存所需要的信息。当 P 调用 Q 时，控制和数据信息添加到栈尾。当 P 返回时，这些信息会释放掉。

在数据栈中，只需要栈指针`%rsp`向栈顶方向增长就分配出一段空间，而向栈底方向增长就释放一段空间。在运行时栈中也一样，具体的运行时栈如下图所示：

![图片](https://user-images.githubusercontent.com/91216205/217459289-2a4a0e6e-9cf3-40cd-951f-409663fd66b2.png)

图中上方为栈底，下方为栈顶，其中第一部分就是调用 P 之前分配的空间，第二部分就是调用 P 之后，P 过程使用的空间，而第三部分也就是 P 调用的 Q 所使用的空间。这三部分都有同一个名字：**栈帧**（stack frame）。

从图中可以知道以下几点：

- 当前正在执行的过程的帧总是在栈顶
- 当过程 P 调用过程 Q 时，会把返回地址压入栈中，指明当 Q 返回时，要从 P 程序的哪个位置继续执行。我们把这个返回地址当作 P 的栈帧的一部分，因为它存放的是与 P 相关的状态。
- Q 的代码会扩展当前栈的边界，分配它的栈帧所需的空间。在这个空间中，它可以保存寄存器的值，分配局部变量空间，为它调用的过程设置参数。

另外，大多数过程的栈帧都是定长的，在过程的开始就分配好了。但是有些过程需要变长的帧。

通过寄存器，过程 P 可以传递最多 6 个（因为只有 6 个寄存器是用来保存参数的）整数值（也就是指针和整数），但是如果 Q 需要更多的参数， P 可以在调用 Q 之前在自己的栈帧里存储好这些参数。

为了提高空间和时间效率，x86-64 过程值分配自己所需要的栈帧部分。例如，许多过程有 6 个或者更少的参数，那么所有的参数都可以通过寄存器传递。因此，上图中画出的某些栈帧部分可以省略。实际上，许多函数甚至根本不需要栈帧，当所有的局部变量都可以保存在寄存器中，而且该函数不会调用任何其他函数，就可以这样处理。



## 2. 转移控制

简单来说，使用 `call` 和 `ret` 指令可以完成一个过程的调用和返回。

`call` 指令首先记录好它要继续的 P 的执行的代码位置，即将这个地址压入 P 的栈帧中，然后将程序计数器（PC）设置为 Q 的起始地址。

`ret` 指令则从栈中弹出保存好的返回地址，然后把 PC 设置为这个地址



# 三. 数据传送

