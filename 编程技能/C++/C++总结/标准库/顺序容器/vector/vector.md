# 一. 简介

`vector`表示对象的集合，其中所有对象的类型都相同。

`vector`是一个**类模板**，需要**实例化**才能使用，`vector`实例化的方法如下：

```c++
vector<int> ivec;				// ivec保存int类型的对象
vector<Sales_item> Sales_vec;	 // Sales_vec保存Sales_item类型的对象
vector<vector<string>> file;	 // file保存vector<string>类型的对象，每个元素也是一个集合，保存string类型的对象
```



# 二. 使用准备

```c++
#include <vector>		// vector类头文件
using std::vector;		// vector类型说明符
```



# 三. 定义和初始化

`vector`对象的定义及初始化方法如下：

- `T`：一种类型

| 方式                           | 效果                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| `vector<T> v1`                 | 默认初始化，`v1`是一个空`vector`                             |
| `vector<T> v2(v1)`             | 将`v1`拷贝到`v2`                                             |
| `vector<T> v2 = v1`            | 将`v1`拷贝到`v2`                                             |
| `vector<T> v3(n, val)`         | 用`n`个`val`初始化`v3`                                       |
| `vector<T> v4(n)`              | 用`n`个重复执行了值初始化的对象初始化`v4`(即每个元素执行默认初始化) |
| `vector<T> v5{a, b, c...}`     | 用列表初始值初始化`v5`                                       |
| `vector<T> v5 = {a, b, c...}`  | 用列表初始值初始化`v5`                                       |
| `vector<T> v6(T* beg, T* end)` | 主要适用于通过数组初始化`vector`对象，首先类型要相同，其次用于初始化的元素是从`beg`指向的元素（包含）到`end`指向的元素（不包含）。在使用时需要确保两个指针都 |

**注意**：

使用列表初始化的时候，若需要初始化的对象不是数值类型，但第一个参数提供了一个非负整数，且列表总共只有不多于两个参数，此时列表初始化将被视为构造初始化（若只有一个非负整数的参数，则该参数提供元素个数，元素值进行默认初始化）。其他情况将产生错误。



# 四. 操作

下表列出了`vector`类型支持的一些操作：

- `v`：一个`vector<T>`对象

| 操作                             | 效果                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| `v.empty()`                      | 返回`bool`值，若`v`中不含有任何元素，返回`true`，否则返回`false` |
| `v.size()`                       | 返回`vector<T>::size_type`类型，返回`v`中元素的个数          |
| `v.push_back(t)`                 | 操作：向`v`的尾端添加一个值为`t`的元素                       |
| `v.begin()`                      | 返回`vector<T>::iterator`或`vector<T>::const_iterator`类型，返回指向`v`第一个元素的迭代器 |
| `v.end()`                        | 返回`vector<T>::iterator`或`vector<T>::const_iterator`类型，返回`v`的尾后迭代器 |
| `v[n]`                           | 返回`v`中第`n`个位置上元素的引用，位置`n`从0开始             |
| `v1 = v2`                        | 用`v2`为`v1`赋值                                             |
| `v1 = {a, b, c...}`              | 用列表为`v1`赋值                                             |
| `v1 == v2`<br />`v1 != v2`       | 返回`bool`值，当且仅当它们的元素数量相同且对应位置的元素值都相同时`v1`和`v2`相等，返回`true`，否则返回`false` |
| `<`<br />`<=`<br />`>`<br />`>=` | 以字典顺序进行比较。<br />1. 只有当元素的值可以比较时，`vector`对象才能被比较。<br />2. 如果两个`vector`对象的容量不同，但是在相同位置上的元素值都一样，则元素较少的`vector`对象小于元素较多的`vector`对象；若元素的值有区别，则`vector`对象的大小关系由第一对相异的元素值的大小关系决定 |



# 五. 处理元素

`vector`类型的对象同样可以通过**下标访问**、**范围for**和**迭代器**来处理`vector`对象中的元素。

## 1. 下标访问

**注意**：不能通过下标来添加元素，也就是说不能对越界下标进行操作。



## 2. 范围for循环

```c++
vector<int> ival(10, 5);		// ival包含10个值为5的int对象
for (auto &c : ival) {
    c = 2;
}							  // 将ival中每个元素更改为2
```

**注意**：

1. 当不需要更改元素值时，不要使用引用类型
2. 可以使用`auto`来声明循环控制变量
3. 使用范围`for`语句不要更改`vector`的元素个数



## 3. 迭代器

```c++
vector<int> ival(10, 5);
for (auto beg = ival.begin(), end = ival.end(); beg != end; beg++) {
    cout << *beg << endl;
}
```

