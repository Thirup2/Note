# 一. 无返回值和有返回值函数

`return`语句有两种形式：

```c++
return;
return expression;
```

前者用于返回类型为`void`类型的函数，即无返回值的函数；后者用于除此之外的有返回值的函数。

## 1. 无返回值函数

返回`void`的函数不要求非得有`return`语句，因为在这类函数的最后一句后面会隐式地执行`return`。

通常情况下，`void`函数如果想在它的中间位置提前退出，可以使用`return`语句，一般使用第一种形式的`return`语句，如果使用第二种形式的`return`语句，则`expression`必须是另一个返回`void`的函数。强行令`void`函数返回其他类型的表达式将产生编译错误。

## 2. 有返回值函数

只要函数的返回类型不是`void`，则该函数内的每条`return`语句必须返回一个值。

`return`语句返回值的类型必须与函数的返回类型相同，或者能隐式地转换成函数的返回类型。C++可以保证每个`return`语句的结果类型正确。

有返回值函数应该确保在函数执行的所有情况都可以通过`return`语句退出。

### **注意**：

1. 不要返回局部对象的引用或指针：函数完成后，它所占用的存储空间也随之被释放掉，这意味着局部变量的引用或指针将指向不再有效的内存区域
2. 引用返回左值：当函数返回一个非常量引用时，将得到一个左值，也就是说表达式可以写成函数放在赋值符左边。对于常量引用，其本身就不允许操作，所以无所谓是否是左值



# 二. 值得注意的返回类型

## 1. 列表初始化返回值

C++11新标准规定，函数可以返回花括号包围的值的列表。如果列表为空，则返回一个值初始化的临时量作为函数的值；否则，返回的值由函数的返回类型决定。

如果函数返回的是内置类型，则花括号包围的列表最多包含一个值，而且该值所占空间不应该大于目标类型的空间。如果函数返回的是类类型，类本身定义初始值如何使用。

```c++
vector<string> process()
{
    // ...
    // expected和actual是string对象
    if (expected.empty())
        return {};
    else if (expected == actual)
        return {"functionX", "okay"};
    else
        return {"functionX", expected, actual};
}
```

## 2. 主函数main的返回值

`main`函数可以没有`return`语句，如果没有`return`语句，编译器将隐式地插入一条返回0的`return`语句。

`main`函数返回的值表示程序执行的状态，返回0表示执行成功，返回其他值表示执行失败，其中非0值的具体含义依机器而定。

`cstdlib`头文件中定义了两个预处理变量表示执行成功与失败：`EXIT_SUCCESS`和`EXIT_FAILURE`

## 3. 返回数组

### 1）返回格式

```c++
Type array[dimension];
// ...
// 函数签名
{
    // 函数体
    return array;
}
```

### 2）函数签名

```c++
Type (*function(parameter_list))[dimension]
```

`function`是一个函数，该函数返回一个指针，该指针是一个指向数组的指针，数组的大小由`dimension`规定，数组的类型为`Type`。

也就是说，`function`函数返回一个指向一个`Type`类型数组的指针

### 3）声明简化

- 使用别名

  ```c++
  typedef int arrT[10];
  using arrT = int[10];
  
  arrT* func(int i);
  // 等价于
  int *func(int i)[10];
  ```

- 使用尾置返回类型

  使用`auto`替代返回类型，然后将函数的真正返回类型通过`->`连接在函数签名后面

  ```c++
  auto func(int i) -> int(*)[10];
  ```

- 使用`decltype`

  当我们直到函数返回的指针将指向哪个数组的类型，就可以使用`decltype`关键字声明返回类型

  ```c++
  int odd[] = {1, 3, 5, 7, 9};
  int even[] = {0, 2, 4, 6, 8};
  decltype(odd) *arrPtr(int i)
  {
      return (i % 2) ? &odd : &even;
  }
  ```

  **注意**：`decltype`并不负责把数组类型转换成对应的指针，所以`decltype`的结果是个数组，要想表示`arrPtr`返回指针还必须在函数声明时加一个`*`符号。