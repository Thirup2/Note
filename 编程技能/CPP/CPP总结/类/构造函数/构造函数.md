# 一. 简介

构造函数是一类特殊的成员函数，它负责一项工作，那就是创建一个类对象并初始化它。

其声明方式、定义方式以及调用方式都与一般的函数有所区别。



# 二. 语法

## 1. 声明

一个构造函数的声明需要满足以下条件，当然大部分条件定义也必须满足：

1. 构造函数的名字与类名相同
2. 构造函数没有返回类型
3. 构造函数不能被声明成`const`的，因为初始化完成之后，一个对象才能获得其“常量”属性

其格式如下：

```c++
ClassName(<Para-List>);
```

一般某个类都会有多种初始化的方式，这可以通过重载构造函数来实现。



## 2. 定义

### 1）类内定义

类内定义就是将类内函数声明加上函数体构成定义，其初始值列表也属于定义。

对于默认与非默认构造函数，其定义方式可能有以下几类：

- 合成的默认构造函数显式定义

  ```c++
  ClassName() = default;
  ```

  其效果与合成的默认构造函数相同，之所以这样定义而不直接使用合成的默认构造函数是因为如果使用合成的默认构造函数意味着我们不能定义任何其他构造函数，所以显式地定义一个合成的默认构造函数，一般都意味着我们既需要一个合成的默认构造函数，也需要一些其他的构造函数。

  另外，当`default`出现在类内部时，那么默认构造函数是内联的。

- 非合成的默认构造函数

  ```c++
  ClassName() : Init-List {}
  ```

  通过初始值列表为类的数据成员设置初始值，其效果一般与提供类内初始值的合成默认构造函数效果相同。同样，它一般也意味着我们既需要默认构造函数，也需要其他的构造函数。

- 一般的构造函数

  ```c++
  ClassName(Para-List) : <Init-List> {}
  ```

  对于这类函数而言，一般传入的参数都是用作初始值列表的初始值。其初始值列表并非必要，因为有时会通过函数体来为成员赋值。



### 2）类外定义

和成员函数相同，构造函数的类外定义只需要在函数名之前添加一个作用域运算符即可，其余格式与类内定义相同。如果返回类型为类内定义的类型，也需要添加一个作用域运算符。

如：

```c++
class ClassName
{
    /* ... */
    ClassName();
    ClassName(Para-List);
    /* ... */
};
ClassName::ClassName() = default; /* 或 */ ClassName() : <Init-List> {/* 构造函数体 */}
ClassName::ClassName(Para-List) : <Init-List> {/* 构造函数体 */}
```

当`=default`出现在类外时，默认构造函数是非内联的。



# 三. 构造函数初始值列表

构造函数的函数体一般并不是用来初始化数据成员的，而是通过一个特殊的列表，叫做构造函数初始值列表来初始化类的数据成员。

它负责为新创建的对象的一个或几个数据成员赋初值。它是成员名字的一个列表，每个名字后面紧跟括号括起来（或者花括号括起来）的成员初始值，成员之间用逗号隔开。其格式如下：

```c++
ClassName() : Item1(Value1), Item2(Value2) {}
```

没包含在初始值列表中的数据成员按照与合成默认构造函数相同的方式隐式初始化。

构造函数初始值列表具有以下的一些特性：

## 1. 特殊性

为什么要使用初始值列表，而不是在函数体内进行初始化的操作？这与C++的机制有关。

首先，我们都知道一个对象的初始化和先创建再赋值是有区别的。而构造函数的初始值列表和函数体就体现了这一点区别。

如果使用初始值列表，那么调用构造函数时，会在创建对象的同时用初始值列表对成员进行初始化；如果不使用初始值列表，而是使用函数体进行“初始化”操作的话，构造函数会先对对象进行默认初始化，然后再执行函数体中的内容。



## 2. 必要性

有时，提供一个初始值列表是必要的，如数据成员包含一个`const`成员，对于`const`成员，在函数体内进行赋值的操作是不被允许的。

一些必须要初始化的类型如下：

- `const`类型
- 引用类型
- 没有定义默认构造函数的类类型（即不存在默认构造函数，如定义了非默认构造函数但是又不显式定义默认构造函数）



## 3. 默认有序

首先，在构造函数初始值中每个成员只能出现一次。

其次，是在我们编写构造函数时，不需要考虑每一个成员编写的顺序，成员的初始化顺序与他们在类定义中的出现顺序一致。也就是说，初始值列表中初始值的顺序并不会影响成员初始化的顺序。

这个特性用到的机会不多，但是有：有时我们会用一个成员去初始化另一个成员，此时两个成员的初始化顺序就显得很重要了，很明显应该先初始化第一个成员，再用第一个成员去初始化第二个成员，所以第一个成员在类定义中应该放在第二个成员之前。

一个可以很好的注意这一点的方法是：将初始值列表的顺序安排得和类定义中数据成员出现的顺序相同。



# 四. 默认实参与构造函数

构造函数同样可以为参数提供默认实参，通过默认实参，我们可以实现一种功能，就是将一个构造函数既是非默认构造函数，又是默认构造函数。

当为一个构造函数的所有参数都提供了默认实参时，该函数就可以同时为我们提供一个默认构造函数，如下所示：

```c++
class Sales_data
{
public:
    Sales_data(std::string s = "") : bookNo(s) { }		// 为s提供了一个值为空串的默认实参
    /* ... */
};
```



# 五. 委托构造函数

**委托构造函数**就是使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些（或者全部）职责委托给了其他构造函数。

其格式主要体现在初始值列表上，在其他部分，都和一般的构造函数相同，都有相同的函数名和不同的一个参数列表，以及一个函数体。

其初始值列表与其他构造函数的不同点在于，委托构造函数的初始值列表只有一个唯一的入口，就是另一个构造函数，其格式如下：

```c++
class Sales_data
{
public:
    Sales_data(std::string s, unsigned cnt, double price) : bookNo(s), units_sold(cnt), revenue(cnt * price) { }	// 非委托构造函数
    
    Sales_data() : Sales_data("", 0, 0) {}							  // 委托第一个构造函数按照提供的三个参数进行初始化，同时该函数提供了一个默认构造函数
    Sales_data(std::string s) : Sales_data(s, 0, 0) {} 				 // 委托第一个函数进行初始化，这次需要一个string对象作为参数
    Sales_data(std::istream &is) : Sales_data() { read(is, *this); }	// 同样委托第一个函数进行初始化，需要一个输入流作为参数
}
```

需要注意的是，进行委托的构造函数必须要提供能够确实其他构造函数的参数。



# 六. 默认构造函数

## 1. 简介

如果我们没有显式地提供一个构造函数，那么类会通过一个特殊的构造函数来控制默认初始化过程，这个函数叫做**默认构造函数**。其无须任何实参。

这个默认构造函数一般是由编译器为我们隐式地定义的（前提是没有显式地定义构造函数），其又被称为**合成的默认构造函数**。当我们定义了一些其他的构造函数时，我们必须自行定义一个默认的构造函数，否则类将没有默认构造函数。

>  对于大多数类来说，这个合成的默认构造函数将按照如下规则初始化类的数据成员：
>
>  - 如果存在类内的初始值，则用它来初始化成员
>  - 否则，默认初始化该成员

> 对于一些特殊的类，我们不能使用合成的默认构造函数：
>
> - 当类包含一些没有给定类内初始值的内置类型或复合类型的数据成员时，因为会被执行默认初始化，其值为未定义
> - 当类中包含一个其他类类型的成员且这个成员的类型没有默认构造函数时，编译器将无法初始化该成员

可以显式地声明一个默认构造函数，其格式如下：

```c++
ClassName() = default;
```

该函数的效果与合成的默认构造函数完全相同。

也可以定义一个不同于合成的默认构造函数的默认构造函数，其方法是提供一个初始值列表：

```c++
ClassName() : Init-List {};
```



## 2. 默认构造函数的作用

拥有默认构造函数的类在某些地方也能发挥作用，即当对象被默认初始化或值初始化时自动执行默认构造函数。

对于类来说，其对象被默认初始化或值初始化有以下情况：

- 当一个类本身含有类类型的成员且使用合成的默认构造函数时，该类所包含的类会被默认初始化，自动调用默认构造函数
- 当类类型的成员没有在构造函数初始值列表中显式地初始化时，该类对象会进行默认初始化，自动调用默认构造函数
- 当我们通过书写形如`ClassName()`的表达式显式的请求值初始化时，对象进行值初始化