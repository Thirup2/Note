# 一. 简介

对于顺序容器，都可以使用**迭代器**来访问其基本元素。

迭代器类似于指针类型，提供了对对象的间接访问，并且能够通过迭代器访问对象。

迭代器与指针类似，也有有效和无效之分，有效的迭代器指向某个元素或者指向容器中尾元素的下一位置；其他所有的情况都属于无效。



# 二. 获取迭代器

对于顺序容器类型来说，都有返回迭代器的成员（如`begin()`、`end()`），可以通过这些成员来获取一个迭代器

```c++
vector<int> ival(10, 5);
auto beg = ival.begin;
auto end = ival.end;
```



# 三. 操作

下表列举了一些迭代器的操作：

- `iter`：一个迭代器

| 操作                                   | 效果                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| `*iter`                                | 返回迭代器`iter`所指元素的引用                               |
| `iter->mem`                            | 解引用`iter`并获取该元素的名为`mem`的成员，等价于`(*iter).mem` |
| `++iter`                               | 令`iter`指示容器中的下一个元素                               |
| `--iter`                               | 令`iter`指示容器中的上一个元素（`forward_list`不支持）       |
| `iter1 == iter2`<br />`iter1 != iter2` | 判断两个迭代器是否相等(不相等)<br />当两个迭代器指示的是同一个元素或者它们是同一个容器的尾后迭代器则相等，返回`true`；否则，则不相等，返回`false` |

**注意**：

1. 执行解引用的迭代器必须合法并确实指示着某个元素
2. 迭代器有`iterator`和`const_iterator`两种类型，对于前者，可以对其指向的对象进行读写操作；对于后者，只能对其指向的对象进行读操作
3. 如果`vector`对象改变了元素个数，则该对象之前的迭代器将会失效



# 四. 其他操作

下表列出了`vector`和`string`对象支持的其他操作：（`list`和`forward_list`不支持）

| 操作                             | 效果                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| `iter + n`                       | 返回一个迭代器，指向`iter`之后第`n`个元素或尾后位置，需要自行确定迭代器的有效性 |
| `iter - n`                       | 返回一个迭代器，指向`iter`之前第`n`个元素，需要自行确定迭代器的有效性 |
| `iter += n`                      | 将迭代器向后移动`n`个元素，需要自己保证迭代器的有效性        |
| `iter -= n`                      | 将迭代器向前移动`n`个元素，需要自己保证迭代器的有效性        |
| `iter1 - iter2`                  | 返回`string::difference_type`或`vector<T>::difference_type`类型，返回两个迭代器所指的元素之间相隔的元素个数 |
| `<`<br />`<=`<br />`>`<br />`>=` | 当两指针指向同一容器的元素或尾后位置时，当某个迭代器指向的容器位置在另一个迭代器所指的位置之前，则说前者小于后者。 |



# 五. 注意事项

## 1. 迭代器范围

一个 **迭代器范围**（iterator range）由一对迭代器表示，两个迭代器分别指向同一个容器中的元素或是尾元素之后的位置。这两个迭代器通常被称为 `begin` 和 `end`。`begin` 指向容器中的第一个元素，`end` 指向容器中最后一个元素之后的位置。

迭代器范围中的元素包含 `begin` 所表示的元素以及从 `begin` 开始直至 `end`（但不包含 `end`）之间的所有元素。即**左闭合区间**（left-inclusive interval），$[begin, end)$

我们需要确保这两个迭代器满足下面的要求：

- 它们指向同一个容器中的元素，或者是容器最后一个元素之后的位置，且
- 我们可以通过反复递增 `begin` 来到达 `end`。也就是说，`end` 不在 `begin` 之前



## 2. 使用左闭合范围蕴含的编程假定

之所以`begin`指向第一个元素，而`end`指向最后一个元素之后的位置，是因为这种范围有三种方便的性质：

- 如果`begin`和`end`相等，则范围为空
- 如果`begin`和`end`不等，则范围至少包含一个元素，且`begin`指向该范围中的第一个元素
- 我们可以对`begin`递增若干次，使得`begin==end`

也就是我们可以如下使用循环：

```c++
while (begin != end) {
    *begin = val;
    ++begin;
}
```

