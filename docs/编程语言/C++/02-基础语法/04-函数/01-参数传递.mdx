在 C 语言中，参数传递只存在**值传递**这一种传递方式，即实参的值被拷贝给形参，形参和实参是两个独立的对象。这种调用方式称为**传值调用**。

而在 C++ 中，由于引用类型的存在，参数传递还存在一种形式。当形参是引用类型时，这种传递就称为**引用传递**，形参只是实参的一个别名。这种调用方式称为**传引用调用**。

将形参和实参理解成一个初始化语句对理解参数传递很有帮助。形参是一个声明语句，还不完全是初始化，但当我们调用函数时提供了实参，初始值就被补充了，此时可以将形参看成一个以实参为初始值的初始化语句。其要求和效果就和一个初始化语句的要求和效果相同。



## 一、参数传递

### 1、传值参数

值传递时的形参是一个和实参独立的对象，所以无论对该形参执行怎样的操作都不会影响到实参对象。

需要格外注意的是指针传递。当我们传递的参数是一个指针时，对指针的一些操作会改变原来的对象，但实际上这还是一个值传递。当我们的形参是一个指针时，它和实参仍然是相互独立的两个对象，当我们改变形参指针指向的时候，实参指针的指向并不会改变。但由于它们保存内存地址，所以可以通过指针间接操作该内存地址的对象。



### 2、传引用参数

引用传递时的形参是实参的一个别名，需要满足定义引用时的要求，即实参类型必须和形参完全匹配，或使用`const`引用形参。

通过使用引用形参，可以达到和使用指针形参类似的效果，但引用并非一个对象，对引用本身执行的操作全是对形参所绑定的对象执行的操作。

**使用引用避免拷贝**：

使用引用可以有效的避免形参的拷贝操作，这样有两个优点：

- 拷贝大的类类型对象或者容器对象时比较低效
- 有的类类型不支持拷贝操作

但相对来说，也有一个缺点，即有可能会导致不应该被修改的原值被修改。解决这一点的方法就是对于无须改变值的形参，最好将其声明为常量引用。

**使用引用形参返回额外信息**

一个函数只能返回一个值，而通过引用形参我们可以在效果上实现返回多个值（指针形参也可以达到相同的效果）。



## 二、数组形参

由于数组不允许拷贝的性质，所以不能直接传递数组，但可以通过以下几种方式间接地传递数组

- 指向元素的指针+确定范围的方法：由于数组名可以转换为指向其首元素的指针，所以我们可以这样用，传递的实参仍然可以使用数组名。除了指向其首元素的指针，我们还需要一个确定数组范围的方法，否则我们会很容易出现不合法的内存访问，具体来说，有以下几种确定方法：

  - 传递首元素指针以及数组大小
  - 传递首元素指针和尾元素后指针
  - 若数组是一个 C 风格字符串，则可以不用传递额外的参数，数组以`'\0'`结尾。

  > 传递指向数组元素指针的具体写法有几种：
  >
  > ```cpp
  > void print(const int*);
  > void print(const int[]);
  > void print(const int[10]);
  > ```
  >
  > 这三种写法实际上是等价的，也就是说即使使用第二种方法，形参也并不是一个数组，包括第三种方法，`[]`中的数组并不起任何作用。

- 指向数组整体的指针或引用：可以将形参声明为指向数组整体的指针或引用

  ```cpp
  void print(int (*arr)[10]);
  void print(int (&arr)[10]);
  ```

  对于指向数组整体的指针，在提供实参时需要对数组本身使用取地址符，即：`&arr`；

  对于与数组整体绑定的引用，在提供实参时使用数组名即可。
  
  和传递指向数组首元素指针的方法相比，这种方法唯一的缺点就是只能传入定长的数组。

:::info 是否支持范围 for 语句

对于传递指向首元素指针的方法，这样的形参并不能使用范围`for`语句进行处理，因为在函数的尺度上来看，这并不是一个数组，仅仅是一个指针，针对这个指针，也无法使用`begin`和`end`函数获取迭代器指针。

对于传递指向整个数组指针的方法，对这个指针解引用之后可以使用范围`for`语句进行处理。

对于传递与整个数组的引用的方法，可以直接对这个引用使用范围`for`语句。

:::



## 三、命令行参数

`main`函数有两种版本，一种是我们常用的空参数列表版本，一种是接受命令行参数的版本：

```cpp
int main(int argc, char *argv[]);
```

第一个参数是包括程序名在内的命令行参数的数量，第二个参数是一个 C 风格字符串的数组，其保存了包括程序名在内各个命令行参数。

假设程序名是`prog`，在添加了处理命令行参数的代码后，我们可以像下面这样调用这个程序：

```cpp
prog -d -o ofile data0
```

这样的调用会将`main`函数的`argc`参数初始化为`5`，而`argv`所保存的内容应该是：

```cpp
argv[0] = "prog";
argv[1] = "-d";
argv[2] = "-o";
argv[3] = "ofile";
argv[4] = "data0";
```

为了更安全地使用命令行参数，C++ 的`argv`数组最后一个元素之后的元素值为 0，也就是一个空指针，而不指向任何字符串，即：

```cpp
argv[5] = 0;
```



## 四、可变形参

函数可以通过一些方法接受可变数量的实参。

如果所有的实参类型相同，可以传递一个名为`initializer_list`的标准库类型，这种类型的对象用来保存某种特定类型的值的数组。`initializer_list`是一个类模板，使用时需要进行实例化。下面是`initializer_list`支持的操作：

| 操作                                  | 效果                                                         |
| ------------------------------------- | ------------------------------------------------------------ |
| `initializer_list<T> lst;`            | 默认初始化，空列表                                           |
| `initializer_list<T> lst{a, b, c...}` | 用列表元素初始化`lst`                                        |
| `lst2(lst)`<br />`lst2 = lst`         | 拷贝`lst`对象为`lst2`。<br />表中的元素不会被拷贝，二者共用同一批元素 |
| `lst.size()`                          | 列表中的元素数量                                             |
| `lst.begin()`                         | 返回指向`lst`中首元素的指针                                  |
| `lst.end()`                           | 返回指向`lst`中尾元素下一位置的指针                          |

需要格外注意的是第三个操作，拷贝一个`initializer_list`对象并不会拷贝其元素，同时除了初始化和赋值语句之外，也不存在其他的修改其中元素的手段。

提供实参时要么提供一个相同类型的对象，要么提供一个花括号包裹着的值的序列。

另外，含有`initializer_list`形参的函数也可以同时拥有其他形参，没有数量和顺序上的要求。

一个使用`initializer_list`形参的函数示例如下：

```cpp
void error_msg(int error_num, initializer_list<string> il);
```

对于这个函数的调用形式如下：

```cpp
error_msg(42, {"functionX", "okay"});
```



### C 语言兼容省略符形参

省略符形参是为了便于 C++ 程序访问某些特殊的 C 代码而设置的，这些代码使用了名为`varargs`的 C 标准库功能。省略符形参应该仅仅用于 C 和 C++ 通用的类型。特别应该注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝。

省略符形参即：`...`，它只能出现在形参列表的最后一个位置，其形式仅下面两种：

```cpp
void foo(para_list, ...);
void foo(...);
```

关于省略符形参的使用参考 C 编译器文档。