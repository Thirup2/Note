## 一、发生的时机

在下面这些情况下，编译器会自动地转换运算对象的类型：

**算术转换**：

- 在大多数表达式中，比`int`类型小的整型值首先提升为较大的整数类型（整型提升）
- 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型

**其余转换**：

- 在条件中，非布尔值转换为布尔类型
- 初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型
- 函数调用时会发生类型转换



## 二、算术转换

### 1. 整型提升

当运算符的运算对象类型不一致时，对于所有运算对象都是整数的情况，将首先进行整型提升。

**整型提升**负责把小整数类型转换成较大的整数类型。

`bool`、`char`、`signed char`、`unsigned char`、`short`以及`unsigned short`等类型，只要它们所保存的值能够保存在`int`中，它们就会提升成`int`类型，否则，提升成`unsigned int`类型。

如果是较大的`char`类型（`wchar_t`、`char16_t`、`char32_t`）则提升成`int`、`unsigned int`、`long`、`unsigned long`、`long long`、`unsigned long long`中能容纳原值的最小的一种类型。

而对于`long`、`unsigned long`、`long long`、`unsigned long long`类型则保持原类型



### 2. 整型转换

当一个运算符的运算对象类型不一致，对于所有运算对象都是整数的情况，在整型提升之后，如果所有运算对象的类型一致，则无需进行额外的转换。

如果所有运算对象的类型仍然不一致，则根据以下情况进行转换：

- 所有运算对象虽然类型不一致，但都是带符号的或都是无符号的，则小类型的运算对象转换成较大的类型。
- 当运算对象有带符号的也有无符号的情况时
  - 当无符号类型不小于带符号类型时，带符号类型的运算对象转换为无符号的（需要注意如果带符号类型的运算对象刚好是负值，则会导致错误转换）
  - 当带符号类型大于无符号类型时，此时的转换结果依赖于机器。（之所以依赖于机器是因为`int`、`long`、`long long`这三者的大小取决于机器）
    - 如果无符号类型的所有值都能存在该带符号类型中，则无符号类型的运算对象转换成带符号类型；
    - 如果不能，那么带符号类型的运算对象转换成无符号类型



### 3. 浮点转换

- 如果运算符的所有运算对象都是`float`类型，则无需转换
- 其余情况将非浮点类型转换为`double`，`float`也转换为`double`类型。
- 如果运算对象中有`long double`类型，则将所有类型转化为`long double`



## 三、其他隐式类型转换

### 1. 数组转换成指针

在大多数用到数组的表达式中，数组名自动转换成指向数组首元素的指针，以下列出的情况例外：

- 当数组被用作`decltype`关键字的参数
- 数组作为取地址符`&`、`sizeof`以及`typeid`等运算符的运算对象时
- 当一个指向数组的引用绑定到数组时，此数组也不会发生转换



### 2. 指针的转换

- 整数常量 0 以及字面值`nullptr`可以转换成任意指针类型
- 指向任意非常量的指针能转换成`void *`
- 指向任意对象的指针能转换成`const void *`



### 3. 转换成布尔类型

在任何需要`bool`类型值的地方算数类型或指针类型可以转换成布尔类型。



### 4. 转换成常量

在需要底层`const`的地方，可以将不具有底层`const`的变量转换成具有底层`const`的变量。



### 5. 类类型定义的转换

类类型能定义由编译器自动执行的转换（隐式转换），但编译器每次只能执行一步类类型的转换。

包括非`explicit`的接受一个参数的构造函数，以及重载的非`explicit`类型转换运算符。前者定义了从其他类型到类类型的隐式转换，后者定义了类类型到其他类型的隐式转换。

例如：在`string`类型中，C 风格字符串能够转换成`string`对象；在标准 IO 库中，输入输出流对象能够转换成`bool`类型值。