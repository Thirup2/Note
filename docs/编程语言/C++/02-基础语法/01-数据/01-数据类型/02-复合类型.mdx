## 一、引用（左值引用）

**用处**：引用为一个变量起了一个别名，这个别名与该变量的实体绑定在一起，且不允许修改。同时引用仅仅是一个别名，因为其不存在实体，所以同时也不允许声明引用类型的引用。

**声明**：使用`&`符号来声明引用，由于不允许修改其绑定对象，故必须进行初始化

```cpp
int ival = 1024;
// highlight-next-line
int &refVal = ival;		// refVal 与 ival 绑定
// error-next-line
int &refVal2;			// 错误：没有初始值
```

**引用的类型**：在 C++ 程序中，在需要单独写明某个引用的类型时，将声明的引用的名字摘除即引用的类型，例如`int &`就是上述例子的引用类型。

**初始值**：首先，初始值必须是一个对象而不能是字面值或者某个表达式的计算结果；其次，初始值的类型必须与引用的基础类型（即去掉`&`后剩下的类型）相同。（以上原则在`const`引用部分有例外）。

**使用**：几乎可以像使用其引用对象一样使用引用，包括赋值操作，不过其含义并非修改其绑定对象，因为几乎所有对引用的操作都是对其所绑定对象的直接操作。



## 二、指针

**用处**：指针是一个对象，其保存的值被当作地址进行处理（实际上也是一个整数类型，但比整数类型有更多的操作接口）。可以通过指针直接访问其地址所存在的数据。

**声明**：使用`*`符号来声明指针。如果是定义，不必在定义处进行初始化，但通常使用空指针或一个有意义的地址进行初始化更安全

```cpp
int ival = 42;
int *p;				// 执行默认初始化，在函数体外为 0，在函数体内为垃圾值即无效指针
int *p1 = nullptr;	// 空指针，等价于 0
int *p2 = &ival;	// p2 保存 ival 的地址，称为 p2 指向 ival
int *p3 = 0;		// 正确：空指针
int *p4 = 0x400000;	// 正确，但不推荐
// error-next-line
int *p5 = ival;		// 错误：不能用变量作为指针的初始值
```

**指针的类型**：和引用类似，在一条声明语句中除去变量名即指针的类型，上述例子中都是`int *`类型，此写法可以在程序中需要单独写明类型的地方使用。

> **特殊指针类型**
>
> - `void*`类型的指针可以接受对任何类型进行取地址操作所得到的初始值，但不能直接操作该类型指针所指的对象。
> - 指向指针的指针，例如`int **ptp`，`ptp`就是一个指向指针的指针类型，以此类推还可继续向下。

**初始值**：通常，指针的初始值也必须和指针的基础类型相同或是空指针类型。具体如下：

- 空指针：`nullptr`
- 变量地址：需要注意和引用不同，指针保存变量的地址，而不是变量的值，故需要对变量进行取址操作，即`&`+变量名，如`&ival`。
- 地址值：可以向指针直接提供一个地址的值，但除了 0 （空指针）之外都是危险的操作。

> **注意**：由于可以向指针直接提供一个整数值作为地址，可能有人会使用整数变量本身作为指针的初始值，但这样的初始化将会引发错误。

**使用**：指针首先是一个对象，它可以直接被赋值，也就是更换其指向的对象。另外我们也可以像使用其指向类型一样使用指针，前提是需要先对其进行解引用操作，即`*`+指针名，如`*p1`，这样的一个整体可以当作其指向对象一样进行使用。



## 三、数组

**用途**：数组是一个其他类型的容器，其大小固定，在创建数组时必须给出其大小，该值应该是一个常量表达式且大于 0。

**声明**：使用`[]`来声明数组。当元素类型必须给定初始值时数组也必须进行显式初始化。

```cpp
unsigned num = 42;
const unsigned cnt = num;
constexpr unsigned sz = 42;

int arr[10];		// 含有 10 个整数的数组
int *parr[sz];		// 含有 42 个 int* 类型的数组
// error-next-line
string bad[cnt];	// 错误：cnt 不是常量表达式
```

**初始化**：

- 如果元素类型允许进行默认初始化，此时不提供初始值，将对所有元素进行默认初始化。

- 用花括号形式的列表初始值对数组进行列表初始化，初始值数量应不超过数组维度。

  初始值从前往后向数组元素进行赋予初始值，当初始值元素个数小于数组大小时，未得到初始值的元素执行值初始化：

  ```cpp
  int arr[10] = {1, 2, 3};		// arr[0] = 1, arr[1] = 2, arr[2] = 3。其余元素值初始化为 0
  ```

  :::info C99 开始的指定初始化器

  在 C 语言中，从 C99 标准开始数组支持如下所示的语法：

  ```cpp
  int arr[10] = {1, 2, 3 ,[5] = 5, [9] = 9};
  ```

  即使用指定初始化器的形式指定被初始化的元素。

  但这项语法并未在 C++ 中得到应用，如果习惯于使用 C 语言中该语法的话，需要格外注意 C++ 中没有这一条语法规则。

  :::

- 如果提供了列表初始值，可以不用提供数组维度。数组的维度将自动设置为初始值的个数。

- 对于字符数组，可以提供字符串字面值作为初始值。需要注意的是数组的长度至少是“字符串长度+1”，包括最后一个空字符

**数组的类型**：由于运算符优先级问题，所以对数组元素的具体类型的理解可能会有困难。需要记住的是`[]`运算符相比与`*`和`&`运算符优先级更高。在此基础上观察几个例子：

```cpp
int arr[10];
int *parr[10];

int *ptrs[10];				// []优先级更高，故 ptrs 是一个数组。其元素是 int* 类型
int (*parr)[10];			// ()优先级更高，parr 先和 * 结合，表示 parr 是一个指针，指向 int[10] 类型
// error-next-line
int &refs[10];				// 错误：不存在引用的数组
int (&refarr)[10] = arr;	// refarr 是一个引用，与 int[10] 类型绑定
int *(&refparr)[10] = parr;	// refparr 是一个引用，与 int*[10] 类型绑定
```

需要注意的是包括维度在内都是数组的类型的一部分

**使用**：一个数组整体不允许拷贝和赋值，但允许向其单个元素进行拷贝和赋值。访问其元素的方法有下标、指针等，如果是为了迭代该数组，还可以使用范围`for`语句。当使用下标时，其下标的类型为`size_t`。

:::info 创建数组和使用数组时下标的区别

`size_t`类型通常是一个无符号类型。

在创建一个数组时，其下标一定是一个`size_t`类型，如果我们使用负数作为下标，则会报错。

我们知道数组名在很多时候等价于指向其首位元素的指针，所以我们在使用下标访问一个元素时，将总是会被展开为等价的指针访问形式，即：

```cpp
int arr[10];
int n = getn();

arr[n] = n;
// 将自动转换为以下语句：
*(arr + n) = n;
```

在这种情况下，数组的下标就可以是负数。由于这个特点，我们需要特别考虑下标是否合法，例如：

```cpp
int arr[10];
int *pi = &arr[2];	// 由于指针和数组的特殊关系，我们可以将 pi 当作数组使用

pi[0] = 1;			// 等价于 arr[2] = 1;
pi[-2] = 0;			// 等价于 arr[0] = 0;
// error-next-line
pi[8] = 10;			// 错误：等价于 arr[10] = 10, 超过了下标范围
```

需要注意的是，以上下标运算的规律只适用于数组，而不适用于其他实现了下标运算符的类类型。

:::

### 指针和数组

**数组名到指针的转换**：当我们使用数组名的时候，通常它将会转化为一个指向其元素类型的指针，且指向其第一个元素。等价于对其第一个元素取地址。如果我们要得到指向该数组整体的指针，则需要对数组名进行取地址，具体示例如下：

```cpp
int arr[10];

int *pi = arr;			// 等价于 int pi = &arr[0];
int (*pa)[10] = &arr;	// 此时 pa 指向整个数组
```

**auto 与 decltype**：对于`auto`，如果我们使用数组名做初始值，则会推断为指向数组元素的指针；对于`decltype`，如果我们使用数组名做推断用表达式，则严格返回该数组类型。

**数组中的指针操作**：指向数组元素的指针可以像迭代器一样使用，我们可以手动计算创建两个指针当作迭代器（首位迭代器、尾后迭代器）。也可以使用迭代器库提供的标准库函数`begin()`和`end()`来得到这两个指针。得到的指针可以像迭代器一样进行操作，并且如果两指针指向同一个数组中的元素，还可以进行相减操作，也就是指针还支持迭代器的附加操作。两个指针相减得到的结果类型是`ptrdiff_t`



### C 风格字符串

C 风格字符串即使用数组保存的字符串形式，必须包括最后的空字符才是一个完整的 C 风格字符串。

以空字符结尾的数组是一个 C 风格字符串，一个字符串字面值也是一个 C 风格字符串。数组名将转换为指向首元素的指针，字符串字面值也将返回一个指向其首元素的指针。

通过 C 语言标准库提供的字符串函数可以操作 C 风格字符串，在 C++ 中它们保存在`cstring`头文件中：

| 操作             | 效果                                                         |
| ---------------- | ------------------------------------------------------------ |
| `strlen(p)`      | 返回`p`的长度，空字符不计算在内                              |
| `strcmp(p1, p2)` | 比较`p1`和`p2`的相等性。如果`p1==p2`，返回 0；如果`p1>p2`返回一个正值；如果`p1<p2`返回一个负值 |
| `strcat(p1, p2)` | 将`p2`附加到`p1`之后，返回`p1`。需注意`p1`空间必须大于`strlen(p1) + strlen(p2)` |
| `strcpy(p1, p2)` | 将`p2`拷贝给`p1`，返回`p1`。需注意`p1`空间必须大于`strlen(p2)` |



### 多维数组

**声明方式**：在数组的声明符后继续添加`[]`即可声明一个元素为数组的数组

```cpp
int ia[3][4];	// ia 是包含 3 个元素的数组，每个元素包含 4 个 int
```

**初始化**：

- 对于多维数组的初始化，仍然可以只使用一个花括号，其中的初始值按照`[0][0]`、`[0][1]`...`[2][1]`、`[2][2]`的顺序进行初始化。对于没有提供初始值的元素将执行值初始化。更多维度以此类推。
- 也可以使用花括号内嵌套花括号的方式提供初始值，对于二维数组来说，内层的 1 个花括号就代表 1 行的初始值。更多维度以此类推。

