## 一、基础使用

**用途**：`const`用于定义一个有名字的常量，当程序需要一个保证不会变化的值时可以使用。之所以不用字面值，是因为当需要修改这个常量时不需要在每个地方都进行修改，只需在定义的地方修改一次。

**用法**：将`const`添加到正常的声明语句之前即可，例如：

```cpp
const int bufSize = 512;
// error-next-line
const double pi;		// 错误：未初始化
```

> **注意**：由于 const 常量定义之后不允许修改，所以必须进行给初始值。

**const 对象的链接属性**：默认状态下，const 对象仅在文件内有效。可以在定义前添加`extern`关键字将其修改为外部链接属性，同时在其他声明处也使用`extern`关键字（注意不要重复定义）。



## 二、const 引用

和之前一样，声明一个 const 引用即在正常引用声明语句前添加`const`关键字即可：

```cpp
const int a = 20;
const int &refa = a;
```

:::info 常量引用注意事项

和之前一样，常量引用仍是为对象创建一个别名，但无论被引用对象是否具有常量属性，当使用常量引用简介操作其绑定对象时，这个对象也被当作 const 常量来使用，即无法进行赋值等会导致其值被修改的操作。如果直接操作其绑定对象，则不受任何影响。

实际上由于引用并非一个实体，所以`const`关键字原本就是用来指定引用所绑定的对象的。

另外，一个常量引用可以使用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可，例如：

```cpp
int i = 42;
double dval = 3.14;
const int &r1 = i;
const int &r2 = 42;
const int &r3 = r1 * 2;
const int &ri = dval;
```

实际上，当初始值类型与引用类型不匹配时，C++ 将创建一个**临时量**对象，所以以`const int &r2 = 42;`为例，实际的过程实际如下：

```cpp
const int temp = 42;
const int &r2 = temp;
```

这样，一个 const 引用就并不与初始值本身绑定了，而是绑定在一个临时量上，但由于并不会（也无法）修改这个值，所以没什么影响。

:::



## 三、const 和指针

**const 对于指针的意义**：指针和引用不同，指针除了其指向一个对象，其本身也是一个对象，也可以使用`const`进行修饰。当`const`修饰指针本身时，表示这个指针不能被修改其指向位置；而当`const`修饰指针所指的对象时，则表示指向对象是一个常量，此时和引用类似。

**const 指针的声明**：由于`const`既可以修饰指针本身，又可以修饰指针所指的对象，故`const`所在的位置就显得极其重要。一共有如下 3 种声明方式：

```cpp
int ival = 10;
// highlight-start
const int *ptci = &ival;			// 修饰 ptci 所指的对象是一个常量
int * const cpti = &ival;			// 修饰 cpti 本身是一个常量
const int * const cptci = &ival;	// 修饰 cptci 本身包括其所指的对象
// highlight-end
```

需要注意的是如果指针本身是一个常量，则必须赋予其初始值。而如果只是指针所指的对象被修饰为一个常量，则可以不用赋初值。

**顶层 const 和底层 const**：由于指针本身是不是常量和指针所指的对象是不是常量是两个相互独立的问题。所以用**顶层 const** 表示指针本身是个常量，而用**底层 const** 表示指针所指的对象是一个常量。

当指针具有底层 const 属性时，那么该指针的初始值或者拷贝时的被拷贝对象必须具有相同的底层 const 资格或者能够转换成具有底层 const 的指针，通常不具底层 const 属性的值可以转换为具有底层 const 属性的值（一般算数类型并不存在底层和顶层 const 属性的区别，之所以这里说初始值或被拷贝对象必须具有相同的底层 const 资格是由于如果初始值或被拷贝值是指针那毫无疑问是需要的，而如果是对其指向类型的变量取地址，此时的初始值也就不是原来的类型，而可以看成一个指向该类型的指针了，所以也需要判定是否具有底层 const 属性）。而具有底层 const 属性的值通常无法转换为不具有底层 const 属性的值，故如果指针不具有底层 const 属性，那么其初始值或拷贝时的被拷贝对象也必须不具有底层 const 属性。

而指针的顶层 const 属性则更简单，就和其他类型的 const 限制一样，即基本没有限制，一个顶层 const 属性的指针可以接受无论是否具有顶层 const 属性的初始值，当然前提是需要满足其底层 const 属性的限制。

:::tip 尽量使用底层 const 修饰指针

通常，在需要通过指针修改其指向对象的内容时，使用不具有底层 const 属性的指针，而其他任何情况都应该使用具有底层 const 属性的指针。

例如，如果要写一个函数，其接受一个指针，但我们只用这个参数来遍历一个表或者其他结构然后将其内容打印出来，而不需要修改任何内容。这时如果我们使用不具有底层 const 属性的指针，那么就只能接受一个不具有底层 const 属性的指针。而如果我们使用的是具有底层 const 属性的指针，那么不论是否具有底层 const 属性的指针我们都能够接受。

:::



## 四、constexpr 和常量表达式

`constexpr`修饰的类型用来保存**常量表达式**，即值不会改变并且在编译过程就能得到计算结果的表达式。使用方法和`const`相同。

:::info 为什么会有 constexpr

很多时候我们使用`const`的初衷也是想让其保存一个常量，即值不会改变并且**在编译过程就能得到计算结果**。但很有可能会事与愿违，例如：初始化一个`const`变量时可以用非`const`变量进行赋值，此时虽然在这个`const`变量定义语句之后其值不会发生改变，但无法在编译过程就得到计算结果。当然，还有一些其他情况可能会导致`const`变量保存的实际上不是一个**常量表达式**。

而`constexpr`类型则只能用**常量表达式**进行初始化，如果初始值不是一个常量表达式，则会发生错误。在一些必须使用常量表达式的地方，我们可以使用`constexpr`类型的常量而不一定能使用`const`类型的常量。

:::

**使用方法**：

```cpp
constexpr int mf = 20;			// 20 是常量表达式
constexpr int limit = mf + 1;	// mf + 1 是常量表达式
// highlight-next-line
constexpr int sz = size();		// 只有当 size() 是一个 constexpr 函数时才正确
```

**字面值类型**：只有字面值类型可以用`constexpr`进行修饰，通常 *算术类型*、*引用*、*指针* 都属于字面值类型。比较特殊的是`constexpr`修饰的指针和引用必须绑定到固定地址中的对象，指针还可以是`nullptr`和`0`。

**constexpr 与指针**：`constexpr`只描述指针本身，如果要定义同时描述指针和其指向对象的话，使用如下形式：

```cpp
constexpr const int *p = nullptr;
```

