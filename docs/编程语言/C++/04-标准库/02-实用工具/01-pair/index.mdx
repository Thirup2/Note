---
title: pair
---

## 一、概述

`pair`类型定义在`<utility>`中，是一个类模板，实例化需要提供两个类型参数，一个`pair`类型对象包含两个数据成员，其类型分别是实例化时提供的两个类型参数。

`map`以及其延伸类型的元素类型就是一个`pair`类型，用于`map`实例化的类型参数实际上是实例化了其中包含的`pair`元素类型。

`pair`的两个数据成员为`public`的，可以直接进行访问。



## 二、操作

`pair`上的操作如下所示：

| 操作                                                     | 效果                                                         |
| -------------------------------------------------------- | ------------------------------------------------------------ |
| `pair<T1, T2> p`                                         | `p`是一个`pair`，两个类型分别为`T1`和`T2`的成员都进行值初始化 |
| `pair<T1, T2> p(v1, v2)`                                 | `p`是一个成员类型为`T1`和`T2`的`pair`；<br />`first`和`second`成员分别用`v1`和`v2`进行初始化 |
| `pair<T1, T2> p = {v1, v2}`                              | 等价于`p(v1, v2)`                                            |
| `make_pair(v1, v2)`                                      | 返回一个用`v1`和`v2`初始化的`pair`。<br />`pair`的类型从`v1`和`v2`的类型推断出来 |
| `p.first`                                                | 返回`p`的名为`first`的`public`数据成员                       |
| `p.second`                                               | 返回`p`的名为`second`的`public`数据成员                      |
| `p1 < p2`<br />`p1 <= p2`<br />`p1 > p2`<br />`p1 >= p2` | 关系运算符按照字典序定义，例如：<br />`p1.first < p2.first`或`!(p2.first < p1.first) && p1.second < p2.second`成立时，`p1 < p2`为`true`<br />关系运算利用元素的`<`运算符来实现 |
| `p1 == p2`<br />`p1 != p2`                               | 当`first`和`second`成员分别相等时，两个`pair`相等。<br />相等性利用元素的`==`运算符实现 |

