## 一、new 和数组

为了让`new`分配一个对象数组，我们要在类型名之后跟一对方括号，在其中指明要分配的对象的数目，例如：

```cpp
int *pia = new int[get_size()];
```

在这里的`[]`运算符之中的大小必须是整型但可以不必是常量，另外，数组的尺寸可以是 0。

`pia`是指向数组首元素的指针。

:::info 动态数组返回元素指针

必须要注意的是，`new`分配的数组返回的是一个元素指针，而非一个数组指针，虽然我们可以按照下面这样的形式：

```cpp
int a = pia[2];		// 上一步中的 get_size() 返回的值必须大于 2
```

像数组一样使用这个指针，但它的本质永远是一个元素指针，对一个元素指针我们不能调用`begin`或`end`，也就不能使用范围`for`语句来处理这个数组。

:::

### 初始化

- 默认情况下，`new`分配的对象，不论是单个分配的还是数组中的，都是默认初始化的。

- 可以对数组中的元素进行值初始化，方法是在大小之后跟一对空括号

  ```cpp
  int *pia = new int[10]();
  string *psa = new string[10]();
  ```

  只能使用空括号进行值初始化，括号里面不能有任何内容。

- 也可以提供一个花括号列表用于列表初始化

  ```cpp
  int *pia = new int[10]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  string *psa = new string[10]{"a", "an", "the", string(3, 'x')};
  ```

  与内置数组对象的列表初始化一样，初始值会用来初始化动态数组中开始部分的元素，如果初始值数目小于元素数目，剩余元素将进行值初始化。如果初始值数目大于元素数目，则`new`表达式失败，不会分配任何内存，并且会抛出一个类型为`bad_array_new_length`的异常，此类型定义在头文件`<new>`中。和之前一样，如果要阻止其抛出异常，则添加一个`nothrow`的参数：

  ```cpp
  string *psa = new (nothrow) string[10]();
  ```



## 二、释放动态数组

为了释放动态数组，必须使用`delete[]`，方括号内不需要动态数组的尺寸，只需要知道需要被释放的内存是个数组就行了：

```cpp
delete [] pia;
delete [] psa;
```

数组中的元素按照逆序进行销毁，即先销毁最后一个元素，然后是倒数第二个，以此类推。

另外，如果在释放一个数组时不添加`[]`，那么行为是未定义的。

当我们使用类型别名将数组的尺寸封装之后，通过`new`分配数组时可以不需要`[]`，但释放时仍然需要`[]`：

```cpp
typedef int arrT[42];
int *p = new arrT;
delete [] p;
```

