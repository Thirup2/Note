## 一、迭代器概念

迭代器并非某一种特定类型，而是一组概念，只要一种类型满足一组迭代器的概念，那这个类型就可以当做迭代器一样调用 STL 算法。

所以你会发现每一种容器类型都定义了自己的迭代器类型，并且由于指针满足某一组迭代器的概念，所以指针也可以当做迭代器一样使用。

而`iterator`标准库中实际上最主要是提供了一组标准库泛型函数用来操控各种各样的迭代器，例如递增，前进 n 位等操作。当然，`iterator`库也提供了一些类模板，但它们实际上并不是为了用户据此创建实例化的迭代器类型，例如`iterator_traits`类模板是用来获取迭代器类型的工具，它根据传入的迭代器类型自动推断出相应的特性；而`reverse_iterator`类模板是用于创建反向迭代器的模板，它接受的实例化参数仍然是我们自定义实现的迭代器，它的功能只是将其封装成一个反向迭代器。

每个容器都有两个成员函数`begin()`和`end()`用于返回对应迭代器类型的首元素迭代器和尾后迭代器。而对于数组来说，我们可以把指向数组首元素和尾后元素的指针作为两个迭代器使用，而获取这两个指针可以自行计算或者使用`iterator`标准库提供的两个函数：`std::begin(arr)`和`std::end(arr)`，它们会返回`arr`数组中的这两个指针。

迭代器可以按照行为不同和功能不同有两种分类方式，具体如下所述。



## 二、分类

不同的迭代器可能会有这两种差别：对它们执行同一个操作所产生的效果不同；它们相同操作效果相同但它们所支持的操作数量不同。

根据前者进行分类则是按照行为进行分类，这种分类方式并不能区分迭代器的具体类型，例如，在一个传入普通迭代器的地方，也可能可以传入插入迭代器、流迭代器、反向迭代器或移动迭代器。而按照后者进行的分类则是分离出了迭代器的 5 种类型，它们每一种类型都是一组概念（和之前所说的一样），如果你的自定义类只要满足了其中任意一组概念，那这个类就是一个迭代器，可以在任何需要该类迭代器的地方使用。

### 1. 按行为分类

#### 普通迭代器

普通迭代器是我们最常使用的迭代器类型，它支持的操作都是正常逻辑的操作，仅仅只是不同的迭代器（按第二种分类方式）之间支持的操作数量可能不同。

此处将常用操作（如果支持的话）列出：

| 操作                                   | 效果                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| `*iter`                                | 返回迭代器`iter`所指元素的引用                               |
| `iter->mem`                            | 解引用`iter`并获取该元素的名为`mem`的成员，等价于`(*iter).mem` |
| `++iter`                               | 令`iter`指示容器中的下一个元素                               |
| `--iter`                               | 令`iter`指示容器中的上一个元素                               |
| `iter1 == iter2`<br />`iter1 != iter2` | 判断两个迭代器的相等性。当两个迭代器指向同一个元素或者他们是同一个容器的尾后迭代器，则相等；否则不相等 |
| `iter + n`                             | 将元素看作从左往右列出。则该操作使迭代器向右移动`n`个位置。  |
| `iter - n`                             | 和上一个操作相反，使迭代器向左移动`n`个位置                  |
| `iter1 += n`                           | 迭代器加法的复合复制语句，即执行完`iter1 + n`后将其值覆盖原来的`iter1` |
| `iter1 -= n`                           | 和上一操作相反，将执行完`iter1 - n`后的值覆盖原来的`iter1`   |
| `iter1 - iter2`                        | 两个迭代器相减的结果是它们之间的距离`n`，即`iter2`向右移动`n`个元素可以和`iter1`相等 |
| `<`、`<=`、`>`、`>=`                   | 迭代器的关系运算符。<br />参与运算的两个迭代器必须指向同一个容器中的元素或尾元素的下一位置。<br />排在左边的元素的迭代器小于排在右边的元素的迭代器 |



#### 插入迭代器

插入器是一种迭代器适配器，它接受一个容器，生成一个迭代器，能实现向给定容器添加元素的功能。

当我们通过一个插入迭代器进行复制时，该迭代器调用容器操作来向给定容器的指定位置插入一个元素。

插入器通过以下三个函数获取，它们每个都要求传入其中的容器实现了某个操作：

- `back_inserter`：创建一个尾部插入迭代器。要求容器实现了`push_back`操作。
- `front_inserter`：创建一个头部插入迭代器。要求容器实现了`push_front`操作。
- `inserter`：创建一个一般插入迭代器。该函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前。要求容器实现了`insert(p, t)`操作

插入迭代器支持以下的操作：

| 操作                             | 效果                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| `it = t`（`it`是一个插入迭代器） | 在`iter`指定的当前位置插入值`t`。<br />根据生成插入器时调用的具体函数不同，插入迭代器插入的位置也不同。 |
| `*it`、`++it`、`it++`            | 这些操作都存在，但不做任何事，每个操作都返回`it`             |

对于插入迭代器的操作需要注意以下两点：

- 直接对插入迭代器赋值并不是像改变指针指向一样改变了迭代器的指向，而是调用了对应的插入函数将值插入到迭代器指示的位置之前。对于普通的迭代器而言，这样的操作是不可行的。只不过也可以对插入迭代器使用`*it = t`的用法，不过因为`*it`不执行任何操作返回`it`，所以其效果和直接赋值效果相同。
- 插入迭代器实际上只支持赋值操作，但它还是实现了不执行任何操作的解引用和递增操作，这是因为必须要满足迭代器的一组概念才能作为迭代器被传入到需要迭代器的算法中。



#### iostream 迭代器

流迭代器就是两个类模板：`istream_iterator`、`ostream_iterator`。当创建一个流迭代器时，必须指定迭代器将要读写的对象，即实例化使用的类型的作用。

流迭代器的基本功能还是输入输出，但它现在可以像一个迭代器一样进行使用。例如在`copy`算法中，我们需要三个迭代器，此时我们就可以将第一对迭代器替换为输入迭代器（第二个必须是能够当做尾后值使用的迭代器），第三个迭代器可以是一个容器的插入迭代器，这样这个算法执行的操作就是从输入中读取元素并插入到容器中而取代了与之等效的迭代语句；也可以用第一对迭代器表示正常容器的范围，第三个迭代器使用输出迭代器，这样就可以输出该容器中的元素，同样也可以用等效的迭代语句进行取代。

<Tabs>

<TabItem value="istream" label="istream_iterator">

一个`istream_iterator`使用`>>`来读取流。因此，`istream_iterator`要读取的类型必须定义了输入运算符。

`istream_iterator`支持的操作具体如下表所示：

| 操作                           | 效果                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| `istream_iterator<T> in(is)`   | `in`从输入流`is`读取类型为`T`的值                            |
| `istream_iterator<T> end`      | 读取类型为`T`的值的`istraem_iterator`迭代器，表示尾后位置    |
| `in1 == in2`<br />`in1 != in2` | `in1`和`in2`必须读取相同类型，如果它们都是尾后迭代器，或绑定到相同的输入，则两者相等 |
| `*in`                          | 返回从流中读取的值                                           |
| `in->mem`                      | 与`(*in).mem`的含义相同                                      |
| `++in`、`in++`                 | 使用元素类型定义的`>>`运算符从输入流中读取下一个值。<br />与以往一样，前置版本返回一个指向递增后迭代器的引用，后置版本返回旧值。 |

:::info istream_iterator 的使用原理

首先我们需要用一个输入流去初始化一个`istream_iterator`，这样就得到一个输入流迭代器。和其他大多数迭代器一样，支持解引用、递增、相等性判断等操作。但它的这些操作和其他类型的迭代器有所区别。

总的来说，可以将用于初始化的输出流看作一个容器，然后一个`istream_iterator`对象就是根据这个“容器”生成的迭代器。

当我们对其执行递增操作时，迭代器并非“移向”下一位置，而是从初始化时的输入流中读取一个实例化类型的元素，此时这个读取的值还保存在这个类型内部。

当我们对其执行解引用操作时，则会返回刚读取的值。

如果我们将这个输入过程作为迭代语句的条件，那么如果想让这个输入流程自然结束，需要定义一个默认初始化的`istream_iterator`对象，并在每次迭代时与之进行比较。当一个输入迭代器关联的输入流遇到文件尾或遇到 IO 错误，迭代器的值就和这个默认初始化的`istream_iterator`对象相等。所以通常将默认初始化的`istream_iterator`对象当做尾后迭代器进行使用。

:::

</TabItem>

<TabItem value="ostream" label="ostream_iterator">

我们可以对任何具有`<<`运算符的类型定义`ostream_iterator`。当创建一个`ostream_iterator`时，我们可以提供（可选的）第二参数，它是一个 C 风格字符串，在输出每个元素后都会打印此字符串。另外必须将`ostream_iterator`绑定到一个指定的流，不允许空的或表示尾后位置的`ostream_iterator`。

`ostream_iterator`支持的操作具体如下所示：

| 操作                             | 效果                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| `ostream_iterator<T> out(os)`    | `out`将类型为`T`的值写到输出流中                             |
| `ostream_iterator<T> out(os, d)` | `out`将类型为`T`的值写到输出流`os`中，每个值后面都输出一个`d`。<br />`d`指向一个空字符结尾的字符数组 |
| `out = val`                      | 用`<<`运算符将`val`写入到`out`所绑定的`ostream`中。<br />`val`的类型必须与`out`可写的类型兼容 |
| `*out`、`++out`、`out++`         | 仅存在但不做任何事，返回`out`                                |

:::info ostream_iterator 的使用原理

输出流迭代器的操作和输入流迭代器相比少了不少，这是因为输出流迭代器的特性，以 STL 算法为例一个输出流迭代器只能做目的容器迭代器，可以将输出流看作目的容器。

由于这个原因，一个`ostream_iterator`不允许默认初始化，因为目的容器的迭代器不需要使用尾后迭代器。

每次使用`=`运算符，就是将右侧运算对象输出到该迭代器所绑定的输出流中。

:::

</TabItem>

</Tabs>

> 注：输入流迭代器只能用作输入迭代器，而输出流迭代器也只能用作输出迭代器，除此之外的其他功能都不支持。



#### 反向迭代器

反向迭代器和普通迭代器一样，由类类型自行提供。

反向迭代器的正反和普通迭代器完全颠倒，对于反向迭代器来说，指向尾元素的反向迭代器则是首元素迭代器，而指向首元素之前位置的反向迭代器则是尾后迭代器。而正常的迭代器递增操作是向右移动迭代器（按从左往右排列），而反向迭代器的递增操作则是向左移动迭代器，它们之间的递减操作（如果普通迭代器支持）也刚好相反。另外，排在左边的反向迭代器比排在右边的反向迭代器更大，如果用排在右边的反向迭代器减去排在左边的反向迭代器将得到一个负数。

反向迭代器的操作支持基本和普通迭代器相同，只是它们执行的方式和上一段所说的一样有所不同，故此处不特殊列出其操作。

需要注意的一点是反向迭代器需要递减运算符，相对于普通迭代器来说，它们可能没有递减运算符（例如`forward_list`）。



#### 移动迭代器

移动迭代器使用的场景比较特殊，使用移动迭代器意味着所有将用移动迭代器指向的内容在进行操作之后对程序来说都应该是有效但可析构的。

通常应用在重新分配容器内存大小时。

**移动迭代器**和插入迭代器一样也是一种迭代器适配器，也就是说需要传入一个普通迭代器然后可以得到一个移动迭代器，通过`make_move_iterator`来获取这个移动迭代器。如：`make_move_iterator(c.begin())`，具体的改变是在解引用操作上，对一个移动迭代器进行解引用操作，将得到一个其指向对象的右值引用。其他操作和原迭代器相同。

移动迭代器通常和`uninitialized_copy`这个泛型算法一起使用，这个函数定义在`<memory>`中。接受一对迭代器参数表示源范围，第三个参数是目标迭代器表示目标位置。其返回值是目标迭代器经过`copy`递增后的值。对于这个算法，如果我们传入普通迭代器也就是解引用为左值引用的迭代器，那么调用的就是对应的拷贝操作，如果传入移动迭代器，那么调用的就是对应的移动操作。

下面是一个例子：

```cpp
void StrVec::reallocate()
{
    auto newcapacity = size() ? 2 * size() : 1;		// 基于当前 size 分配新的 capacity
    auto first = alloc.allocate(newcapacity);		// 使用 StrVec 的分配器 alloc 分配新的空间并交给指针 first
    auto last = uninitialized_copy(					// 通过移动迭代器将源空间中的元素“移动”到新空间中并用 last 保存这些元素的末尾位置
    				make_move_iterator(begin()),
    				make_move_iterator(end()),
    				first);
    free();											// StrVec 的成员函数，释放当前对象管理的内存
    elements = first;								// 更新管理内存的指针指向新空间
    first_free = last;								// 更新指向暂未使用的空间的指针
    cap = elements + newcapacity;					// 使 cap 指向整个空间的尾后位置
}
```



### 2. 按功能分类

迭代器可以按功能分为 5 类，分别是输入迭代器、输出迭代器、前向迭代器、双向迭代器和随机访问迭代器。

它们之间的区别是支持的操作数量不同，但可以分为四个层级：

- 输入迭代器和输出迭代器：定义了最基础的功能
- 前向迭代器：满足输入迭代器和输出迭代器的所有功能
- 双向迭代器：满足前向迭代器支持的所有功能之外还额外提供一些功能
- 随机访问迭代器：满足双向迭代器支持的所有功能之外还额外提供一些功能

#### 输入迭代器

最基础的迭代器之一，可以读取序列中的元素，一个输入迭代器必须支持：

- 用于比较两个迭代器的相等和不相等运算符（`==`、`!=`）

- 用于推进迭代器的前置和后置递增运算（`++`）

- 用于读取元素的解引用运算符（`*`）

  > 注：输入迭代器中的解引用运算符只会出现在赋值运算符的右侧

- 箭头运算符（`->`），等价于`(*it).member`，即解引用迭代器，并提取对象的成员

> 输入迭代器只用于顺序访问。对于一个输入迭代器，`*it++`保证是有效的，但递增它可能导致所有其他指向流的迭代器失效。不能保证输入迭代器的状态可以保存下来并用来访问元素。因此，输入迭代器只能用于单遍扫描算法。
>
> `istream_iterator`是一种输入迭代器。



#### 输出迭代器

另一个最基础的迭代器类型，只写而不读元素。一个输出迭代器必须支持：

- 用于推进迭代器的前置和后置递增运算符（`++`）

- 解引用运算符（`*`）

  > 注：输出迭代器的解引用操作只出现在运算符的左侧

> 我们只能向一个输出迭代器赋值一次。类似输入迭代器，输出迭代器只能用于单遍扫描算法。用作目的位置的迭代器通常都是输出迭代器。
>
> `ostream_iterator`是一种输出迭代器。



#### 前向迭代器

可以读写元素，同时支持输入迭代器和输出迭代器的所有操作，但不提供其他操作。

这类迭代器只能在序列中沿一个方向移动。前向迭代器还可以多次读写同一个元素。因此，我们可以保存前向迭代器的状态，使用前向迭代器的算法可以对序列进行多遍扫描。



#### 双向迭代器

除了支持所有前向迭代器的操作之外，双向迭代器还支持：

- 前置和后置的递减运算符（`--`）。

可以正向/反向读写序列中的元素。



#### 随机访问迭代器

除了支持双向迭代器的所有功能，随机访问迭代器还支持：

- 比较两个迭代器相对位置关系运算符（`<`、`<=`、`>`、`>=`）
- 迭代器和一个整数值的加减运算（`+`、`+=`、`-`、`-=`），计算结果是迭代器在序列中前进（或后退）给定整数个元素后的位置
- 用于两个迭代器上的减法运算符（`-`），得到两个迭代器的距离
- 下标运算符（`iter[n]`），与（`*(iter[n])`）等价



## 三、迭代器库操作

虽然大部分迭代器通常是用户自定义的，但迭代器库还是有一些只有包含了`<iterator>`库之后才能使用的操作。
