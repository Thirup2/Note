## 一、迭代器要求

任何算法最基本的特性是它要求了迭代器最小应该是哪种类型，例如：

- `find`、`accumulate`要求至少是输入迭代器
- `copy`函数的第三个参数要求至少是输出迭代器
- `replace`要求至少是前向迭代器
- `reverse`要求至少是双向迭代器
- `sort`要求必须是随机访问迭代器



## 二、算法形参模式

大多数算法具有如下 4 种形式之一：

- `alg(beg, end, other args)`
- `alg(beg, end, dest, other args)`
- `alg(beg, end, beg2, other args)`
- `alg(beg, end, beg2, end2, other args)`

其中`alg`是算法的名字。

`beg`和`end`表示算法所操作的输入范围。几乎所有算法都接受一个输入范围，是否有其他参数则依赖于要执行的操作。

`dest`和`beg2`、`end2`都是迭代器参数，如果用到了这些迭代器参数，它们指定目的位置或第二个范围。

如果是接受单个目标迭代器的算法，那么算法假定：按其需要写入数据，不管写入多少个元素都是安全的。

如果是接受单独的`beg2`的算法，这些算法假定：从`beg2`开始的范围与`beg`和`end`表示的范围至少一样大。

> 还有一些算法可以接受一些不同于上述 4 种模式的其他模式的参数，例如`fill_n`算法，但这些算法属于比较少的一部分，故不特地说明其形参模式。



## 三、算法命名规范

一个算法可能会有其他的版本，例如额外接受谓词的版本、拷贝的版本等等，它们都遵循一套命名和重载规范。

### 1. 接受谓词的版本

接受谓词的算法基于原算法有两种解决方案：

- 一些算法使用重载形式传递一个谓词，算法在函数名上面没有区分
- 一些算法提供一个`_if`版本，和原算法是两个不同的算法，例如`find_if`



### 2. 拷贝的版本

算法的拷贝版本可以将重排后的元素写入到给定的输出目的位置，其命名规范是在原算法后添加`_copy`，例如：`reverse_copy`



### 3. 接受谓词的拷贝版本

一些算法同时提供`_copy`和`_if`版本，其命名规范为`_copy`在前，`_if`在后，例如：`remove_copy_if`。
