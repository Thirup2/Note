---
title: 泛型算法
---

容器只定义了很少的操作，在多数情况下，我们可以添加和删除元素、访问首尾元素、确定容器是否为空以及获得指向首元素或尾元素之后位置的迭代器。

但很显然，我们还很可能希望容器可以做其他很多有用的操作：查找特定元素、替换或删除一个特定值、重排元素顺序等。

标准库并未给每个容器都定义成员函数来实现这些操作，而是定义了一组**泛型算法**。称它们为“算法”，是因为它们实现了一些经典算法的公共接口，如排序和搜索；称它们是“泛型的”，是因为它们可以用于不同类型的元素和多种容器类型（包括标准库类型，如`vector`或`list`，还包括内置的数组类型，甚至实现了迭代器的自定义类型）

## 一、概述

大多数算法都定义在`algorithm`中，以及在头文件`numeric`中还定义了一组数值泛型算法。

一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作，并且也不会直接操作元素，而是通过传入的迭代器支持的操作来间接进行操作。

例如，我们可以通过`find`函数在指定范围内查找特定值：

```cpp
vector<int> vec = { /* ... */ };
int val = 42;
auto result = find(vec.cbegin(), vec.cend(), val);
```

`find`会返回在`vec.cbegin()`到`vec.cend()`这个范围内第一个等于给定值的元素的迭代器。如果范围中无匹配元素，则`find`返回第二个参数来表示搜索失败。



## 二、算法的工作方式

这些算法可以作用于不同类型的容器，之所以能做到这样的效果，我们可以先仔细了解一下`find`的步骤：

1. 访问序列中的首元素
2. 比较此元素与我们要查找的值
3. 如果此元素与我们要查找的值匹配，`find`返回标识此元素的值
4. 否则，`find`前进到下一个元素，重复执行步骤 2 和 3
5. 如果到达序列尾，`find`应停止
6. 如果`find`到达序列末尾，它应该返回一个指出元素未找到的值，此值和步骤 3 返回的值必须具有相容的类型

这些步骤都不依赖于容器所保存的元素类型。因此，只要有一个迭代器可用来访问元素，`find`就完全不依赖于容器类型（甚至无须例会保存元素的是不是容器）。

### 迭代器令算法不依赖于容器

在上述`find`函数流程中，除了第 2 步外，其他步骤都可以用迭代器操作来实现。总的来说，当你传入一个范围参数时，算法会检查你传入的参数是否满足迭代器的要求，如果满足，那么就不再管其他事情。

例如，`find`算法中需要的迭代器至少应该重载了相等性比较运算符（`==`），前置和后置递增运算符（`++`），解引用运算符（`*`）。而只要满足这个最低要求，即使不是容器中的迭代器，都可以传入到`find`算法中。



### 算法仍依赖于元素类型的操作

虽然迭代器令算法不依赖于容器，但仔细观察`find`算法的步骤还是会发现在第 2 步中会对元素值进行比较，这就要求对传入的迭代器进行解引用操作之后的元素类型重载了相等性比较运算符。

当然，即使元素没有定义该操作也能够调用`find`算法，但是需要我们使用自定义的操作来代替默认的运算符。