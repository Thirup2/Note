---
title: 构造函数
---

## 一、基本方法

一个构造函数不需要返回类型，并且其函数名和类型名相同，例如：

```cpp
class type {
    int data = 0;
public:
    type();
};
```

其中`type()`就是一个构造函数。一个不接受任何参数的构造函数是这个类型的默认构造函数。

如果不声明和定义任何构造函数，那么编译器将会合成默认构造函数。

需要注意的是如果创建对象时使用默认构造函数，不需要添加`()`，否则会变成一个类类型函数的声明语句：

```cpp
type item();
```

如上，定义了一个返回`type`类型的函数`item`，而不是`type`类型的对象。



## 二、合成的默认构造函数

对于大多数类而言，这个合成的默认构造函数将按照如下规则初始化类的数据成员：

- 如果存在类内初始值，则用它来初始化成员
- 否则，默认初始化该成员

有时候，合成的默认构造函数是不可用的，主要有以下三个原因：

- 如果定义了其他的构造函数，则合成的默认构造函数不可用，只能显式定义默认构造函数
- 如果类的数据成员是一个内置类型或符合类型，如果没有赋予类内初始值，那么此时合成的默认构造函数会赋予它们垃圾值
- 有时候编译器不能为某些类合成默认的构造函数，例如类中的某些成员无法进行默认初始化时



## 三、自定义构造函数

如果要自定义构造函数，则需要使用**构造函数初始值列表**，例如：

```cpp
Sales_data(const std::string &s): bookNo(s) { }
Sales_data(const std::string &s, unsigned n, double p):
		   bookNo(s), units_sold(n), revenue(p*n) { }
```

这两个函数中出现在参数列表之后，函数体之前的内容就是构造函数初始值列表。它们以`:`开头，以`,`分隔，初始化形式使用直接初始化的形式。

当某个数据成员被构造函数初始值列表忽略时，它将与合成默认构造函数相同的方式隐式初始化。

### 初始值列表的作用

如果没有在构造函数的初始值列表中显式地初始化成员，则该成员将在构造函数体之前执行默认初始化。

你可以在函数体内为成员赋值以达到类似的效果：

```cpp
Sales_data::Sales_data(const string &s, unsigned cnt, double price)
{
    bookNo = s;
    units_sold = cnt;
    revenue = cnt * price;
}
```

然而需要特别注意，这样的构造函数体内的内容并非初始化操作，而是赋值操作。

**缺点**：

- 一个构造函数会先根据初始值列表进行初始化，然后执行函数体内的内容，函数体可以为空。当没有初始值列表时，会先执行默认初始化，然后执行函数体。对于上面的例子而言，相当于先进行了默认初始化，然后再依次给他们赋值，很显然多了很多冗余操作。
- 另外由于函数体内的操作是赋值而非初始化，那么对于有些类型这样的操作就是错误的，例如成员是`const`或者引用时，是必须进行初始化的。当成员属于某种类类型且该类没有定义默认构造函数时，也必须将这个成员初始化。

### 成员初始化的顺序

初始值列表中的成员可以以任何顺序出现，但它们的执行顺序却不一定按照初始值列表中列出的顺序。

成员的初始化顺序与它们在类定义中的出现顺序一致，初始值列表中初始值的前后位置关系不会影响实际的初始化顺序。

如果一个成员是用另一个成员来初始化的，那么这两个成员的初始化顺序就很关键了：

```cpp
class X {
    int i;
    int j;
public:
    // error-next-line
    X(int val): j(val), i(j) { }		// i 先被初始化，但它的初始值 j 还未初始化，故 i 被初始化为垃圾值
};
```



## 四、委托构造函数

如果我们有一个类如下所示：

```cpp
class Sales_data {
    std::string str;
	unsigned num;
    double price;
public:
    Sales_data();
    Sales_data(std::string s);
    Sales_data(std::string s, unsigned cnt, double rate);
}
```

在上面我们声明了三个构造函数，它们可以像下面这样实现：

```cpp
Sales_data::Sales_data(): 
	str(""), num(0), price(0) { }
Sales_data::Sales_data(std::string s):
	str(s), num(0), price(0) { }
Sales_data::Sales_data(std::string s, unsigned cnt, double rate):
	str(s), num(cnt), price(rate) { }
```

但实际上它们都进行了类似的初始化，为每一个成员都提供了初始值，这样的初始值列表可以换成**委托构造函数**的形式：

```cpp
Sales_data::Sales_data():
	Sales_data("", 0, 0) { }
Sales_data::Sales_data(std::string s):
	Sales_data(s, 0, 0) { }
Sales_data::Sales_data(std::string s, unsigned cnt, double rate):
	str(s), num(cnt), price(rate) { }
```

使用这样的形式更简洁便利，并且如果受委托的构造函数（如上例中第三个函数）的函数体中还定义了内容，并且另外两个构造函数也需要相同的函数体，那么委托构造函数就只需要定义一次该函数体即可，委托构造函数会先执行被委托的构造函数执行完初始值列表和函数体后才回到委托构造函数的函数体执行。



## 五、类类型转换 {#typeconvert}

只接受一个参数的构造函数定义了一个其他类型向该类类型的转换规则。例如：

```cpp
class type {
    int a = 0;
    int b = 0;
public:
    type(int n): a(n), b(n) { }
    add(const type &obj) {
        a += obj.a;
        b += obj.b;
    }
};
```

这样我们就有了一个从`int`类型向`type`类型的转换规则了，并且还是**隐式转换**。在一个需要`type`类型的地方，都可以使用一个`int`类型代替：

```cpp
type obj(10);
obj.add(10);
```

`add`函数接受一个`type`类型，而我们只填入了一个`int`类型的字面值，它可以转换为`type`类型。

当然，定义了隐式转换的类型也可以进行显式类型转换。

### 只允许一步隐式类类型转换

如果我们定义了由`type1`到`type2`的隐式转换，并定义了`type2`到`type3`的隐式转换，也不能直接由`type1`隐式转换为`type3`，如果想实现这个过程，必须将`type1`到`type2`的转换或`type2`到`type3`的转换改写成隐式转换的形式。

### 抑制隐式转换

实际上我们并不想要一个`int`到`type`类型的隐式转换，我们可以通过将构造函数声明为`explicit`的来加以阻止：

```cpp
class type {
    // ...
    explicit type(int n): a(n), b(n) { }
    // ...
};
```

这样从`int`到`type`就无法进行隐式转换了。

注：`explicit`关键字只在类内构造函数声明时使用，不能在其他地方重复。

### explicit 构造函数的使用

一个声明为`explicit`的构造函数只能用于直接初始化，而不能用于拷贝形式的初始化，例如：

```cpp
type item(n);
// error-next-line
type item = n;		// 错误
```

之所以会发生错误，是因为拷贝初始化调用拷贝构造函数，接受的是一个`type`类型的对象，所以会发生`n`向该类型的隐式转换，所以会出错。

### 更多……

其他类类型转换相关的内容请参考[类型转换运算符](../../重载运算与类型转换/类型转换运算符/)。
