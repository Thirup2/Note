对于既定义了拷贝操作又定义了移动操作的类型来说，当我们执行一个拷贝初始化或赋值操作的时候，程序到底选择的是哪个函数呢？

如果只定义了拷贝操作，不难发现，此时即使参数是右值，仍然将调用拷贝操作并且不会出任何问题。但如果定义了移动操作，左值必须使用`std::move`这个标准库函数之后才能调用移动操作而不能直接调用。

这是因为一个左值引用既可以绑定到一个左值，也可以绑定到一个右值，而一个右值引用却只能绑定到一个右值。

所以具体的函数匹配过程如下：

- 当既定义了拷贝操作又定义了移动操作，一个左值不出意外精确匹配到拷贝操作，而一个右值也精确地匹配到移动操作
- 当只定义了拷贝操作：一个左值仍然精确匹配到拷贝操作，而一个右值只能退而求其次选择拷贝操作
- 当只定义了移动操作：左值无法匹配任何操作除非使用`std::move`，而右值则精确匹配到移动操作

如果只定义了拷贝操作，那么对于右值来说，所有拷贝初始化和赋值操作也将执行拷贝操作，这可能会比特化的移动操作消耗更多的性能，但并不会出什么错误。