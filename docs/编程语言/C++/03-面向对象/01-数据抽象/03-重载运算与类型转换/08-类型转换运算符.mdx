## 一、运算符重载

> 类型转换运算符可以定义类类型到其他类型的转换规则，除此之外，仅接受一个参数的构造函数也可以定义类型转换，构造函数所定义的类型转换是从其他类型到类类型的转换规则，具体内容参考[构造函数-类类型转换](../../构造与拷贝控制/构造函数/#typeconvert)

- 函数类型：成员函数
- 参数：无
- 返回值：无

**示例**：

```cpp
class SmallInt {
public:
    SmallInt(int i = 0) : val(i) {
        if (i < 0 || i > 255)
            throw std::out_of_range("Bad SmallInt value");
    }
    // highlight-next-line
    operator int() const { return val; }
private:
    std::size_t val;
};
```

一个类型转换函数必须是类的成员函数；它不能声明返回类型，形参列表也必须为空。且类型转换运算符通常不应该改变转换对象的内容，因此，类型转换运算符一般被定义为`const`成员函数。



## 二、类类型转换注意事项

### 1. 转换规则

编译器一次只能执行一个用户定义的隐式类型转换，但是隐式的用户定义类型转换可以置于一个标准（内置）类型转换之前或之后，并与其一起使用。

例如：

```cpp
SmallInt si = 3.14;		// 3.14 转换为 int（内置转换），然后转换为 SmallInt（类定义转换）
si + 3.14;				// si 转换为 int（类定义转换），然后转换为 double（内置转换）
```



### 2. 显式转换

基于上一条的转换规则，有可能会因此产生一些令人意外的结果。

例如，当类提供了向`bool`类型的转换时，如果把一个类对象放进任何需要算术类型的上下文中，可能会引发意想不到的结果。特别是，`istream`可以向`bool`类型隐式转换，那么下面的表达式：

```cpp
int i = 42;
cin << i;
```

如果向`bool`类型的转换是隐式的，那么`cin`首先转换为`bool`类型（类定义转换），然后由`bool`提升为`int`（内置转换），该转换基于上一条规则，可以判断是合法的，最终上面的表达式就变成了将 1 或 0 左移 42 个位置。

为了解决这个问题，C++11 标准引入了**显式的类型转换运算符**，其方法是在类型转换运算符重载函数前添加`explicit`关键字：

```cpp
class SmallInt {
public:
    explicit operator int() const { return val; }
};
```

其效果与作用在接受单参数的构造函数上时类似，即阻止对应的隐式转换。但和其不同的一点是，在这种用法中存在着一种例外：如果表达式被用作条件，则编译器会将显式的类型转换自动应用于它。即，当表达式出现在以下位置时，显式的类型转换将隐式地被执行：

- `if`、`while`和`do`语句的条件部分
- `for`语句头的条件表达式
- 逻辑非运算符（`!`）、逻辑或运算符（`||`）、逻辑与运算符（`&&`）的运算对象
- 条件运算符（`?:`）的条件表达式

根据该规则，不难判断重载的`operator bool()`运算符应该定义为`explicit`。



### 3. 避免二义性转换

如果类中包含一个或多个类型转换，则必须**确保在类类型和目标类型之间只存在唯一一种转换方式**。否则的话，我们编写的代码将很可能会具有二义性。

在两种情况下可能产生多重转换路径：

- 第一种情况是两个类提供相同的类型转换：例如，当 A 类定义了一个接受 B 类对象的转换构造函数，同时 B 类定义了一个转换目标是 A 类的类型转换运算符时，这两个转换函数都是由 B 转换为 A，所以定义了两个相同的类型转换
- 第二种情况是类定义了多个转换规则，而这些转换涉及的类型本身可以通过其他类型转换联系在一起。具体见后例。

**相同类型转换**：

一个提供了相同类型转换的示例如下所示：

```cpp
struct B;
struct A {
    A() = default;
    A(const B&);		// 将 B 转换为 A
};
struct B {
    operator A() const;
};
```

此时如果像下面这样使用，将会产生二义性错误：

```cpp
A f(const A&);
B b;
// error-next-line
A a = f(b);		// 需要将 b 隐式转换为 A 类型，产生二义性错误
```

如果要正确执行上述的调用，就不得不显式的调用类型转换运算符或者转换构造函数：

```cpp
A a1 = f(b.operator A());		// 调用 B 的类型转换运算符
A a2 = f(A(b));					// 调用 A 的构造函数
```

需要注意的是第二种形式的调用，从之前的知识中我们得知`Type(val)`也是强制类型转换的，其原理为以`val`为初始值创建一个`Type`类型的临时量，从而达到类型转换的效果。而`operator Type()`这个运算符也使我们可以用`Type(val)`这样的形式进行显式类型转换，那么为什么`A(b)`这样的调用没有出现二义性错误呢？实际上如果`A`类型提供了对应的构造函数，那么无论`B`类型是否重载了`operator A()`运算符，都将调用`A`的构造函数，只有当`A`没有提供对应的构造函数时，才调用`B`类型重载的`operator A()`运算符。

所以实际`Type(val)`这样的类型转换方式并不能称为强制类型转换，真正的强制类型转换是`static_cast`等转换方法。然而对于上面这种情况，仍然不能使用强制类型转换，因为强制类型转换并不能消除其二义性。

**多重类型转换**：

如果类定义了一组类型转换，它们的所有转换源（或者转换目标）类型本身可以通过其他类型转换联系在一起，则同样会产生二义性的问题。其中一个最典型的例子就是类定义了多个从算术类型转换为类类型的构造函数，或者转换目标都是都是算数类型的类型转换运算符。

****

例如，下面的类中包含两个转换构造函数，它们的参数是两种不同的算术类型：

```cpp
struct A {
    A(int = 0);
    A(double);
};
```

对于这个例子，当我们使用如下形式进行调用时将会出现二义性错误：

```cpp
long lg;
// error-next-line
A a2(lg);		// 二义性错误
```

无论是`long`到`int`的转换还是`long`到`double`的转换，其优劣度都相同，故无法判断应该调用哪一个转换构造函数。

****

同样，下面的类中包含两个转换到不同算术类型的类型转换运算符：

```cpp
struct A {
    operator int() const;
    operator double() const;
};
```

对于这个例子，当我们使用如下形式进行调用时会出现二义性错误：

```cpp
void f2(long double);
A a;
// error-next-line
f2(a);
```

由于无论是从`int`还是从`double`转换到`long double`，其优劣度都相同，故无法判断`a`应该先转换为`int`还是`double`，产生二义性错误。

**经验规则**：

- 不要令两个类执行相同的类型转换
- 避免转换目标是内置算术类型的类型转换，如果已经定义了一个转换成算术类型的类型转换时，那么
  - 不要再定义接受算术类型的重载运算符。如果用户需要这样的运算符，则类型转换操作将转换你的类型的对象，然后使用内置的运算符
  - 不要定义转换到多种算术类型的类型转换。让标准类型转换完成向其他算术类型转换的工作。



### 4. 重载函数与转换构造函数

当某几个类型定义了同样的转换构造函数（接受相同类型的参数），与此同时，一组重载函数刚好使用了这几个类型作为参数，此时将导致另一个二义性问题：

```cpp
struct C {
    C(int);
};
struct D {
    D(int);
};

void manip(const C&);
void manip(const D&);
```

此时如果调用`manip`函数时提供的是一个`int`，那么此调用将具有二义性：无法判定应该将`int`转换为`C`还是`D`类型。

我们只能使用显示构造正确的类型来消除二义性：

```cpp
manip(C(10));
```

但即便如此，一个非常重要的原则是：**如果在调用重载函数时我们需要使用构造函数或者强制类型转换来改变实参的类型，则这通常意味着程序的设计存在不足**。

****

另外，对于以下情况：

```cpp
struct D {
    D(int);
};
struct E {
    E(double);
};

void manip2(const D&);
void manip2(const E&);
```

此时按照下面形式进行调用仍然会出现二义性错误：

```cpp
manip2(10);
```

对于第一个重载函数，10 需要一步转换为`D`；对于第二个重载函数，10 需要经过内置转换和类定义转换两步转换为`E`。

看上去转换为`D`为更好一点，但并非如此。只要转换调用了类定义的转换，即使其中一个调用需要额外的标准类型转换而另一个调用能精确匹配，编译器也会将该调用标示为错误。



### 5. 函数匹配与重载运算符

重载的运算符也是重载的函数。因此，通用的函数匹配规则同样适用于判断在给定的表达式中到底应该使用内置运算符还是重载运算符。

首先确定候选函数集：

- 当我们使用运算符形式调用运算符时
  - 如果运算对象只有内置类型：则直接调用内置运算符
  - 如果运算对象包含类类型且左侧运算对象不为类类型：则候选函数集包括非成员运算符函数和内置运算符
  - 如果左侧运算对象为类类型：则候选函数集包括非成员运算符函数、该类中的运算符函数成员以及内置运算符
- 当我们使用函数形式调用运算符时，将根据函数调用形式进行区别
  - 通过类对象调用的运算符函数：仅考虑该类的成员函数
  - 未通过类对象调用的运算符函数：仅考虑编译单元中所有的非成员函数

由于这个原因，会导致：**如果我们对同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性问题**。

例如：

```cpp
class SmallInt {
    friend SmallInt operator+(const SmallInt &, const SmallInt &);		// 重载 + 运算符
public:
    SmallInt(int = 0);													// int 转换为 SmallInt
    operator int() const { return val; }								// SmallInt 转换为 int
private:
    std::size_t val;
};
```

对其进行如下调用：

```cpp
SmallInt s3;
// error-next-line
int i = s3 + 0;		// 二义性错误
```

其中`s3 + 0`这个表达式既可以将`s3`转换为`int`调用内置运算符，也可以将`0`转换为`SmallInt`调用重载运算符，故会出现二义性错误。