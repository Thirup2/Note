## 一、解引用运算符

- 函数类型：通常为成员函数
- 参数：无
- 返回值：类指向对象类型的引用（解引用运算符通常在行为类似指针的类中重载，其返回值通常为逻辑上该指针指向的对象的引用）

**示例**：

```cpp
class PtrToInt {
    int *ival;
public:
    int& operator*() const
    {
		return *ival;
    }
};
```

解引用运算符通常定义为`const`成员，即可以对任何类型的该类型对象进行解引用操作。

:::info 解引用无需重载

你可能会想解引用操作是否需要重载，对普通对象返回普通引用，对`const`对象返回`const`引用，事实上并不需要。因为指针有顶层和底层`const`之分。

当一个类对象被修饰为`const`时，由于定义解引用操作的类通常是类似指针的类，所以这个`const`实际上是一个顶层指针，而它的底层`const`属性并不会发生改变，也就是说其指向的对象类型不会变，在上例中我们将`PtrToInt`设定为指向`int`类型的指针，那么无论是否是`const`的`PtrToInt`对象，其指向的对象永远是`int`而不是`const int`。

故仅需将该函数定义为`const`成员函数即可。

:::



## 二、成员访问运算符

- 函数类型：成员函数
- 参数：无
- 返回值：类指向对象类型的指针

**示例**：

```cpp
class PtrToStr {
    string *str;
public:
    std::string& operator*() const {/* 实现 */};
    // highlight-start
    std::string* operator->() const
    {
        return &this->operator*();	// 委托给 operator*，并对 operator* 返回值取地址再返回
    }
    // highlight-end
};
```

和`operator*`一样，`operator->`也应该定义为`const`函数，且无需针对返回值类型重载。

:::info 箭头运算符返回的指针指向的类型

和解引用运算符不同，箭头运算符有更多的限制，其中之一就是箭头运算符的本义是成员访问，所以任何重载的箭头运算符都应该保持这个含义。也就是说，箭头运算符必须返回一个**类的指针**或者是**自定义了箭头运算符的某个类的对象**。除此之外，代码都将发生错误。

当一个`->`运算符按照上述要求实现，那么其执行过程应该如下（以`point->mem`为例）：

- 如果`point->`返回一个指针，则我们应用内置的箭头运算符，表达式等价于`(*point).mem`。如果`point`所指的类型没有名为`mem`的成员，程序会发生错误。
- 如果`point->`返回一个定义了箭头运算符的对象，则调用`point.operator->()`的结果来获取`mem`。其中，如果该结果是一个指针，则执行第 1 步；如果该结果本身含有重载的`operator->`运算符，则重复调用当前步骤。最终，当这一过程结束时程序要么返回了所需的内容，要么返回了一些表示程序错误的信息。

:::