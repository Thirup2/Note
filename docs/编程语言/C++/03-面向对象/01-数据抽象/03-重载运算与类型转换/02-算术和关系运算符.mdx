## 一、算术运算符

- 函数类型：非成员函数
- 参数：通常是两个相同的类类型对象的常量引用
- 返回值：保存结果的类类型对象（通常不应该是引用或指针）

**示例**：

```cpp
Sales_data operator+(const Sales_data &lhs, const Sales_data &rhs)
{
    Sales_data sum = lhs;		// 拷贝到局部变量以便相加
    sum += rhs;					// 使用重载的 += 运算符处理
    return sum;
}
```

:::info 使用复合赋值运算符实现

通常来说，如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值运算符实现算术运算符。

之所以用复合赋值运算符实现算术运算符而不是相反的过程，是因为复合赋值运算符并不适合用算术运算符实现。例如一个`string`对象，如果我们先实现它的`+`操作，那么不难想象这个`+`操作里首先会定义一个局部的类类型的变量，然后由于没有`+=`运算符，所以我们需要对两个运算对象都逐成员进行`+`操作并保存到这个局部变量中，然后返回它。简单算下来，这样的`+`操作首先需要一个对象的空间，然后根据需要进行`+`操作的成员数量判断（假设为`n`），那么就需要进行`2n`次`+`运算才能完成。而用`+`实现的`+=`运算符也需要这样的空间和时间。

而如果使用`+=`来实现`+`运算呢？在`+=`运算符中，不需要多余的空间，只需要对左侧运算对象中的`n`个需要进行`+`运算的成员进行`+`运算即可，时间记为`n`；而使用`+=`实现的`+`运算，首先也需要一个对象的空间，然后需要`+=`操作的时间`n`即可。

所以如果是前者，那么调用这两个操作中的任意一个，都需要一个该类型对象的空间，以及`2n`的时间；而如果是后者，调用这两个操作中的任意一个都只需要`n`的时间，仅仅是`+`操作会多需要一个该类型对象的空间。

:::



## 二、相等运算符

- 函数类型：非成员函数
- 参数：通常是两个相同的类类型对象的常量引用
- 返回值：`bool`类型值

**示例**：

```cpp
bool operator==(const Sales_data &lhs, const Sales_data &rhs)
{
    return lhs.isbn() == rhs.isbn() &&
        lhs.units_sold == rhs.units_sold &&
        lhs.revenue == rhs.revenue;
}
bool operator!=(const Sales_data &lhs, const Sales_data &rhs)
{
    return !(lhs == rhs);
}
```

**设计准则**：

- 如果一个类含有判断两个对象是否相等的操作，则它显然应该把函数定义成`operator==`而非一个普通的命名函数：因为用户肯定希望能使用`==`比较对象，所以提供了`==`就意味着用户无需再费时费力地学习并记忆一个全新的函数名字。此外，类定义了`==`运算符之后也更容易使用标准库容器和算法
- 如果类定义了`operator==`，则该运算符应该能判断一组给定的对象中是否含有重复数据
- 通常情况下，相等运算符应该具有传递性，即如果`a==b`和`b==c`都为真，那么`a==c`也应该为真
- 如果类定义了`operator==`，则这个类也应该定义`operator!=`。
- 相等运算符和不相等运算符中的一个应该把工作委托给另一个，这意味着其中一个运算符应该负责实际比较对象的工作，而另一个运算符则只是调用那个真正工作的运算符。



## 三、关系运算符

- 函数类型：非成员函数
- 参数：通常是两个相同的类类型对象的常量引用
- 返回值：`bool`类型值

**设计准则**：

定义了相等运算符的类也常常包含关系运算符。特别是，因为关联容器和一些算法要用到小于运算符，所以定义`operator<`会比较有用。

通常关系运算符需要满足以下两个要求：

- 定义顺序关系，令其与关联容器中对关键字的要求一致
- 如果类同时也含有`==`运算符的话，则定义一种关系令其与`==`保持一致。特别是，如果两个对象是`!=`的，那么一个对象应该`<`另一个

如果一个类想要设计的关系运算符无法满足这两个要求，那么就不要定义关系运算符