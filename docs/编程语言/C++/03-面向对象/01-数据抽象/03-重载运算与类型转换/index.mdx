---
title: 重载运算与类型转换
---

## 一、概述

重载的运算符是具有特殊名字的函数：它们的名字由关键字`operator`和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。

重载运算符函数的参数数量与该运算符作用的运算对象数量一样多。一元运算符有一个参数，二元运算符有两个。对于二元运算符来说，左侧运算对象传递给第一个参数，而右侧运算对象传递给第二个参数。除了存在的函数调用运算符`operator()`之外，其他重载运算符**不能含有默认实参**。

如果一个运算符函数是成员函数，则它的第一个运算对象将绑定到隐式的`this`指针上，因此，成员运算符函数显式的参数数量比运算符的运算对象总数少一个。

对于一个运算符函数，它要么是类的成员，或者至少含有一个类类型的参数，也就是说我们不能为内置类型定义重载运算符。并且只能重载已有的运算符，而无权发明新的运算符号，同时在已有的运算符中，只有下表中的运算符可以被重载：

```
+		-		*		/		%		^
&		|		~		!		,		=
<		>		<=		>=		++		--
<<		>>		==		!=		&&		||
+=		-=		/=		%=		^=		&=
|=		*=		<<=		>>=		[]		()
->		->*		new		new[]	delete	delete[]
```

而不能被重载的运算符有：`::`、`.*`、`.`、`?:`

对于可以被重载的运算符，其中`+`、`-`、`*`、`&`四个运算符既是一元运算符也是二元运算符，所有这些运算符都能被重载，从参数的数量我们可以推断到底定义的是哪种运算符。

而对于赋值和复合赋值运算符，如果类含有算术运算符或者位运算符，则最好也提供对应的复合赋值运算符。

对于一个重载的运算符来说，其优先级和结合律与对应的内置运算符保持一致。



## 二、重载运算符的调用

重载的运算符有两种调用方式：

- 其一是像在内置类型上使用运算符一样使用，它将隐式调用重载的运算符函数：

  ```cpp
  Sales_data data1, data2;
  data1 + data2;
  ```

- 其二是显式调用重载运算符函数：

  ```cpp
  operator+(data1, data2);
  ```

这两次调用是等价的。



## 三、不应被重载的运算符

以下几种运算符虽然可以被重载，但一般不建议重载，分别是：`&&`、`||`、`,`、`&`。主要有以下两个原因：

- 对于`&&`、`||`、`,`这三个运算符，内置版本规定了这些运算符的求值顺序规则，而重载之后无法保留下来
- 对于`&&`、`||`这两个运算符，内置版本的短路求值属性也无法保留，两个运算对象总是会被求值
- 对于`,`、`&`这两个运算符，C++ 已经定义了当它们作用在类类型对象上时的特殊含义，所以一般来说它们不应该被重载。



## 四、重载运算符的操作逻辑

重载的运算符应该保持与内置类型一致的含义，具体的参考标准如下：

- 如果类执行 IO 操作，则定义移位运算符使其与内置类型的 IO 保持一致
- 如果类的某个操作是检查相等性，则定义`operator==`；如果类有了`operator==`，那么也通常应该有`operator!=`
- 如果类包含一个内在的单序比较操作，则定义`operator<`；如果类有了`operator<`，那它也应该含有其他关系操作。
- 重载运算符的返回类型通常情况下应该与其内置版本的返回类型兼容：逻辑运算符和关系运算符应该返回`bool`，算术运算符应该返回一个类类型的值，赋值运算符和复合赋值运算符则应该返回左侧运算对象的一个引用



## 五、成员或非成员

重载运算符函数可以作为类成员也可以作为非成员存在。我们需要判断一个运算符是作为成员函数存在合适还是作为非成员函数存在更合适。

可以按照下面的准则进行判断：

- 赋值（`=`）、下标（`[]`）、函数调用（`()`）和成员访问箭头（`->`）运算符必须是成员
- 复合赋值运算符一般来说应该是成员，但并非必须，这一点与赋值运算符略有不同
- 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员
- 具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，因此它们通常应该是普通的非成员函数

其中比较需要关注的一点是第四点，一个对称性运算符，以`string`类型的`operator+`为例，它接受两个`string`对象并将其连接起来返回结果。同时，一个 C 风格的字符串可以隐式转换为`string`对象，也就是说我们希望它可以进行下面两种调用方式且不出现错误：

```cpp
string s = "world";

string t = s + "!";
string u = "hi" + s;
```

当`operator+`是一个成员函数时，第一个运算对象则必须是一个`string`对象，不能经过任何隐式转换，此时`string u = "hi" + s;`这种调用方式就会出现错误。而如果`operator+`是一个非成员函数，那么它接受两个`string`类型的参数，这时那个 C 风格字符串就可以转换为`string`对象并调用该运算符了。
