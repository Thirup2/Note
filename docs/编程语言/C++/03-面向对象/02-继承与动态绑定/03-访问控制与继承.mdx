## 一、用户访问权限控制

### 1. 基类的用户访问权限

一个基类有两种用户，一个是类用户，一个是派生类，当基类中使用的访问权限说明符包括`protected`时，两种用户对基类成员的访问权限是有区别的：

- **类用户**：仅能访问`public`成员
- **派生类**：能访问`protected`成员和`public`成员



### 2. 派生类的成员权限

一个派生类除了自己的成员，还包括了基类类型的数据成员，而这个基类类型的数据成员中的成员又有`public`、`protected`、`private`三种访问权限说明符的控制，当这些成员到了派生类中之后，是否还保留原来的权限则取决于类派生列表中使用的访问权限说明符：

- `public`：当类派生列表中使用的访问权限说明符为`public`时，则派生类中基类成员对派生类外的访问权限不变；
- `private`：当类派生列表中使用的访问权限说明符为`private`时，则派生类中基类成员对派生类外的访问权限全部变为`private`的；
- `protected`：当类派生列表中使用的访问权限说明符为`protected`时，则派生类中基类成员中的`public`成员对派生类外的访问权限全部变为`protected`的，其他保持不变。



### 3. 派生类间接访问基类成员权限

派生类对于基类中的`public`和`protected`成员可以直接进行访问。

而如果进行间接进行访问，例如在派生类的成员或友元中通过一个类对象对基类成员进行访问时：

- 当这个类对象是此派生类对象时，则该派生类的该成员或友元可以直接通过这个类对象访问基类中的`public`和`protected`成员；
- 如果该类对象是基类对象，则该派生类的该成员或友元则仅能使用基类对象提供的用户接口，即只能使用`public`成员。

如下例代码所示：

```cpp
class Base {
protected:
    int prot_mem;
};

class Sneaky : public Base {
    friend void clobber(Sneaky&);
    friend void clobber(Base&);
    int j;
};
// highlight-next-line
void clobber(Sneaky& s) { s.j = s.prot_mem = 0; }
// error-next-line
void clobber(Base& b) { b.prot_mem = 0; }
```

这个派生类对自身的所有成员都可以直接访问，而对于其继承的基类则只可以访问其`public`和`protected`成员。

所以作为友元，这两个函数都能够直接访问`Sneaky`中的`public`、`protected`以及属于其自身的`private`成员。由于接受`Sneaky&`的版本本身是`Sneaky`类的友元，所以可以访问`private`成员`j`和继承而来的`protected`成员`prot_mem`；而接受`Base&`的版本虽然是`Sneaky`的友元，但不是`Base`的友元，该函数只能算是`Base`类的普通用户，所以不能通过接受的参数`Base& b`访问`Base`中的`protected`成员。



## 二、派生类向基类转换的可访问性

动态绑定中，派生类的指针或引用可以转换为基类的指针或引用。而这个转换本身并不会让派生类对象转换为基类对象，仅仅是指针认为自己所指的对象变成了基类对象。而我们知道派生类在继承基类后，原本基类成员的访问权限可能在派生类中发生变化（可能使用`protected`或`private`继承），此时如果进行派生类的指针或引用向基类指针或引用的转换，则可能造成使用上的矛盾。故有些转换是不会发生的。

假设`D`继承自`B`：

- 只有当`D`公有地继承`B`时，用户代码才能使用派生类向基类的转换；如果`D`继承`B`的方式是受保护的或私有的，则用户代码不能使用该转换。
- 不论`D`以什么方式继承`B`，`D`的成员函数和友元都能使用派生类向基类的转换；派生类向其直接基类的类型转换对于派生类的成员和友元来说永远是可访问的。
- 如果`D`继承`B`的方式是公有的或者受保护的，则`D`的派生类的成员和友元可以使用`D`向`B`的类型转换；反之，如果`D`继承`B`的方式是私有的，则不能使用。