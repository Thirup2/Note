由于继承和动态绑定中每一个知识点都有必要单独进行说明，故本页只对基类和派生类的基本定义方法和相关知识点进行简单介绍。

整个“继承与动态绑定”章节将以以下两个类作为例子：

- `Quote`类：表示按原价销售的书籍
- `Bulk_quote`类（继承自`Quote`类）：表示打折销售的书籍

## 一、示例定义

### 1. 定义基类

定义基类的方法与定义普通类类型类似，只有一些新增的内容。

对于`Quote`类，基本的定义如下：

```cpp
class Quote {
public:
    Quote() = default;
    Quote(const std::string &book, double Sales_price)
        : bookNo(book), price(sales_price) { }
    std::string isbn() const { return bookNo; }
    // highlight-start
    // 1. 虚函数
    virtual double net_price(std::size_t n) const
    	{ return n * price; }
    virtual ~Quote() = default;
    // highlight-end
private:
    std::string bookNo;
	// highlight-start
    // 2. protected 成员
protected:
    double price = 0.0;
    // highlight-end
};
```



### 2. 定义派生类

派生类必须通过使用**类派生列表**明确指出它是从哪个（哪些）基类继承而来的。类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有以下三种访问说明符中的一个：`public`、`protected`或者`private`。

对于`Bulk_quote`类，基本定义如下：

```cpp
// highlight-start
// 1. 类派生列表
class Bulk_quote : public Quote {
// highlight-end
public:
    // highlight-start
    // 2. 派生类构造函数
    Bulk_quote() = default;
    Bulk_quote(const std::string&, double, std::size_t, double);
    // 3. 覆盖基类虚函数
    double net_price(std::size_t) const override;
    // highlight-end
private:
    // highlight-start
    // 4. 新成员
    std::size_t min_qty = 0;
    double discount = 0.0;
    // highlight-end
};
```

如果仅仅声明而不定义一个派生类，则不应包含它的派生列表：

```cpp
class Bulk_quote;		// Bulk_quote 继承自 Quote 类
```

如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明：

```cpp
class Quote;
// error-next-line
class Bulk_quote : public Quote { /* ... */ };	// Quote 未定义
```

一个类可以既是基类，也是派生类，即派生类可以作为其他类的基类：

```cpp
class Base {/* ... */};
class D1 : public Base {/* ... */};
class D2 : public D1 {/* ... */};
```

当两个类的继承关系紧邻时，此时的基类为派生类的**直接基类**，例如`Base`是`D1`的直接基类，`D1`是`D2`的直接基类；否则称为**间接基类**，例如`Base`是`D2`的间接基类。更为直接的判断方式是直接基类会出现在派生列表中，而间接基类由派生类通过其直接基类继承而来。

每个类都会继承直接基类的所有成员。对于一个最终的派生类来说，它会继承其直接基类的成员；该直接基类的成员又含有其基类的成员；以此类推直至继承链的顶端。因此，最终的派生类将包含它的直接基类的子对象以及每个间接基类的子对象。

如果我们不希望某个类被其他类继承，可以在类名后跟一个关键字`finale`：

```cpp
class NoDerived final { /* ... */ };
```

声明为`final`的类不能被其他类作为基类继承。



## 二、重点内容

### 1. 虚函数

在具有继承关系的类中，可能会有**虚函数**存在。对于普通函数，在继承过程中并不会发生变化，而对于虚函数，派生类在继承时可以对其进行重新定义，即**覆盖**。

虚函数的作用之一是当我们使用指针或引用调用虚函数时，该调用将进行动态绑定。根据引用或指针所绑定对象的类型不同，该调用可能执行的版本也不同，可能执行基类的版本，也可能执行某个派生类的版本。

在基类中，声明一个虚函数需要在函数声明前添加`virtual`关键字，`virtual`关键字只能出现在类内部的声明语句之前而不能用于类外部的函数定义。

在派生类中，可以按照基类的方法声明该类自己的虚函数。同时，对于其继承的基类，其中的虚函数会和其他函数一样继承至派生类中，并且保留基类中的定义和其虚函数属性。派生类也可以覆盖自己所继承的虚函数的实现，方法之一是在函数前添加`virtual`关键字，这样如果有同名且被继承的虚函数存在，则将覆盖其实现，但该方法需要自己保证覆盖函数和被覆盖函数同名；方法之二是在函数中添加`override`关键字，在所有的声明和定义中都要出现，该方法可以替程序员保证有一个同名的被覆盖的虚函数存在。

更多关于虚函数的内容参考[虚函数](../虚函数/)



### 2. 访问控制与继承

派生类除了继承基类的成员函数，还继承基类的数据成员。我们很自然地会认为是将基类中代码复制了一份到派生类中，但实际上并不是这样的，而应该是将一个基类类型的对象作为数据成员添加到了派生类的成员中，不过比较特殊的是我们可以不使用成员访问运算符而直接在派生类中访问其成员，从而造成了“派生就是把基类中的代码复制到了派生类中”这样的错觉。

我们目前只接触到了`public`和`private`两个访问控制说明符，这两种权限下的成员都会被派生类继承，但派生类只能访问公有成员，而不能访问私有成员，同时我们还会希望派生类对基类的访问权限和用户对这个基类的访问权限并不相同。为了解决这个问题，于是添加了一个新的访问控制说明符`protected`。以上三个访问控制说明符除了出现在描述成员之外，还需要在类派生列表中对基类进行描述。

更多关于访问控制与继承的内容参考[访问控制与继承](../访问控制与继承/)



### 3. 派生类构造函数

和之前说的一样，派生是将一个基类对象作为成员添加进派生类中而非直接复制代码，所以对于派生类的构造函数，通常应该是对这个基类类型成员调用它的构造函数，再对派生类独有的数据成员进行初始化，而不是对基类成员也逐个进行初始化。

以`Bulk_quote`的构造函数为例：

```cpp
Bulk_quote(cosnt std::string &book, double p, std::size_t qty, double disc)
    : Quote(book, p), min_qty(qty), discount(disc) { }
```

如上所示，对于派生类中的基类成员，我们首先调用`Quote(book, p)`这一构造函数，然后再对派生类中独有的`min_qty`、`discount`两个成员分别进行了初始化。



### 4. 派生类作用域

派生类的作用域嵌套在基类的作用域之内。也就是说派生类中的成员函数可以直接访问基类中可访问的成员而无需作用域运算符。这也就是为什么派生类中的基类成员是一个类对象却不需要作用域运算符或成员访问运算符的原因。

更多关于派生类作用域的内容参考[继承中的类作用域](../继承中的类作用域/)



### 5. 继承与静态成员

基类中定义的静态成员和之前一样，在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例。

而静态成员的访问权限则遵循通用的访问控制规则，如果基类中的成员是`private`的，则派生类无权访问它。假设某静态成员是可访问的，则我们既能通过基类使用它，也能通过派生类使用它：

```cpp
void Derived::f(const Derived &derived_obj)
{
    Base::statmem();		// 通过基类访问
    Derived::statmem();		// 通过派生类访问
    derived_obj.statmem();	// 通过派生类对象访问
    statmem();				// 通过 this 对象访问
}
```



## 三、继承中的类型转换

### 1. 隐式转换

继承类中的类型转换主要遵循一个原则：**派生类的指针或引用可以转换为基类的指针或引用**。

上述原则有几个需要注意的地方：

- 由于这个原则的存在，所以当我们使用基类的引用或指针时，实际上我们并不清楚使用该引用或指针所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象。在源代码中我们使用的类型称为**静态类型**，而实际运行过程中变量存储在内存中的类型称为**动态类型**。在编写代码时，我们可以基于其静态类型进行编程，但我们必须认识到该程序在运行过程中可能是任何可行的动态类型。

- 智能指针也支持派生类向基类的类型转换

- 只存在从派生类指针或引用到基类指针或引用的隐式转换，不存在基类指针或引用到派生类指针或引用的隐式转换。即使是下面这种情况：

  ```cpp
  Bulk_quote bulk;
  Quote *itemP = &bulk;
  // error-next-line
  Bulk_quote *bulkP = itemP;		// 错误：不能将基类指针转换为派生类指针
  ```

  即使基类指针（或引用）绑定的是一个派生类对象，也不能将这个基类指针转换为相应派生类的指针（或引用）。

- 基类和派生类对象之间并不能转换（除非有隐式转换函数），发生转换的是基类和派生类对象的指针或引用。



### 2. 显式转换

其中基类指针或引用到派生类指针或引用的隐式转换会失败的原因是编译器在编译时无法确定某个特定的转换在运行时是否安全，这是因为编译器只能通过检查指针或引用的静态类型来推断该转换是否合法。

此时有两种显式转换可以帮我们实现基类指针或引用到派生类指针或引用的转换：

- 使用`dynamic_cast`请求一个在运行时进行安全检查的类型转换
- 如果我们已知某个基类指针或引用到派生类指针或引用的转换是安全的，可以直接使用`static_cast`来强制覆盖掉编译器的检查工作

