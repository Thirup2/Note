由于继承和动态绑定中每一个知识点都有必要单独进行说明，故本页只对基类和派生类的基本定义方法和相关知识点进行简单介绍。

整个“继承与动态绑定”章节将以以下两个类作为例子：

- `Quote`类：表示按原价销售的书籍
- `Bulk_quote`类（继承自`Quote`类）：表示打折销售的书籍

## 一、定义基类

定义基类的方法与定义普通类类型类似，只有一些新增的内容。

对于`Quote`类，基本的定义如下：

```cpp
class Quote {
public:
    Quote() = default;
    Quote(const std::string &book, double Sales_price)
        : bookNo(book), price(sales_price) { }
    std::string isbn() const { return bookNo; }
    // highlight-start
    // 1. 虚函数
    virtual double net_price(std::size_t n) const
    	{ return n * price; }
    virtual ~Quote() = default;
    // highlight-end
private:
    std::string bookNo;
	// highlight-start
    // 2. protected 成员
protected:
    double price = 0.0;
    // highlight-end
};
```

### 1. 虚函数

处于继承链中的基类和普通类类型的区别之一就在于基类会存在**虚函数**。对于正常的成员函数，派生类在继承时无法进行覆盖，而对于虚函数，派生类在继承时可以对其重新定义，并进行覆盖（`override`）声明。

当我们使用指针或引用调用虚函数时，该调用将被动态绑定。根据引用或指针所绑定的对象类型不同，该调用可能执行基类的版本，也可能执行某个派生类的版本。

声明虚函数的方法是在函数声明前添加`virtual`关键字来实现，**`virtual`关键字只能出现在类内部的声明语句之前而不能用于类外部的函数定义**。如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。

对于非虚函数，其解析过程发生在编译时；而对于虚函数，其解析过程发生在运行时。

更多关于虚函数的内容参考[虚函数](../虚函数/)



### 2. 访问控制与继承

派生类除了继承基类的成员函数，还继承基类的数据成员。我们很自然地会认为是将基类中的内容复制了一份到派生类中，但实际上并不是这样的。

我们目前只接触到了`public`和`private`两个访问控制说明符，这两种权限下的成员都会被派生类继承，但派生类只能访问公有成员，而不能访问私有成员，所以继承这一机制并非直接复制这么简单。

眼下的问题是如果派生类想要访问基类中的私有成员应该怎么办。如果将基类中的私有成员定义为`public`，那么其会暴露在对用户的接口中，而定义为`private`，派生类则无法访问。于是根据需要，有了第三种访问控制说明符，即`protected`。

仅仅在基类中对成员进行`protected`访问说明并不能，派生类在继承基类时还需要对基类使用一个访问控制说明符，两个说明符组合从而决定派生类所继承的成员的访问权限。

此处仅对派生类继承基类为`public`时进行说明：当派生类继承基类时对基类的声明为`public`时，基类中的`public`和`protected`成员派生类都可以访问，而基类中的`private`成员不能直接访问。对于用户来说，还是只能访问`public`成员，`protected`和`private`成员都无法访问。

更多关于访问控制与继承的内容参考[访问控制与继承](../访问控制与继承/)



## 二、定义派生类

派生类必须通过使用**类派生列表**明确指出它是从哪个（哪些）基类继承而来的。类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有以下三种访问说明符中的一个：`public`、`protected`或者`private`。此处的访问控制说明符和基类中成员的访问控制说明符组合从而决定成员的访问权限，更多关于访问控制与继承的内容参考[访问控制与继承](../访问控制与继承/)。

另外，对于基类中的虚函数，派生类必须进行重新声明。

对于`Bulk_quote`类，基本定义如下：

```cpp
// highlight-start
// 1. 类派生列表
class Bulk_quote : public Quote {
// highlight-end
public:
    // highlight-start
    // 2. 派生类构造函数
    Bulk_quote() = default;
    Bulk_quote(const std::string&, double, std::size_t, double);
    // 3. 覆盖基类虚函数
    double net_price(std::size_t) const override;
    // highlight-end
private:
    // highlight-start
    // 4. 新成员
    std::size_t min_qty = 0;
    double discount = 0.0;
    // highlight-end
};
```

### 1. 派生类中的虚函数

派生类可以不覆盖它继承的虚函数，如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。派生类可以在它覆盖的函数前使用`virtual`关键字，但不是非得这么做，或者也可以在形参列表后面、`const`成员函数的`const`关键字后面或引用成员函数的引用限定符后面添加一个关键字`override`。

更多关于虚函数的内容参考[虚函数](../虚函数/)



### 2. 派生类构造函数

在派生类中虽然包含从基类继承而来的成员，但是派生类并不能直接初始化这些成员。和其他创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分。

以`Bulk_quote`的构造函数为例：

```cpp
Bulk_quote(cosnt std::string &book, double p, std::size_t qty, double disc)
    : Quote(book, p), min_qty(qty), discount(disc) { }
```

我们可以将派生类的对象看成一个基类对象+一个附加对象，而这个附加对象才是我们的派生类真正能够控制的内容，我们定义一个派生类时，实际上定义的也只是这个附加内容。也就是说当我们创建一个派生类对象时，首先会创建一个基类对象，然后再创建一个附加的派生类对象，然后才得到一个我们通常意义上的完整的派生类对象。

而首先创建的这个基类对象，派生类也只能像用户一样使用它，也就是用它暴露出来的接口，唯一不同的是基类中的`protected`成员，其访问权限和继承时使用的访问控制说明符相关。



### 3. 派生类作用域

派生类的作用域嵌套在基类的作用于之内。也就是说派生类中的成员函数可以直接访问基类中可访问的成员而无需作用域运算符。

更多关于派生类作用域的内容参考[继承中的类作用域](../继承中的类作用域/)



### 4. 继承与静态成员
