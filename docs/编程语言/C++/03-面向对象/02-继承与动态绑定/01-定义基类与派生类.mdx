由于继承和动态绑定中每一个知识点都有必要单独进行说明，故本页只对基类和派生类的基本定义方法和相关知识点进行简单介绍。

整个“继承与动态绑定”章节将以以下两个类作为例子：

- `Quote`类：表示按原价销售的书籍
- `Bulk_quote`类（继承自`Quote`类）：表示打折销售的书籍

## 一、定义基类

定义基类的方法与定义普通类类型类似，只有一些新增的内容。

对于`Quote`类，基本的定义如下：

```cpp
class Quote {
public:
    Quote() = default;
    Quote(const std::string &book, double Sales_price)
        : bookNo(book), price(sales_price) { }
    std::string isbn() const { return bookNo; }
    // highlight-start
    // 1. 虚函数
    virtual double net_price(std::size_t n) const
    	{ return n * price; }
    virtual ~Quote() = default;
    // highlight-end
private:
    std::string bookNo;
	// highlight-start
    // 2. protected 成员
protected:
    double price = 0.0;
    // highlight-end
};
```

### 1. 虚函数

处于继承链中的基类和普通类类型的区别之一就在于基类会存在**虚函数**。对于正常的成员函数，派生类在继承时无法进行覆盖，而对于虚函数，派生类在继承时可以对其重新定义，并进行覆盖（`override`）声明。

当我们使用指针或引用调用虚函数时，该调用将被动态绑定。根据引用或指针所绑定的对象类型不同，该调用可能执行基类的版本，也可能执行某个派生类的版本。

声明虚函数的方法是在函数声明前添加`virtual`关键字来实现，**`virtual`关键字只能出现在类内部的声明语句之前而不能用于类外部的函数定义**。如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。

对于非虚函数，其解析过程发生在编译时；而对于虚函数，其解析过程发生在运行时。

更多关于虚函数的内容参考[虚函数](../虚函数/)



### 2. 访问控制与继承

派生类除了继承基类的成员函数，还继承基类的数据成员。我们很自然地会认为是将基类中的内容复制了一份到派生类中，但实际上并不是这样的。

我们目前只接触到了`public`和`private`两个访问控制说明符，这两种权限下的成员都会被派生类继承，但派生类只能访问公有成员，而不能访问私有成员，所以继承这一机制并非直接复制这么简单。

眼下的问题是如果派生类想要访问基类中的私有成员应该怎么办。如果将基类中的私有成员定义为`public`，那么其会暴露在对用户的接口中，而定义为`private`，派生类则无法访问。于是根据需要，有了第三种访问控制说明符，即`protected`。

仅仅在基类中对成员进行`protected`访问说明并不能，派生类在继承基类时还需要对基类使用一个访问控制说明符，两个说明符组合从而决定派生类所继承的成员的访问权限。

此处仅对派生类继承基类为`public`时进行说明：当派生类继承基类时对基类的声明为`public`时，基类中的`public`和`protected`成员派生类都可以访问，而基类中的`private`成员不能直接访问。对于用户来说，还是只能访问`public`成员，`protected`和`private`成员都无法访问。

更多关于访问控制与继承的内容参考[访问控制与继承](../访问控制与继承/)



## 二、定义派生类

派生类必须通过使用**类派生列表**明确指出它是从哪个（哪些）基类继承而来的。类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有以下三种访问说明符中的一个：`public`、`protected`或者`private`。此处的访问控制说明符和基类中成员的访问控制说明符组合从而决定成员的访问权限，更多关于访问控制与继承的内容参考[访问控制与继承](../访问控制与继承/)。

对于`Bulk_quote`类，基本定义如下：

```cpp
// highlight-start
// 1. 类派生列表
class Bulk_quote : public Quote {
// highlight-end
public:
    // highlight-start
    // 2. 派生类构造函数
    Bulk_quote() = default;
    Bulk_quote(const std::string&, double, std::size_t, double);
    // 3. 覆盖基类虚函数
    double net_price(std::size_t) const override;
    // highlight-end
private:
    // highlight-start
    // 4. 新成员
    std::size_t min_qty = 0;
    double discount = 0.0;
    // highlight-end
};
```

### 1. 声明与定义

如果仅仅声明而不定义一个派生类，则不应包含它的派生列表：

```cpp
class Bulk_quote;		// Bulk_quote 继承自 Quote 类
```

如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明：

```cpp
class Quote;
// error-next-line
class Bulk_quote : public Quote { /* ... */ };	// Quote 未定义
```

一个类可以既是基类，也是派生类，即派生类可以作为其他类的基类：

```cpp
class Base {/* ... */};
class D1 : public Base {/* ... */};
class D2 : public D1 {/* ... */};
```

当两个类的继承关系紧邻时，此时的基类为派生类的**直接基类**，例如`Base`是`D1`的直接基类，`D1`是`D2`的直接基类；否则称为**间接基类**，例如`Base`是`D2`的间接基类。更为直接的判断方式是直接基类会出现在派生列表中，而间接基类由派生类通过其直接基类继承而来。

每个类都会继承直接基类的所有成员。对于一个最终的派生类来说，它会继承其直接基类的成员；该直接基类的成员又含有其基类的成员；以此类推直至继承链的顶端。因此，最终的派生类将包含它的直接基类的子对象以及每个间接基类的子对象。

如果我们不希望某个类被其他类继承，可以在类名后跟一个关键字`finale`：

```cpp
class NoDerived final { /* ... */ };
```

声明为`final`的类不能被其他类作为基类继承。



### 2. 派生类中的虚函数

派生类可以不覆盖它继承的虚函数，如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。派生类可以在它覆盖的函数前使用`virtual`关键字，但不是非得这么做，或者也可以在形参列表后面、`const`成员函数的`const`关键字后面或引用成员函数的引用限定符后面添加一个关键字`override`。

更多关于虚函数的内容参考[虚函数](../虚函数/)



### 3. 派生类构造函数

在派生类中虽然包含从基类继承而来的成员，但是派生类并不能直接初始化这些成员。和其他创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分。

以`Bulk_quote`的构造函数为例：

```cpp
Bulk_quote(cosnt std::string &book, double p, std::size_t qty, double disc)
    : Quote(book, p), min_qty(qty), discount(disc) { }
```

我们可以将派生类的对象看成一个基类对象+一个附加对象，而这个附加对象才是我们的派生类真正能够控制的内容，我们定义一个派生类时，实际上定义的也只是这个附加内容。也就是说当我们创建一个派生类对象时，首先会创建一个基类对象，然后再创建一个附加的派生类对象，然后才得到一个我们通常意义上的完整的派生类对象。

而首先创建的这个基类对象，派生类也只能像用户一样使用它，也就是用它暴露出来的接口，唯一不同的是基类中的`protected`成员，其访问权限和继承时使用的访问控制说明符相关。



### 4. 派生类作用域

派生类的作用域嵌套在基类的作用于之内。也就是说派生类中的成员函数可以直接访问基类中可访问的成员而无需作用域运算符。

更多关于派生类作用域的内容参考[继承中的类作用域](../继承中的类作用域/)



### 5. 继承与静态成员

基类中定义的静态成员和之前一样，在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例。

而静态成员的访问权限则遵循通用的访问控制规则，如果基类中的成员是`private`的，则派生类无权访问它。假设某静态成员是可访问的，则我们既能通过基类使用它，也能通过派生类使用它：

```cpp
void Derived::f(const Derived &derived_obj)
{
    Base::statmem();		// 通过基类访问
    Derived::statmem();		// 通过派生类访问
    derived_obj.statmem();	// 通过派生类对象访问
    statmem();				// 通过 this 对象访问
}
```



## 三、继承中的类型转换

### 1. 隐式转换

继承类中的类型转换主要遵循一个原则：**派生类的指针或引用可以转换为基类的指针或引用**。

上述原则有几个需要注意的地方：

- 由于这个原则的存在，所以当我们使用基类的引用或指针时，实际上我们并不清楚使用该引用或指针所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象。在源代码中我们使用的类型称为**静态类型**，而实际运行过程中变量存储在内存中的类型称为**动态类型**。在编写代码时，我们可以基于其静态类型进行编程，但我们必须认识到该程序在运行过程中可能是任何可行的动态类型。

- 智能指针也支持派生类向基类的类型转换

- 只存在从派生类指针或引用到基类指针或引用的隐式转换，不存在基类指针或引用到派生类指针或引用的隐式转换。即使是下面这种情况：

  ```cpp
  Bulk_quote bulk;
  Quote *itemP = &bulk;
  // error-next-line
  Bulk_quote *bulkP = itemP;		// 错误：不能将基类指针转换为派生类指针
  ```

  即使基类指针（或引用）绑定的是一个派生类对象，也不能将这个基类指针转换为相应派生类的指针（或引用）。

- 基类和派生类对象之间并不能转换（除非有隐式转换函数），发生转换的是基类和派生类对象的指针或引用。



### 2. 显式转换

其中基类指针或引用到派生类指针或引用的隐式转换会失败的原因是编译器在编译时无法确定某个特定的转换在运行时是否安全，这是因为编译器只能通过检查指针或引用的静态类型来推断该转换是否合法。

此时有两种显式转换可以帮我们实现基类指针或引用到派生类指针或引用的转换：

- 使用`dynamic_cast`请求一个在运行时进行安全检查的类型转换
- 如果我们已知某个基类指针或引用到派生类指针或引用的转换是安全的，可以直接使用`static_cast`来强制覆盖掉编译器的检查工作

