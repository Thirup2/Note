## 一、声明与定义

### 1. 声明

- 在基类中，声明一个虚函数的方法是在函数的最前方添加`virtual`关键字
- 在派生类中，基类中的虚函数在其所有派生类中都是虚函数，无需二次声明，但也可以添加`virtual`关键字。如果派生类中要添加新的虚函数，则必须在该函数前添加`virtual`关键字。

**基类与派生类的虚函数匹配**：如果一个派生类要覆盖某个继承而来的虚函数，那么它的形参类型必须与被它覆盖的基类函数完全一致。同时，派生类中虚函数的返回类型也必须和基类函数匹配，或者当类的虚函数返回类型是类本身的指针或引用时，且派生类虚函数返回类型到基类虚函数返回类型的类型转换是可访问的。



### 2. 定义

- 由于动态绑定环节发生在运行时，为了保证在运行时任何情况下匹配的虚函数都可执行，故所有的虚函数都必须有定义。
- 允许定义与虚函数名字相同但形参列表不同的函数，该函数可以是虚函数也可以不是，与相对应的同名虚函数是两个独立的函数
- 在派生类中，最好在覆盖基类实现的虚函数中添加`override`关键字，表明该函数是覆盖某基类虚函数的实现，如果没有找到任何基类包含该虚函数，则会报错，从而解决上述第二点中可能造成的“覆盖原虚函数实现的函数实际上是另一个独立函数”的问题。
- 可以在虚函数中添加`final`关键字，后续所有尝试覆盖该函数的操作都将引发错误。



## 二、默认实参

虚函数可以有默认实参，但派生类中虚函数的参数不会继承基类中该虚函数的默认实参。

同时，调用该虚函数时默认实参值并不由实际调用的动态类型决定，而是由调用对象的静态类型决定。例如，当调用实际上将运行基类对应的虚函数时，但调用该虚函数的对象是该基类的派生类，那么此时如果使用了默认实参，则默认实参值由派生类的对应虚函数中的默认实参值决定，然后再进入实际要调用的基类对应的虚函数的函数体。

所以，如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。



## 三、回避动态绑定

当我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本时，需要使用作用域运算符：

```cpp
double undiscounted = baseP->Quote::net_price(42);
```

如果不使用作用域运算符，即`baseP->net_price(42)`，那么这次调用的函数可能是`Quote`类型的，也可能是`Bulk_quote`类型的，具体取决于`baseP`的类型。而当我们添加了作用域运算符，那么无论`baseP`的类型是什么，都将调用`Quote`类型的该函数。

当使用了作用域运算符后，虚函数的调用将不会进行动态绑定，且该调用将在编译时完成解析。

该操作的常见用途是派生类的虚函数实现需要调用基类中的虚函数版本时，如果不采用该方法指定具体调用的函数，那么将一直调用它自身，导致无限递归。