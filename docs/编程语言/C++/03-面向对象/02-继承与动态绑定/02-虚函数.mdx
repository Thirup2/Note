## 一、声明与定义

### 1. 声明

- 在基类中，声明一个虚函数的方法是在函数的最前方添加`virtual`关键字
- 在派生类中，如果要声明新的虚函数，则和基类声明虚函数的方法相同；如果使用基类中的虚函数且无需覆盖，则无需单独声明；如果需要对基类中的虚函数进行覆盖，则应该重新声明该函数，对于重新声明的函数，可以选择添加或不添加`virtual`关键字，如果不添加也并不影响该函数的虚函数属性。

**基类与派生类的虚函数匹配**：如果一个派生类要覆盖某个继承而来的虚函数，那么它的形参类型必须与被它覆盖的基类函数完全一致。另外，派生类中虚函数的返回类型也必须和基类函数匹配，否则要求类的虚函数返回类型是类本身的指针或引用，且派生类虚函数返回类型到基类虚函数返回类型的类型转换是可访问的。



### 2. 定义

- 由于动态绑定环节发生在运行时，为了保证在运行时任何情况下匹配的虚函数都可执行，故所有的虚函数都必须有定义（纯虚函数除外）。
- 在派生类中，最好在覆盖基类实现的虚函数中添加`override`关键字，表明该函数是覆盖某基类虚函数的实现，如果没有找到任何基类包含该虚函数，则会报错。
- 可以在虚函数中添加`final`关键字，后续所有尝试覆盖该函数的操作都将引发错误。
- 通过在函数体的位置（即声明语句的分号之前）用`=0`替代，可以将一个虚函数说明为纯虚函数。



## 二、纯虚函数

含有纯虚函数的类通常是用来提供接口的类，这表明它并不需要实现，所有派生自该类的派生类各自决定应该如何实现或仍保持为纯虚函数。派生类如果不对纯虚函数进行覆盖，那么该派生类仍然拥有纯虚函数。

纯虚函数的声明方法通过在函数体的位置（即声明语句的分号之前）用`=0`代替即可声明一个纯虚函数。其中，`=0`只能出现在类内部的虚函数声明语句处。

纯虚函数不需要定义，但我们仍然可以为它提供定义，但函数体必须定义在类的外部，而不能在类的内部为一个`=0`的函数提供函数体。

:::info 为什么不需要定义却可以提供定义

纯虚函数的主要目的是提供接口，并不需要实现，但为什么 C++ 又有允许在类外定义纯虚函数这样混淆的规则呢？

具体的答案并不清楚，这样的用法或许有一定的应用场景，然而，重要的是要认识到，虽然 C++ 允许在类外部定义纯虚函数的函数体，但这并不是推荐的做法，也不符合纯虚函数作为抽象接口的本质。在大多数情况下，纯虚函数应该仅作为接口声明，而具体的实现留给派生类。如果需要提供一个默认实现，更常见的做法是使用非纯虚函数（即，具有函数体的虚函数），这样既保持了多态性，又避免了抽象类的限制。

:::

**含有（或者未经覆盖直接继承）纯虚函数的类是抽象基类**。

抽象基类负责定义接口，而后续的其他类可以覆盖该接口。我们不能（直接）创建一个抽象基类的对象，但可以创建一个抽象基类的指针或引用，用于动态绑定。



## 三、默认实参

虚函数可以有默认实参，但派生类中虚函数的参数不会继承基类中该虚函数的默认实参。

同时，调用该虚函数时默认实参值并不由实际调用的动态类型决定，而是由调用对象的静态类型决定。例如，当调用实际上将运行基类对应的虚函数时，但调用该虚函数的对象是该基类的派生类，那么此时如果使用了默认实参，则默认实参值由派生类的对应虚函数中的默认实参值决定，然后再进入实际要调用的基类对应的虚函数的函数体。

所以，如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。



## 四、虚函数与重载

在考虑重载时，不用关心函数是否具有虚函数的属性。即同一个类中，所有同名的虚函数和普通函数其参数列表必须有函数匹配优劣度上的区别；

派生类中继承的基类中的虚函数在派生类中也参与重载判定；

当用户通过指针或引用调用的函数经函数匹配后匹配为普通函数，则不进行动态绑定；如果经函数匹配后为虚函数，则进行动态绑定。



## 五、回避动态绑定

当我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本时，需要使用作用域运算符：

```cpp
double undiscounted = baseP->Quote::net_price(42);
```

如果不使用作用域运算符，即`baseP->net_price(42)`，那么这次调用的函数可能是`Quote`类型的，也可能是`Bulk_quote`类型的，具体取决于`baseP`的类型。而当我们添加了作用域运算符，那么无论`baseP`的类型是什么，都将调用`Quote`类型的该函数。

当使用了作用域运算符后，虚函数的调用将不会进行动态绑定，且该调用将在编译时完成解析。

该操作的常见用途是派生类的虚函数实现需要调用基类中的虚函数版本时，如果不采用该方法指定具体调用的函数，那么将一直调用它自身，导致无限递归。