---
description: C++ 基础语法 -> 数据 -> 数据类型 -> 复合类型 -> 数组
keywords: [C++,复合类型,数组]
---

## 一、声明定义与初始化

### 1. 声明与定义

数组的声明方式需要用到下标操作符`[]`，如下所示：

```cpp
int arr[10];
```

其中`arr`是数组的名字，`10`说明了数组中元素的个数即数组的维度，必须大于 0。

另外，维度必须是一个常量表达式，其必须在编译阶段就获得其值，并为数组分配内存。并且数组一旦被定义，就无法再变更大小。

关于数组的类型，必须明确指定而不允许使用`auto`关键字由初始值列表推断类型，同时数组的元素应为对象，因此不存在引用的数组。



### 2. 初始化

**默认初始化**：默认情况下，数组的元素被默认初始化，即对数组中每个元素执行默认初始化。

**显式初始化**：可以对数组的元素进行列表初始化，此时允许忽略数组的维度。如果忽略数组的维度，则最终创建的数组的元素个数与初始值列表中的元素个数相同；如果指定了数组的维度，则初始值列表中的元素个数不得超过该维度，如果提供的元素个数小于该维度值，则用提供的值从前往后开始初始化，剩下的元素执行值初始化。

**字符数组的初始化**：对于字符数组除了以上的初始化方式外，还可以用字符串字面值对其进行初始化。需要记住的是，一个字符串字面值永远比看到的字符个数多一个位置用于存放空字符，也就是 C 风格的字符串。需要注意的是，该方法实际上是列表初始化的一个特例，所以必须满足列表初始化的要求。

:::caution 关于初始化方式

数组的初始化方式总共就只有以上几种，而并不像`string`或`vector`那样还可以通过拷贝或者构造进行初始化。实际上，数组本身根本不允许拷贝和赋值。

:::



### 3. 复杂的数组声明

数组能存放多数类型的对象，也能声明数组的指针和引用，它们的声明方式比较复杂，但只需要把握一个原则就能完全把握其声明方式，那就是运算符的优先级，例如：

```cpp
int *ptrs[10];				// `[]` 的优先级高于 `*`，所以 ptrs 优先与 [] 结合，表示这是一个数组，然后再先后和 *、int 结合，即指向 int 类型的指针的数组
// error-next-line
int &refs[10] = /* ? */;	// 和上面的逻辑相同，这是一个 int 类型的引用的数组，但 C++ 不允许该数组类型，故发生错误
int (*Parray)[10] = &arr;	// 指向 int [10] 类型数组的指针
int (&arrRef)[10] = arr;	// 与 int [10] 类型数组绑定的指针
```



## 二、操作

### 1. 范围 for 语句

数组支持使用范围 for 语句依次访问其元素

```cpp
int a[10] = {};
for (int &elem : a) {
    elem = 1;
}
for (int elem : a) {
    cout << elem << endl;
}
```



### 2. 下标访问

数组的下标接受的参数和其他类似，使用数组下标的时候，通常将其定义为`size_t`类型，`size_t`是一种机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象的大小。但这只是推荐使用的类型，我们在使用数组（准确来说是指向数组元素的指针）的时候，还可以使用负值作为下标。

数组除了大小固定这一特点外，其他用法和`vector`基本类似。

同时，我们仍然需要检查下标的值是否越界。



### 3. 指针与数组

**获取指向数组元素的指针**：

在大部分情况下，数组名会隐式转换为指向其元素类型的指针，例如：

```cpp
int ia[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
auto ia2(ia);		// ia2 是一个 int * 类型，并指向 ia 中的首元素
```

实际上就是`ia`这个数组名被隐式转换为了指向其元素类型的指针，等价于：

```cpp
int *ia2(&ia[0]);
```

但该特点在我们使用`decltype`的时候不会发生，`decltype(ia)`将严格返回一个`int [10]`类型。

另外，如果我们要声明一个指向数组整体的指针，则使用：

```cpp
int (*PtA)[10] = &ia;		// 注意此处取地址的方法和 &ia[0]、ia 都不一样，只有这样取地址得到的才是指向一个指向数组的指针
```



**指针作为迭代器**：

指针本身支持的操作可以让我们像用迭代器一样使用指针，实际上迭代器才是模仿指针写出的。

我们可以自行移动指针来获取首指针和尾后指针，但这种方法错误率较高。我们也可以用迭代器库提供的函数来获取，它们都返回指针类型：

```cpp
#include <iterator>
using std::begin;
using std::end;

int *pbeg = begin(arr), *pend = end(arr);
while (pbeg != pend && *pbeg >= 0)
    ++pbeg;
```



**指针运算**：

- `*p`：类似于指针解引用。返回指针`p`所指元素的引用
- `p->mem`：类似于指针的类成员访问。接引用`p`并获取该元素的名为`mem`的成员，等价于`(*p).mem`
- `++p`：类似于指针向数组后方移动一个元素。令`p`指向容器中的下一个元素
- `--p`：类似于指针向数组前方移动一个元素。令`p`指向容器中的上一个元素
- `p1 == p2`/`p != p2`：判断两个指针是否相等（不相等），如果两个指针指向的是同一个元素或者它们是同一个容器的尾后指针，则相等；否则则不等。
- `p + n`：运算结果是一个指针，该指针指向原指针向尾部方向移动`n`个元素的位置
- `p - n`：运算结果是一个指针，该指针指向原指针向首部方向移动`n`个元素的位置
- `p1 += n`：将指针向尾部方向移动`n`个元素
- `p1 -= n`：将指针向首部方向移动`n`个元素
- `p1 - p2`：得到`p1`与`p2`的距离，其值的类型为`ptrdiff_t`，定义在`cstddef`头文件中，也是前四个运算中`n`所使用的类型
- `<`、`<=`、`>`、`>=`：指针的大小判断，当同一个容器中某指针所指位置在另一个指针所指位置之前，则指前者小于后者。参与运算的两个指针必须指向同一个容器中的元素或者尾元素的下一位置。
- `p[n]`：等价于`*(p + n)`，返回`p`所指位置后移`n`个位置的元素的引用。

:::caution 关于 p[n]

和其他迭代器不同，指针还允许使用下标运算符，但通常只有当指针指向数组中某元素或数组尾后位置时，该表达式才是有效的，这一点编译器不会进行检查，我们需要自行检查。

而且与其他类自定义的下标运算符不同的是，内置的下标运算允许输入一个负值，只要结果地址指向原来的指针所指同一数组中的元素（或尾后位置）即可：

```cpp
int ia[] = {0, 2, 4, 6, 8};
int *p = &ia[2];
int k = p[-2];		// 将 ia[0] 赋值给 k
```

同样，编译器并不会检查访问的地址是否是有效地址，仍需我们自行检查。

:::



## 三、C风格字符串

### 1. 简介

C 风格字符串即使用原生数组实现的字符串，这种字符串将字符依序存放在数组中，并以空字符`\0`作为结束。一般利用指针来操作这些字符串。



### 2. C 标准库字符串操作

在`<cstring>`头文件中提供了一组函数用于操作 C 风格字符串，如下：

- `strlen(p)`：返回字符串指针`p`的长度，空字符不计算在内
- `strcmp(p1, p2)`：比较两个字符串指针`p1`、`p2`的相等性。如果`p1==p2`，返回 0；如果`p1>p2`，返回一个正值；如果`p1<p2`，返回一个负值
- `strcat(p1, p2)`：将`p2`附加到`p1`之后，返回`p1`（**注意**：该函数不检查`p1`的容量，如果`p1`数组的容量不足以容纳两个字符串以及一个空字符的内容，将引发错误）
- `strcpy(p1, p2)`：将`p2`拷贝给`p1`，返回`p1`（**注意**：该函数不检查`p1`的容量，如果`p1`数组的容量小于`p2`字符串的长度以及一个空字符的内容，将引发错误）



### 3. string 类与 C 风格字符串的接口

1. **何处使用 C 风格字符串**

   需要注意的是 C 风格字符串和字符串字面值在 C++ 中是两个概念，虽然字符串字面值实际上也是一个 C 风格字符串，但 C 风格字符串这个词还包括以空字符结束的字符数组，为避免歧义同时减少重复声明，后文也将用 C 风格字符串作为以空字符结束的字符数组的专称，但你应该清楚其还包括字符串字面值。

   在 string 类中，我们常常会用到字符串字面值，而在任何能用到字符串字面值的地方，都可以用 C 风格字符串替代。

2. **string 对象转换为 C 风格字符串**

   在需要 C 风格字符串的地方，我们不能使用一个 string 对象去代替，但可以使用 string 类提供的一个成员函数获得一个指向和 string 对象相同内容的 C 风格字符串的指针。该成员函数为`c_str()`，返回一个`const char *`，如：

   ```cpp
   string s("Hello World!");
   const char *str = s.c_str();
   ```

   **需要注意的是**：通过该成员函数获取的 C 风格字符串应该**当时获取当时使用**，因为如果后续的操作改变了用于获取 C 风格字符串的 string 对象的值，则该指针可能会失效。



## 四、多维数组

### 1. 定义与初始化

严格来说，C++ 中并没有多维数组，只有数组的数组，及元素类型为相同尺寸大小的数组的数组。其基本声明方法：

```cpp
int ia[3][4];		// ia 包含 3 个元素，每个元素都是包含 4 个 int 元素的数组
```

多维数组的初始化仍然遵循普通数组的初始化规则，基本初始化方法如下：

```cpp
int ia[3][4] = {
    {0, 1, 2, 3},
    {4, 5, 6, 7},
    {8, 9, 10, 11},
};
```

在列表初始化的内部，我们又使用了几个列表，使用列表形式的好处是每一个列表都表示一个数组元素，哪怕没有为每一个元素都提供初始值，下一个列表也将从第二个数组元素开始初始化。

在外层列表内部，我们也可以不用列表形式初始化，此时的初始化将按照最底层元素的位置顺序依次用初始值为其初始化：

```cpp
int ia[3][4] = {
    {0, 1},					// 第 1 行初始化为 0, 1, 0, 0
    4, 5, 6, 				// 第 2 行初始化为 4, 5, 6, 8
    8, 9, 10,				// 第 3 行初始化为 9, 10, 0, 0
};
```



### 2. 多维数组与指针的转换

**原则：多数情况下，单纯的数组名将被转换为指向该数组中第一个元素的指针。**

在多维数组中，该原则仍然成立，只不过在多维数组中，有多层数组存在。

以**二维数组**`int ia[3][4]`为例，最外层的数组的元素类型为：`int [4]`，是一个数组，所以当我们使用`ia`这个纯数组名时，通常被转换为指向其元素的指针，也就是`int (*)[4]`，后面的`4`作为元素类型的一部分，必须和声明中保持一致，这个指针指向一个含有 4 个`int`元素的数组，对该指针`+1`，将使其指向二维数组中的第 2 个子数组而不是第一个子数组中的第 2 个元素。例如：

```cpp
int ia[3][4] = {
    {0, 1, 2, 3},
    {4, 5, 6, 7},
    {8, 9, 10, 11},
};

// highlight-start
int (*pa1)[4] = ia;		// 指向数组 ia 第 1 个元素，即 ia[0]
int (*pa2)[4] = ia + 2;	// 指向数组 ia 第 3 个元素，即 ia[2]
// highlight-end
```

由于最外层元素仍然是数组，所以`ia[n]`可以当作是内层数组的数组名使用，其中`n`必须在第一层维度的范围内。当我们使用`ia[n]`这个内层数组的数组名时，则和以前一样了，将转换成指向其元素`int`的指针，即`int *`。例如：

```cpp
int ia[3][4] = {
    {0, 1, 2, 3},
    {4, 5, 6, 7},
    {8, 9, 10, 11},
};

// highlight-start
int *pi1 = ia[0];		// 指向数组 ia[0] 第 1 个元素，即 ia[0][0]
int *pi2 = ia[2] + 3;	// 指向数组 ia[2] 第 4 个元素，即 ia[2][3]
// highlight-end
```



### 3. 多维数组各种指针和引用的定义

以多维数组`int iaa[3][4]`为例

1. **指向整个数组的指针或与之绑定的引用**：
   - **指针**：`int (*piaa)[3][4] = &iaa`，`*piaa`可当作一个二维数组使用
   - **引用**：`int (&riaa)[3][4] = iaa`，`riaa`可当作一个二维数组使用
2. **指向内层数组的指针或与之绑定的引用**：
   - **指针**：`int (*pia)[4] = &iaa[1]`（等价于直接使用`iaa + 1`），`*pia`可当作一个一维数组使用
   - **引用**：`int (&ria)[4] = iaa[1]`，`*ria`可当作一个一位数组使用
3. **指向基础元素的指针或与之绑定的引用**：
   - **指针**：`int *pi = &iaa[1][2]`（等价于直接使用`*(iaa + 1) + 2`）
   - **引用**：`int &pi = iaa[1][2]`



### 4. 元素处理

1. **一般 for 循环处理（使用下标）**

   ```cpp
   constexpr size_t rowCnt = 3, colCnt = 4;
   int ia[rowCnt][colCnt];
   //highlight-start
   for (size_t i = 0; i != rowCnt; ++i) {
       for (size_t j = 0; j != colCnt; ++j) {
           ia[i][j] = i * colCnt + j;
       }
   }
   //highlight-end
   ```

2. **范围 for 循环处理**

   - 需要更改元素内容时

     ```cpp
     size_t cnt = 0;
     //highlight-start
     for (int (&row)[4] : ia) {
         for (int &col : row) {
             col = cnt;
             ++cnt;
         }
     }
     //highlight-end
     ```

     当然，也可以使用指针进行间接访问

     ```cpp
     size_t cnt = 0;
     // highlight-start
     for (int (*row)[4] : ia) {
         for (int *col : *row) {
             *col = cnt;
             ++cnt;
         }
     }
     // highlight-end
     ```

   - 无需修改元素内容时：

     ```cpp
     for (int (&row)[4] : ia) {
         for (int col : row) {
             cout << col;
         }
     }
     ```

     需要注意的是由于`ia`的元素是数组，而数组不能进行拷贝，所以我们必须把外层遍历变量声明为引用或指针，而不能声明成`int row[4]`。

     使用指针进行遍历的方法不再列出。

     需要特别注意的是当使用`auto`进行遍历的时候，外层遍历变量必须显式声明为引用，否则将被推断为指向基础元素类型的指针：

     ```cpp
     for (auto &row : ia) {
         for (auto col : row) {
             cout << col;
         }
     }
     ```

     因为用范围 for 遍历二维数组`ia`时，其第一层是 4 个元素的数组作为元素，所以`row`理应被推断为`int [4]`类型，但如前所述这是行不通的，所以`row`会被推断为一个指向基础元素的指针，实际上是`ia[0]`作为数组名所转换出的指针。但由于这是一个指针，而非数组，所以无法对其进行范围 for 循环。（从这也可以看出指向数组元素的指针和数组是不同的东西）。

   
