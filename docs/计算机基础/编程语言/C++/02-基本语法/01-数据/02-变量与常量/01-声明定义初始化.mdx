## 简介

C++ 创建一个变量或者常量基本都是三步：

1. **声明**：将一个名字引入程序，这个名字叫做标识符
2. **定义**：根据该名字的类型为其分配对应大小的内存，可以通过地址对其数据进行访问。这个过程也叫**对象**创建的过程
3. **初始化**：当对象在创建时获得的一个值就是**初始值**，这个过程叫做初始化。

一个最简单创建变量的语句可能就是像下面这样的：

```cpp
int a;
```

看上去它表面上只是做了声明这一步，但实际上它三步都完成了。**声明**很显然语句结束就完成了，与此同时会默认为该名字分配对应大小的内存，所以**定义**也在这条语句中就完成了。**初始化**实际上也是一样，如果不对其进行显式初始化，则会执行默认初始化。



## 一、声明

### 1. 语法

像上面的语法一样，我们可以在声明一个名字的同时定义它，具体的格式是在一个**类型说明符**后面紧跟一个或多个变量名组成的列表，变量名以逗号分隔，最后以分号结束。整个列表中每个变量名的类型都由最前面的一个类型说明符指定，所以放在同一个变量名列表中的名字都一定是同一种类型。另外，还可以为列表中每一个变量赋初始值，具体如下：

```cpp
int a;
double b, c, d;
short sum = 0， value, average = 0;
```

以上语句全都完成了声明、定义和初始化这三步。

**只声明不定义的方法**：

而 C++ 为了允许把程序拆分成多个逻辑部分来写，它支持**分离式编译**机制，该机制允许将程序分割为若干个文件，每个文件可以被独立编译。

如果将程序分为多个文件，则需要有在文件间共享代码的方法。例如，一个文件的代码可能需要使用另一个文件中定义的变量。一个实际的例子是`std::cout`和`std::cin`，它们定义于标准库，却能被我们的程序使用。

为了支持分离式编译，C++ 语言将声明和定义区分开来。我们可以只进行声明，但不进行定义，对于变量而言，其语法是在上述语句前添加`extern`关键字，如：

```cpp
extern int a;
extern double b, c, d;
// error-next-line
extern sum = 0;
```

使用这种方法，我们可以只引入一个名字，编译器会去其他地方查找该名字的定义，如果找不到，则会报错。

另外，由于变量的初始化过程只有在定义了之后才能进行，所以上面代码中的第三条语句中的`extern`的效果会遭到抵消，所以这是一条声明并定义的语句。并且，如果在函数体内部试图初始化一个由`extern`关键字标记的变量，还会引发错误。



### 2. 标识符

声明将引入一个名字，名字则用来标识一个对象，无论这个对象是在声明处定义还是定义在别处，它们都用同一个名字进行直接访问，所以这个名字也叫做**标识符**。

另外，实际上不止变量有标识符，函数、类、模板等都有标识符。

C++ 中对于标识符有一些命名规则需要遵守：

- 标识符由字母、数字和下划线（`_`）组成，其中必须以字母或下划线开头。

- 标识符的长度没有限制，但是对大小写字母敏感

- 另外，C++ 的关键字以及保留字不能用作标识符，具体包括：

  - C++ 关键字

    ```
    alignas		continue		friend		register			true
    alignof		decltype		goto		reinterpret_cast	try
    asm			default			if			return				typedef
    auto		delete			inline		short				typeid
    bool		do				int			signed				typename
    break		double			long		sizeof				union
    case		dynamic_cast	mutable		static				unsigned
    catch		else			namespace	static_assert		using
    char		enum			new			static_cast			virtual
    char16_t	explicit		noexcept	struct				void
    char32_t	export			nullptr		switch				volatile
    class		extern			operator	template			wchar_t
    const		false			private		this				while
    constexpr	float			protected	thread_local
    const_cast	for				public		throw
    // 以下是 C++ 操作符替代名
    and			bitand			compl		not_eq				or_eq		xor_eq
    and_eq		bitor			not			or					xor
    ```

  - C++ 保留字

    - 任意位置出现两个连续下划线的任意标识符
    - 下划线紧连大写字母开头的标识符
    - 以下划线开头（函数体外）的标识符



## 二、定义

变量的定义就不用再多说了，只要不包含`extern`关键字，则一条声明语句也就同时会进行定义。

而即使是在所有函数外使用了`extern`关键字，如果对其进行了初始化，则仍然会对该变量进行定义，此处的`extern`基本不起任何作用，或者说唯一的作用是用来表明该变量会被其他文件或程序用上，所以用`extern`明示其是一个具有外部链接的变量。



## 三、初始化

### 1. 默认初始化

当我们声明并定义一个变量之后，如果没有显式进行任何初始化过程，则变量会被默认初始化，此时变量被赋予**默认值**。而默认值具体是什么是由变量类型和变量定义的位置共同决定的。

对于**内置类型**来说，如果其定义在**任何函数之外**，则初始化为 0，否则将**不被初始化**，此时变量的值是一个未定义的垃圾值。

对于**类**来说，则初始化方式由每个类自行决定，除此之外类还决定是否允许不经初始化就定义对象。



### 2. 拷贝初始化

形如`int a = 0;`的初始化方式就是**拷贝初始化**，拷贝初始化的含义是用将值从一个对象拷贝到另一个对象的方式初始化该对象。

上面的表达式明显不符合拷贝初始化的定义，因为右侧是一个字面值，实际上，如果按照 C++ 的定义，程序需要先用右侧的字面值直接初始化一个对应类型的临时对象，然后再将这个临时对象拷贝给左侧的新建对象。

然而，事实上，大部分时候编译器都会将拷贝初始化自动优化为直接初始化，所以也不用担心效率问题。



### 3. 直接初始化

形如`int a(0);`的初始化方式就是**直接初始化**，直接初始化与拷贝初始化的区别就是拷贝初始化可能需要创建一个临时对象，而直接初始化则不用，它是在对象创建阶段，直接用初始值对对象进行初始化。



### 4. 列表初始化

形如`int a{0};`或`int a = {0};`的初始化方式就是**列表初始化**，列表初始化首先可以用来初始化集合类数据类型，其次也可以用来初始化单个对象。

当列表初始化用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险时，则编译器将报错，例如：

```cpp
long double ld = 3.1415926;
int c(ld), b = ld;			// 正确：转换执行，且确实丢失了部分值
// error-next-line
ing a{ld}, b = {ld};		// 错误：转换未执行，因为存在丢失信息的风险
```



### 5. 值初始化

当使用空的括号或花括号对组成的初始化器创建一个对象时，通常会进行值初始化。

对于内置类型，值初始化的效果是将其设置为 0。对于类类型，则元素由类默认初始化。
