## 一、类型别名

| 类型别名                 | 含义                                                         |
| ------------------------ | ------------------------------------------------------------ |
| `iterator`               | 此容器类型的迭代器类型                                       |
| `const_iterator`         | 可以读取元素，但不能修改元素的迭代器类型                     |
| `size_type`              | 无符号证书类型，足够保存此种容器类型最大可能容器的大小       |
| `difference_type`        | 带符号整数类型，足够保存两个迭代器之间的距离                 |
| `value_type`             | 元素类型                                                     |
| `reference`              | 元素的左值类型；与`value_type&`含义相同                      |
| `const_reference`        | 元素的`const`左值类型（即，`const value_type&`）             |
| `reverse_iterator`       | 反向迭代器                                                   |
| `const_reverse_iterator` | 常量反向迭代器                                               |
| `key_type`               | 此容器类型的关键字类型                                       |
| `mapped_type`            | 每个关键字关联的类型（只适用于`map`）                        |
| `value_type`             | 对于`set`，与`key_type`相同<br />对于`map`，为`pair<const key_type, mapped_type>` |

对于`map`，其关键字不能改变，所以是`const key_type`；对于`set`，其关键字类型虽然并非`const`，但也是只读的，也不能改变。



## 二、构造函数

| 构造函数            | 效果                                                 |
| ------------------- | ---------------------------------------------------- |
| `C c`               | 默认构造函数，构造空容器                             |
| `C c1(c2)`          | 构造`c2`的拷贝`c1`                                   |
| `C c(b, e)`         | 构造`c`，将迭代器`b`和`e`指定的范围内的元素拷贝到`c` |
| `C c{a, b, c, ...}` | 列表初始化`c`，非`explicit`，故可拷贝                |

**实例化**：

对于`map`以及其延伸类型而言，至少需要两个类型参数进行实例化。对于`set`及其延伸类型而言，至少需要一个类型参数进行实例化。

关联容器中的元素默认使用关键字类型的`<`运算符来比较两个关键字，可以使用自定义的操作来代替关键字上的`<`运算符，其格式是在实例化时提供一个额外的类型参数，这个类型应该是需要传入的函数的类型，在创建该类型的对象时，必须提供一个相同类型的函数作为构造函数的参数。

自定义的操作必须在关键字类型上定义一个**严格弱序**。可以将严格弱序看作“小于等于”，虽然实际定义的操作可能是一个复杂的函数，但无论我们怎样定义比较函数，它必须具备如下性质：

- 两个关键字不能同时“小于等于”对方；如果`k1`“小于等于”`k2`，那么`k2`决不能“小于等于”`k1`
- 如果`k1`“小于等于”`k2`，且`k2`“小于等于”`k3`，那么`k1`必须“小于等于”`k3`
- 如果存在两个关键字，任何一个都不“小于等于”另一个，那么我们称这两个关键字是“等价”的。如果`k1`“等价于”`k2`，且`k2`“等价于”`k3`，那么`k1`必须“等价于”`k3`

作为自定义操作给出的操作实际上是实例化类型的一部分，所以需要在实例化一个关联容器时提供这个额外操作的类型，创建该类型对象时需要提供一个相同类型的实参，这个额外操作的类型通常使用`decltype`来获取：

```cpp
bool compareIsbn(const Sales_data &lhs, const Sales_data &rhs)
{
    return lhs.isbn() < rhs.isbn();
}

// highlight-next-line
multiset<Sales_data, decltype(compareIsbn)*> bookstore(compareIsbn);
```

> 创建有自定义操作类型的关联容器类型的对象时，必须提供该操作类型的实参，实参位置为初始值之后。例如，对于提供两个迭代器的版本，则自定义操作函数应该作为第三个参数给出；而对于列表初始化，应该再在外层覆盖一个圆括号，并在紧邻花括号之后给出自定义操作：
>
> ```cpp
> map<T1, T2, Comp> c(b, e, comp);
> set<T1, Comp> c2({li1, li2, li3/* other elem */}, comp);
> ```

**列表初始化**：

对于`set`类型而言，列表初始化比较正常，而对于`map`类型，列表中的成员应该是一个一个的`pair`类型的初始化值，刚好`pair`类型的初始化值也使用列表给出，所以`map`类型的列表初始化通过列表中内嵌列表的形式给出：

```cpp
map<string, int> count{{"one", 1}, {"two", 2}, {"three", 3}};
```

**multi 版本的区别**：

对于不带`multi`的`map`和`set`而言，它们的每个关键字只能添加一次，不允许关键字重复的元素出现在一个容器中。

而对于`multimap`和`multiset`，它们的所有关键字都可以重复。



## 三、其他操作

### 1. 迭代器

| 操作                       | 效果                                        |
| -------------------------- | ------------------------------------------- |
| `c.begin()`、`c.end()`     | 返回指向`c`的首元素和尾元素之后位置的迭代器 |
| `c.cbegin()`、`c.cend()`   | 返回`const_iterator`                        |
| `c.rbegin()`、`c.rend()`   | 返回指向`c`的尾元素和首元素之前位置的迭代器 |
| `c.crbegin()`、`c.crend()` | 返回`const_reverse_iterator`                |

- 当解引用一个关联容器迭代器时，我们得到的是一个类型为容器的`value_type`的值的引用。对`map`而言，`value_type`是一个`pair`类型，其迭代器可以不是`const`的，但其`first`成员保存`const`的关键字，`second`成员保存值。对于`set`而言，其迭代器是`const`的，不能修改。
- 使用迭代器遍历有序关联容器的元素也是有序的；遍历无序关联容器的元素可能是无序的。

> **关联容器与算法**：
>
> 我们通常不对关联容器使用泛型算法，关联容器的关键字是`const`的这一特性意味着不能将关联容器传递给修改或重排容器元素的算法。
>
> 关联容器可用于只读取元素的算法。但是，很多这类算法都要搜索序列。对于关联容器进行关键字进行查找才可以达到最好的效果，但算法并不能通过关联容器的关键字进行快速查找，因此对其使用泛型搜索算法几乎是个坏主意。
>
> 实际编程中，如果我们真要对一个关联容器使用算法，要么是将它当作一个源序列，要么当作一个目的位置。例如，可以用泛型`copy`算法将元素从一个关联容器拷贝到另一个序列。类似的，可以调用`inserter`将一个插入器绑定到一个关联容器。通过使用`inserter`，我们可以将关联容器当做一个目的位置来调用另一个算法。



### 2. 添加元素

| 操作                                       | 效果                                                         |
| ------------------------------------------ | ------------------------------------------------------------ |
| `c.insert(v)`<br />`c.emplace(args)`       | `v`是`value_type`类型的对象；`args`用来构造一个元素<br />对于`map`和`set`，只有当元素的关键字不在`c`中才插入（或构造）元素。<br />函数返回一个`pair`，包含一个迭代器，指向具有指定关键字的元素，以及一个指示是否插入成功的`bool`值<br />对于`multimap`和`multiset`，总会插入（或构造）给定元素，并返回一个指向新元素的迭代器 |
| `c.insert(b, e)`<br />`c.insert(il)`       | `b`和`e`是迭代器，表示一个`c::value_type`类型值的范围；<br />`il`是这种值的花括号列表。函数返回`void`<br />对于`map`和`set`，只插入关键字不在`c`中的元素；<br />对于`multimap`和`multiset`，则会插入范围中的每个元素 |
| `c.insert(p, v)`<br />`c.emplace(p, args)` | 类似`insert(v)`（或`emplace(args)`），<br />但将迭代器`p`作为一个提示，指出从哪里开始搜索新元素应该存储的位置<br />返回一个迭代器，指向具有给定关键字的 |

- 向非`multi`版本的关联容器插入关键字已存在的元素时对容器没有任何影响

- 对一个`map`进行`insert`操作时，必须记住元素类型是`pair`。对于想要插入的数据，如果没有一个现成的`pair`对象，可以在`insert`的参数列表中创建一个`pair`：

  ```cpp
  word_count.insert({word, 1});
  word_count.insert(make_pair(word, 1));
  word_count.insert(pair<string, size_t>(word, 1));
  word_count.insert(map<string, size_t>::value_type(word, 1));
  ```

- `insert`（或`emplace`）返回的值依赖于容器类型和参数。对于不包含重复关键字的容器，添加单一元素的`insert`和`emplace`版本返回一个`pair`，告诉我们插入是否成功，其`first`成员是一个迭代器，指向具有给定关键字的元素，`second`成员是一个`bool`值，指出元素是否插入成功还是已经存在于容器中。如果关键字已在容器中，则`insert`什么事情也不做，且返回值中的`bool`部分为`false`。如果关键字不存在，元素被插入容器中，且`bool`值为`true`。



### 3. 删除元素

| 操作            | 效果                                                         |
| --------------- | ------------------------------------------------------------ |
| `c.erase(k)`    | 从`c`中删除每个关键字为`k`的元素。<br />返回一个`size_type`值，指出删除的元素的数量 |
| `c.erase(p)`    | 从`c`中删除迭代器`p`指定的元素。<br />`p`必须指向`c`中一个真实元素，不能等于`c.end()`。<br />返回一个指向`p`之后元素的迭代器，若`p`指向`c`中的尾元素，则返回`c.end()` |
| `c.erase(b, e)` | 删除迭代器对`b`和`e`所表示范围内的元素。返回`e`              |



### 4. 下标操作（只适用于`map`及其延伸类型）

**注**：下表操作值适用于非`const`的`map`和`unordered_map`

| 操作      | 效果                                                         |
| --------- | ------------------------------------------------------------ |
| `c[k]`    | 返回关键字为`k`的元素；<br />如果`k`不在`c`中，添加一个关键字为`k`的元素，对其进行值初始化 |
| `c.at(k)` | 访问关键字为`k`的元素，带参数检查；<br />若`k`不在`c`中，抛出一个`out_of_range`异常 |

- 对`map`系列类型使用下标操作，需要的下标值是关键字类型的值，下标行为是查找关键字对应的值
- 关联容器的下标操作和数组或`vector`等容器的下标操作行为不同，使用一个不在容器中的关键字作为下标，会添加一个具有此关键字的元素到`map`中
- 对于通常的下标操作，其返回类型和解引用一个迭代器所返回的类型是一样的。但对于`map`而言，解引用迭代器会得到一个`value_type`对象，而下标操作返回的是一个`mapped_type`对象。但与其他下标运算符相同的是，返回的是一个左值。



### 5. 访问元素

| 操作                                   | 效果                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| `c.find(k)`                            | 返回一个迭代器，指向第一个关键字为`k`的元素，若`k`不在容器中，则返回尾后迭代器 |
| `c.count(k)`                           | 返回关键字等于`k`的元素的数量。对于不允许重复关键字的容器，返回值永远是 0 或 1 |
| `c.lower_bound(k)`（不适用于无序容器） | 返回一个迭代器，指向第一个关键字不小于`k`的元素              |
| `c.upper_bound(k)`（不适用于无序容器） | 返回一个迭代器，指向第一个关键字大于`k`的元素                |
| `c.equal_range(k)`                     | 返回一个迭代器`pair`，表示关键字等于`k`的元素的范围。<br />若`k`不存在，`pair`的两个成员均为`c.end()` |

- `map`的下标操作会自动插入关键字不在容器中的元素，这个特性在某些地方非常方便，但有时候我们可能并不需要。此时可以使用`find`成员函数来代替下标操作



### 6. 赋值与 swap

| 操作                  | 效果                             |
| --------------------- | -------------------------------- |
| `c1 = c2`             | 将`c1`中的元素替换为`c2`的元素   |
| `c1 = {a, b, c, ...}` | 将`c1`中的元素替换为列表中的元素 |
| `a.swap(b)`           | 交换`a`和`b`的元素               |
| `swap(a, b)`          | 与`a.swap(b)`等价                |



### 7. 大小

| 操作           | 效果                                           |
| -------------- | ---------------------------------------------- |
| `c.size()`     | `c`中元素的数目                                |
| `c.max_size()` | `c`可保存的最大元素数目                        |
| `c.empty()`    | 若`c`中存储了元素，返回`false`，否则返回`true` |



### 8.关系运算符

| 操作                 | 效果                             |
| -------------------- | -------------------------------- |
| `==`、`!=`           | 相等性判断                       |
| `<`、`<=`、`>`、`>=` | 关系运算符（无序关联容器不支持） |

