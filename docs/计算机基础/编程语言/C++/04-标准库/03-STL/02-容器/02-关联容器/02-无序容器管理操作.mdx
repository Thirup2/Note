## 一、无序容器与桶

在关键字类型的元素没有明显的序关系的情况下，以及某些应用中，维护元素的序的代价非常高昂，无序容器就显得非常有用。

和前面说的一样，无序容器使用哈希函数来建立关键字与元素具体位置的联系，从而达到常数级的访问速度。

但实际上，哈希函数几乎无法避免的问题就是可能会有不同关键字进行哈希函数之后得到相同值的问题。面对这样的问题，有多种解决方案，无序容器采用的是**桶**的解决方案。

简单来说，当多个关键字通过哈希函数计算出来的值相同的时候，就将这些元素保存到一个桶中，所以无序容器在存储上就组织为一组桶，每个桶保存零个或多个元素。

理想情况下，哈希函数还能将每个特定的值映射到唯一的桶。但当一个桶保存多个元素时，需要顺序搜索这些元素来查找我们想要的那个。计算一个元素的哈希值和在同种搜索通常都是很快的操作，但是如果一个桶中保存了很多元素，那么查找一个特定元素就需要大量比较操作。

所以无序容器提供了一组管理桶的函数，这些成员函数顺序我们查询容器的状态以及在必要时强制容器进行重组。



## 二、管理操作

### 1. 桶接口

| 操作                   | 效果                        |
| ---------------------- | --------------------------- |
| `c.bucket_count()`     | 正在使用的桶的数目          |
| `c.max_bucket_count()` | 容器能容纳的最多的桶的数量  |
| `c.bucket_size(n)`     | 第`n`个桶中有多少个元素     |
| `c.bucket(k)`          | 关键字为`k`的元素在哪个桶中 |



### 2. 桶迭代

**类型**：

| 类型                   | 含义                             |
| ---------------------- | -------------------------------- |
| `local_iterator`       | 可以用来访问桶中元素的迭代器版本 |
| `const_local_iterator` | 桶迭代器的`const`版本            |

**操作**：

| 操作                       | 效果                            |
| -------------------------- | ------------------------------- |
| `c.begin(n)`、`c.end(n)`   | 桶`n`的首元素迭代器和尾后迭代器 |
| `c.cbegin(n)`、`c.cend(n)` | 返回`const_local_iterator`      |



### 3. 哈希策略

| 操作                  | 效果                                                         |
| --------------------- | ------------------------------------------------------------ |
| `c.load_factor()`     | 每个桶的平均数量，返回`float`值                              |
| `c.max_load_factor()` | `c`试图维护的平均桶大小，返回`float`值。<br />`c`会在需要时添加新的桶，以使得`load_factor <= max_load_factor` |
| `c.rehash(n)`         | 重组存储，使得`bucket_count >= n`<br />且`bucket_count > size/max_load_factor` |
| `c.reserve(n)`        | 重组存储，使得`c`可以保存`n`个元素且不必`rehash`             |



## 三、注意

默认情况下，无序容器使用关键字类型的`==`运算符来比较元素，它们还使用一个`hash<key_type>`类型的对象来生成每个元素的哈希值。

标准库为内置类型提供了`hash`模板，还为一些标准库类型定义了`hash`。

但如果是自定义类类型，我们不能直接定义关键字类型为该类型的无序容器。与容器不同，不能直接使用哈希模板，而必须提供我们自己的`hash`模板版本。

和有序关联容器的比较运算符重载一样，无序关联容器也可以函数来替代`==`运算符和哈希值计算函数，同时无序关联容器并不需要重载比较运算符，因为它不需要按严格弱序进行排列。

**定义用于替代的函数**：

```cpp
size_t hasher(const Sales_data &sd)
{
    return hash<string>() (sd.isbn());
}
bool eqOp(const Sales_data &lhs, const Sales_data &rhs)
{
    return lhs.isbn() == rhs.isbn();
}
```

**无序容器实例化**：

还是一样，将哈希函数类型和相等性判断函数类型作为参数提供在实例化参数最后，哈希放在相等性判断之前：

```cpp
using SD_multiset = unordered_multiset<Sales_data, decltype(hasher)*, decltype(eqOq)*>;
```

同样，我们还是使用`decltype`来获取类型。

**创建无序容器对象**：

创建时必须提供自定义的哈希函数和相等性判断函数，位置放在构造函数所有参数最后，哈希在相等性判断之前：

```cpp
SD_multiset bookstore(42, hasher, eqOp);
```

> 如果我们的类定义了`==`运算符，则可以只重载哈希函数