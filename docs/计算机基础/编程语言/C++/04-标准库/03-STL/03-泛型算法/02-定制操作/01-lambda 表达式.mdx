## 一、定义 lambda

一个 lambda 表达式表示一个可调用的代码单元。我们可以将其理解为一个未命名的内联函数。与任何函数类似，一个 lambda 具有一个返回类型、一个参数列表和一个函数体，以及还有一个捕获列表。但与函数不同的是，lambda 可能定义在函数内部。

### 1. 基本使用

一个 lambda 表达式具有如下形式：

```cpp
[capture list] (parameter list) -> return type { /* function body */ };
```

- `capture list`是一个 lambda 所在函数中定义的局部变量的列表（通常为空）
- `return type`、`parameter list`和`function body`与任何普通函数一样，分别表示返回类型、参数列表和函数体。但是和普通函数不同，lambda 必须使用尾置返回来指定返回类型
- 我们可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体。如果忽略参数列表等价于指定了一个空参数列表；如果忽略返回类型，且函数体只包含`return`语句，则根据`return`的返回值判断返回类型，否则返回`void`类型。

所以，如果忽略参数列表和返回类型，可以像下面这样进行调用：

```cpp
[capture list] {/* function body */};
```

另外，一个 lambda 表达式是一个默认仿函数类型的对象，所以可以作为初始值赋给一个变量：

```cpp
auto f = [] { return 42; }
```

这个`auto`实际上也可以推断出来，因为 lambda 表达式的返回类型是`int`，并且不接受任何参数，所以`f`实际上是`int()`类型的函数。

这个`f`可以进行调用：

```cpp
cout << f() << endl;
```

### 2. lambda 参数

与一个普通函数调用类似，调用一个 lambda 时给定的实参被用来初始化 lambda 的形参。通常，实参和形参的类型必须匹配或能够转换。

与普通函数不同的是，lambda 不能有默认实参。因此，一个 lambda 调用的实参数目永远与形参数目想等。一旦形参初始化完毕，就可以执行函数体了。

例如，一个判断字符串`a < b`并返回`bool`值的 lambda 表达式：

```cpp
auto isShorter = [] (const string &a, const string &b)
					{ return a.size() < b.size(); }
```

这个 lambda 表达式等价于下面这个函数：

```cpp
bool isShorter(const string &a, const string &b)
{
    return a.size() < b.size();
}
```



### 3. 捕获列表

如果不使用捕获列表，那么一个 lambda 表达式和与之等价的函数没有任何区别。

lambda 的捕获列表在一对`[]`中。捕获列表中包含的是一个以逗号分隔的名字列表，这些名字都是它所在函数中定义的。在 lambda 捕获列表中的名字可以在 lambda 的函数体中使用，并且其值和所捕获的局部变量的值相同。

例如：

```cpp
int sz = 42;
auto f = [sz](const string &a)
			{ return a.size() >= sz; }
```

此时调用`f`，它就可以判断字符串`a`的尺寸是否大于`42`，并返回一个`bool`值了。调用者仍然只需要提供 1 个参数，但却实现了传入两个参数的效果。



## 二、lambda 捕获和返回

lambda 之所以可以捕获额外的数据，是因为编译器会生成一个与 lambda 对应的新的（未命名的）类类型。

当向一个函数传递一个 lambda 时，同时定义了一个新类型和该类型的一个对象：传递的参数就是此编译器生成的类类型的未命名对象。类似的，当使用`auto`定义一个用 lambda 初始化的变量时，定义了一个从 lambda 生成的类型的对象。

默认情况下，从 lambda 生成的类都包含一个对应 lambda 所捕获的变量的数据成员。并重载了`operator()`运算符。

### 1. 值捕获

类似参数传递，变量的捕获方式也可以是值或引用。

与传值参数类似，采用值捕获的前提是变量可以拷贝。与参数不同，被捕获的变量的值是在 lambda 创建时拷贝，而不是调用时拷贝：

```cpp
void fcn1()
{
    size_t v1 = 42;
    auto f = [v1] { return v1; }
    v1 = 0;
    auto j = f();
}
```

上例中的`j`仍然将被赋值为`42`而不是`0`，就是因为这个原因。



### 2. 引用捕获

我们定义 lambda 时可以采用引用方式捕获变量，例如：

```cpp
void fcn2()
{
    size_t v1 = 42;
    auto f2 = [&v1] { return v1; }
    v1 = 0;
    auto j = f2();
}
```

具体的方式就是在被捕获的变量名前添加`&`符号，一个以引用方式捕获的变量与其他任何类型的引用的行为类似。所以上例中的`j`将被初始化为 0.

**问题和限制**：

引用捕获和返回引用有着相同的问题和限制。如果我们采用引用方式捕获一个变量，就必须确保被引用的对象在 lambda 执行的时候是存在的。lambda 捕获的都是局部变量，这些变量在函数结束之后就不复存在了。如果 lambda 可能在函数结束后执行，捕获的引用指向的局部变量已经消失。

我们也可以从一个函数返回 lambda，函数可以直接返回一个可调用对象，或者返回一个类对象，该类含有可调用对象的数据成员。如果函数返回一个 lambda，则与函数不能返回一个局部变量的引用类似，此 lambda 也不能包含引用捕获。



### 3. 隐式捕获

除了显式列出我们希望使用的来自所在函数的变量之外，还可以让编译器根据 lambda 体中的代码来推断我们要使用哪些变量。

为了指示编译器推断捕获列表，应该在捕获列表中写一个`&`或`=`，`&`告诉编译器采用引用捕获的方式，`=`则表示采用值捕获方式。

例如：

```cpp
auto wc = find_if(words.begin(),
                  words.end(),
                  [=](const string &s)
                  	{ return s.size() >= sz; });
```

将自动值捕获`sz`。

如果我们希望对一部分变量采用值捕获，对其他变量采用引用捕获，可以混合使用隐式捕获和显式捕获：

```cpp
void biggies(vector<string> &words, vector<string>::size_type sz, ostream &os = cout, char c = ' ')
{
    for_each(words.begin(),
            words.end(),
            [&, c](const string &s)
             	{ os << s << c; });		// c 显式值捕获，其余隐式捕获采用引用捕获
    for_each(words.begin(),
            words.end(),
            [=, &os](const string &s)
             	{ os << s << c; });		// os 显式引用捕获，其余隐式捕获采用值捕获
}
```

显示捕获的方式不能和隐式捕获的方式相同。

具体的捕获列表形式如下表所示：

| 捕获列表               | 效果                                                         |
| ---------------------- | ------------------------------------------------------------ |
| `[]`                   | 空捕获列表。                                                 |
| `[names]`              | `names`是一个逗号分隔的名字列表，这些名字都是 lambda 所在函数的局部变量。<br />默认情况下，捕获列表中的名字都被拷贝；名字前如果使用了`&`，则采用引用捕获方式 |
| `[&]`                  | 隐式捕获列表，采用引用捕获方式                               |
| `[=]`                  | 隐式捕获列表，采用值捕获方式                                 |
| `[&, identifier_list]` | `identifier_list`是一个逗号分隔的列表，包含 0 个或多个来自所在函数的变量。<br />显式捕获的变量只能采用值捕获，其余变量采用引用捕获方式 |
| `[=, identifier_list]` | `identifier_list`是一个逗号分隔的列表，包含 0 个或多个来自所在函数的变量。<br />显式捕获的变量只能采用引用捕获（`&`不能丢），其余变量采用值捕获方式 |



### 4. 可变 lambda

默认情况下，对于一个值被拷贝的变量，lambda 不会改变其值。如果我们希望能改变一个被不活的变量的值，就必须在参数列表后加上关键字`mutable`。因此，可变 lambda 能省略参数列表但不能省略参数列表的`()`：

```cpp
void fcn3() 
{
    size_t v1 = 42;
    auto f = [v1] () mutable { return ++v1; };
    v1 = 0;
    auto j = f();
}
```

需要注意以下几点：

- 一个可变 lambda 表达式如果在一个调用点导致被捕获变量的值发生了改变，那么后续该 lambda 表达式的调用点将保持这个改变，继续下一次改变。
- 另外，如果被捕获变量本身是一个`const`类型，那么无论是否添加`mutable`，该变量都无法被改变，无论是值捕获还是引用捕获；
- 如果不添加`mutable`，即使被捕获变量不是`const`的，只要是值捕获方式，则都无法改变；
- 值捕获和引用捕获都可以添加`mutable`，引用捕获即使不添加`mutable`也可以改变被捕获变量的值，但它们的逻辑并不相同。`mutable`的值捕获如果修改，是修改的原本的变量的一个拷贝，而引用捕获如果修改，则是修改的原本的变量。



### 5. 指定 lambda 返回类型

默认情况下，如果一个 lambda 体包含`return`之外的任何语句，则编译器假定此 lambda 返回`void`。与其他返回`void`的函数类似，被推断返回`void`的 lambda 不能返回值。

当我们需要为一个 lambda 定义返回类型时，必须使用尾置返回类型：

```cpp
transform(vi.begin(), vi.end(), vi.begin(),
         [](int i) -> int
          	{
                if(i < 0)
                    return -i;
                else
                    return i;
            })
```