## 一、基本操作

`shared_ptr`是一个类模板，实例化时需要提供指针指向的类型作为实例化参数。

其基本操作如下表所示：

| 操作                                               | 效果                                                         |
| -------------------------------------------------- | ------------------------------------------------------------ |
| `shared_ptr<T> sp`                                 | 默认初始化。<br />空智能指针，可以指向类型为`T`的对象        |
| `shared_ptr<T> p(p2)`                              | `p`是`shared_ptr p2`的拷贝；此操作会递增`p2`中的计数器。`p2`中的指针必须能转换成`T*` |
| `shared_ptr<T> p(q)`                               | `p`管理内置指针`q`所指向的对象；`q`必须指向`new`分配的内存，且能够转换为`T*`类型 |
| `shared_ptr<T> p(u)`                               | `p`从`unique_ptr u`那里接管了对象的所有权，将`u`置为空       |
| `shared_ptr<T> p(q, d)`                            | `p`接管了内置指针`q`所指向的对象的所有权。`q`必须能转换为`T*`类型。`p`将使用可调用对象`d`来代替`delete` |
| `shared_ptr<T> p(p2, d)`                           | 和`shared_ptr<T> p(p2)`一样，唯一的区别是`p`将用可调用对象`d`来代替`delete` |
| `make_shared<T>(args)`                             | 返回一个`shared_ptr`，指向一个动态分配的类型为`T`的对象。使用`args`初始化此对象 |
| `*p`                                               | 解引用`p`，获得它指向的对象                                  |
| `p->mem`                                           | 等价于`(*p).mem`                                             |
| `p.get()`                                          | 返回`p`中保存的指针。<br />需要注意：若智能指针释放了其对象，返回的指针所指向的对象也就消失了 |
| `swap(p, q)`<br />`p.swap(q)`                      | 交换`p`和`q`中的指针                                         |
| `p = q`                                            | `p`和`q`都是`shared_ptr`，所保存的指针必须能够相互转换。<br />此操作会递减`p`的引用计数，递增`q`的引用计数；若`p`的引用计数变为 0，则将其管理的原内存释放 |
| `p.unique()`                                       | 若`p.use_count()`为 1，返回`true`；否则返回`false`           |
| `p.use_count()`                                    | 返回与`p`共享对象的智能指针数量；可能很慢，主要用于调试      |
| `p.reset()`<br />`p.reset(q)`<br />`p.reset(q, d)` | 若`p`是唯一指向其对象的`shared_ptr`，`reset`会释放此对象；<br />若传递了可选的参数内置指针`q`，会令`p`指向`q`，否则会将`p`置为空；<br />若还传递了参数`d`，将会调用`d`而不是`delete`来释放`q` |



## 二、shared_ptr 模型

要理解`shared_ptr`为何是“智能”指针，首先我们需要理解其内部构造和操作原理。

本小节将简述其内部构造和基本的构造函数、拷贝操作的原理。

### 1. 构造 shared_ptr

当我们使用默认初始化一个`shared_ptr`时，一个`shared_ptr`对象的结构如下图所示：

![01](/imgs/C++/01.jpg)

可以看到一个`shared_str`对象仅仅包含两个指针，分别是指向控制块的指针和指向资源的指针。只不过这个指向控制块的指针会立刻分配内存，其中弱引用计数会立即+1，而由于默认初始化没有资源对象，控制块中的资源指针和`shared_str`的资源指针都指向`nullptr`，所以引用计数仍然是 0。

:::info 弱引用计数和引用计数

从上图中可以看到，我们使用动态内存分配的对象有两部分，一个是控制块，另一个是实际的资源。

这两部分都通过计数器来决定其生存时间，当引用计数为 0 时，将自动释放资源的动态内存，而当弱引用计数为 0 时，将自动释放控制块的动态内存。

所以，实际上引用计数用来管理实际的资源，而弱引用计数用来管理控制块，一个`weak_ptr`只会增加一个控制块中的弱引用计数，而一个`shared_ptr`不仅会增加一个弱引用计数，也会根据实际情况增加引用计数。

:::



### 2. 赋值或给定初始值的构造

对一个空的智能指针赋值，我们首先需要手动分配一块动态内存，然后交给智能指针管理：

```cpp
shared_ptr<int> sp(new int(4));
```

这样的操作会导致原本的`shared_ptr`对象结构变化如下：

![02](/imgs/C++/02.jpg)

首先创建一个`int`对象的内存并初始化它，然后`shared_ptr`指向的控制块中的资源指针和其本身的资源指针都将指向这块内存，然后引用计数会+1.



### 3. 拷贝

当我们将一个`shared_ptr`拷贝给另一个对象时，并不会创建另一个控制块和另一个资源，而是会让它们指向同一块控制块和资源：

```cpp
shared_ptr<int> sp(new int(4));
shared_ptr<int> sp_copy(sp);
```

上述代码使此时的智能指针结构如下图所示：

![03](/imgs/C++/03.jpg)

具体分为三步：

- 第1步：系统创建一个`shared_ptr`对象，注意`shared_ptr`对象本身并不需要动态分配内存，所以这一步是系统做的
- 第2步：使拷贝对象中的控制块指针和资源指针都指向被拷贝对象中两个指针所指的相同的位置
- 第3步：递增引用计数和弱引用计数



### 4. 析构

智能指针可能是一个局部变量，当它离开其作用域时，会自动销毁这个智能指针，即调用该类型的析构函数。对于`shared_ptr`类型，这个析构函数执行如下操作：

1. 首先递减引用计数和弱引用计数
2. 当引用计数递减为 0 时，资源内存将被自动释放；
3. 当弱引用计数递减为 0 时，控制块内存将被自动释放

为了将这三个操作的效果都体现出来，我们再往其中添加一个`weak_ptr`：

```cpp
weak_ptr<int> sp_weak(sp);
```

这样，现在的结构就如下图所示了：

![04](/imgs/C++/04.jpg)

接下来将三个对象逐步进行析构：

**当 sp_copy 被销毁时**：

引用计数、弱引用计数递减 1 且递减后都不为零，控制块和资源无变化：

![05](/imgs/C++/05.jpg)

**当 sp 被销毁时**：

引用计数、弱引用计数递减 1，递减后引用计数为 0 故资源被释放，但弱引用计数还不为 0，控制块仍然保留：

![06](/imgs/C++/06.jpg)

**当 sp_weak 被销毁时**：

弱引用计数递减 1，递减后弱引用计数为 0，故自动释放控制块，随后释放`sp_weak`对象



### 5. make_shared 的不同

使用`new`分配的内存做初始值和使用`make_shared`创建的内存做初始值是有所不同的，前者我们在之前已经看到过了，这里我们来看一下`make_shared`具体有什么不同。

**示例代码**：

```cpp
shared_ptr<int> sp = make_shared<int>(42);
```

**内部结构**：

![07](/imgs/C++/07.jpg)

**不同点**：

- 原本的控制块对象和资源对象是两块分离的内存，但`make_shared`分配的这两部分对象在同一块连续内存中
- 控制块对象中不在存在指向资源对象的指针
- 由于上面的不同，所以仅仅当引用计数递减到 0 时并不会导致资源对象被释放，只有当弱引用计数也递减到 0 时，控制块内存被释放，其中的资源对象才随之释放



## 三、操作解析

### 1. make_shared

`make_shared`是一个函数模板，定义方式与模板类相同，在函数名之后跟一个尖括号，在其中给出类型：

```cpp
shared_ptr<int> p = make_shared<int>(42);
```

`make_shared`用其参数来构造给定类型的对象，所以函数中的参数和函数实例化的类型必须相容，例如`42`与`int`相容；另外实例化参数必须和被初始化的对象指向的类型相同，例如`make_shared<int>`中的`int`和`shared_ptr<int> p`中的`int`相同（相容）。

如果我们不向`make_shared<T>`函数传递任何参数，对象就会进行值初始化。



### 2. 拷贝和赋值

当对一个新的`shared_ptr`对象进行拷贝初始化时，这个对象会和被拷贝对象指向同一个控制块内存和同一个资源内存，这样的初始化效果仅仅是控制块的引用计数和弱引用计数会递增。

但如果对一个`shared_ptr`对象进行赋值操作，情况就不同了，因为被赋值对象并不是一个新的`shared_ptr`对象，它已经指向了一个存在的控制块内存和资源内存。所以对一个`shared_ptr`对象进行赋值操作，将首先把它原来指向的控制块内存中的引用计数和弱引用计数都递减 1，并判断是否需要释放内存，然后再将这个`shared_ptr`对象进行和拷贝操作一样的操作。



### 3. 初始化

- 初始化一个`shared_ptr<T>`的对象，可以使用`make_shared<T>`函数创建的对象作为初始值，这种初始化方式对应的构造函数是非`explicit`的，所以也可以用其拷贝形式

- 也可以用另一个`shared_ptr<T>`的对象作为初始值，同样直接初始化和拷贝初始化的形式都可以

- 除了以上两种初始值，还可以提供一个内置指针作为初始值，需要注意的是该构造函数是`explicit`的，所以不能使用拷贝形式，只能进行直接初始化。提供一个内置指针作为初始值，可以直接使用`new`表达式，也可以提供一个指向动态内存的指针：

  ```cpp
  shared_ptr<int> p1(new int(1024));	// 正确
  // highlight-start
  int *p = new int(128);
  shared_ptr<int> p2(p);				// 可以但不建议
  // highlight-end
  // error-start
  shared_ptr<int> p4 = new int(3);	// 错误：无拷贝形式
  shared_ptr<int> p5 = p;				// 错误：无拷贝形式
  // error-end
  ```

  对于先定义一个指向动态内存的内置指针，然后用该指针作为`shared_ptr`的初始值的行为并不建议，因为这个内置指针并不受`shared_ptr`控制，会导致很多问题，详情见[动态内存-使用注意](../../#mention)
  
- 重置
