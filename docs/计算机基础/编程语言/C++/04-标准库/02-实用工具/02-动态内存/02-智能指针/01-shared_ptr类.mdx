## 一、基本操作

`shared_ptr`是一个类模板，实例化时需要提供指针指向的类型作为实例化参数。

其基本操作如下表所示：

| 操作                          | 效果                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| `shared_ptr<T> sp`            | 默认初始化。<br />空智能指针，可以指向类型为`T`的对象        |
| `shared_ptr<T> p(q)`          | `p`是`shared_ptr q`的拷贝；此操作会递增`q`中的计数器。`q`中的指针必须能转换成`T*` |
| `make_shared<T>(args)`        | 返回一个`shared_ptr`，指向一个动态分配的类型为`T`的对象。使用`args`初始化此对象 |
| `*p`                          | 解引用`p`，获得它指向的对象                                  |
| `p->mem`                      | 等价于`(*p).mem`                                             |
| `p.get()`                     | 返回`p`中保存的指针。<br />需要注意：若智能指针释放了其对象，返回的指针所指向的对象也就消失了 |
| `swap(p, q)`<br />`p.swap(q)` | 交换`p`和`q`中的指针                                         |
| `p = q`                       | `p`和`q`都是`shared_ptr`，所保存的指针必须能够相互转换。<br />此操作会递减`p`的引用计数，递增`q`的引用计数；若`p`的引用计数变为 0，则将其管理的原内存释放 |
| `p.unique()`                  | 若`p.use_count()`为 1，返回`true`；否则返回`false`           |
| `p.use_count()`               | 返回与`p`共享对象的智能指针数量；可能很慢，主要用于调试      |



## 二、shared_ptr 模型

要理解`shared_ptr`为何是“智能”指针，首先我们需要理解其内部构造和操作原理。

本小节将简述其内部构造和基本的构造函数、拷贝操作的原理。

### 1. 构造 shared_ptr

当我们使用默认初始化一个`shared_ptr`时，一个`shared_ptr`对象的结构如下图所示：

![01](/imgs/C++/01.jpg)

可以看到一个`shared_str`对象仅仅包含两个指针，分别是指向控制块的指针和指向资源的指针。只不过这个指向控制块的指针会立刻分配内存，其中弱引用计数会立即+1，而由于默认初始化没有资源对象，控制块中的资源指针和`shared_str`的资源指针都指向`nullptr`，所以引用计数仍然是 0。

:::info 弱引用计数和引用计数

从上图中可以看到，我们使用动态内存分配的对象有两部分，一个是控制块，另一个是实际的资源。

这两部分都通过计数器来决定其生存时间，当引用计数为 0 时，将自动释放资源的动态内存，而当弱引用计数为 0 时，将自动释放控制块的动态内存。

所以，实际上引用计数用来管理实际的资源，而弱引用计数用来管理控制块，一个`weak_ptr`只会增加一个控制块中的弱引用计数，而一个`shared_ptr`不仅会增加一个弱引用计数，也会根据实际情况增加引用计数。

:::



### 2. 赋值或给定初始值的构造

对一个空的智能指针赋值，我们首先需要手动分配一块动态内存，然后交给智能指针管理：

```cpp
shared_ptr<int> sp(new int(4));
```

这样的操作会导致原本的`shared_ptr`对象结构变化如下：

![02](/imgs/C++/02.jpg)

首先创建一个`int`对象的内存并初始化它，然后`shared_ptr`指向的控制块中的资源指针和其本身的资源指针都将指向这块内存，然后引用计数会+1.



### 3. 拷贝

当我们将一个`shared_ptr`拷贝给另一个对象时，并不会创建另一个控制块和另一个资源，而是会让它们指向同一块控制块和资源：

```cpp
shared_ptr<int> sp(new int(4));
shared_ptr<int> sp_copy(sp);
```

上述代码使此时的智能指针结构如下图所示：

![03](/imgs/C++/03.jpg)

具体分为三步：

- 第1步：系统创建一个`shared_ptr`对象，注意`shared_ptr`对象本身并不需要动态分配内存，所以这一步是系统做的
- 第2步：使拷贝对象中的控制块指针和资源指针都指向被拷贝对象中两个指针所指的相同的位置
- 第3步：递增引用计数和弱引用计数



### 4. 析构

智能指针可能是一个局部变量，当它离开其作用域时，会自动销毁这个智能指针，即调用该类型的析构函数。对于`shared_ptr`类型，这个析构函数执行如下操作：

1. 首先递减引用计数和弱引用计数
2. 当引用计数递减为 0 时，资源内存将被自动释放；
3. 当弱引用计数递减为 0 时，控制块内存将被自动释放

为了将这三个操作的效果都体现出来，我们再往其中添加一个`weak_ptr`：

```cpp
weak_ptr<int> sp_weak(sp);
```

这样，现在的结构就如下图所示了：

![04](/imgs/C++/04.jpg)

接下来将三个对象逐步进行析构：

**当 sp_copy 被销毁时**：

引用计数、弱引用计数递减 1 且递减后都不为零，控制块和资源无变化：

![05](/imgs/C++/05.jpg)

**当 sp 被销毁时**：

引用计数、弱引用计数递减 1，递减后引用计数为 0 故资源被释放，但弱引用计数还不为 0，控制块仍然保留：

![06](/imgs/C++/06.jpg)

**当 sp_weak 被销毁时**：

弱引用计数递减 1，递减后弱引用计数为 0，故自动释放控制块，随后释放`sp_weak`对象



### 5. make_shared 的不同

使用`new`分配的内存做初始值和使用`make_shared`创建的内存做初始值是有所不同的，前者我们在之前已经看到过了，这里我们来看一下`make_shared`具体有什么不同。

**示例代码**：

```cpp
shared_ptr<int> sp = make_shared<int>(42);
```

**内部结构**：

![07](/imgs/C++/07.jpg)

**不同点**：

- 原本的控制块对象和资源对象是两块分离的内存，但`make_shared`分配的这两部分对象在同一块连续内存中
- 控制块对象中不在存在指向资源对象的指针
- 由于上面的不同，所以仅仅当引用计数递减到 0 时并不会导致资源对象被释放，只有当弱引用计数也递减到 0 时，控制块内存被释放，其中的资源对象才随之释放



## 三、操作解析





## 四、使用注意