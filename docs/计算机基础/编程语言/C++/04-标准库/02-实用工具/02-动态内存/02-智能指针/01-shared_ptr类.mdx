## 一、基本操作

`shared_ptr`是一个类模板，实例化时需要提供指针指向的类型作为实例化参数。

其基本操作如下表所示：

| 操作                                               | 效果                                                         |
| -------------------------------------------------- | ------------------------------------------------------------ |
| `shared_ptr<T> sp`                                 | 默认初始化。<br />空智能指针，可以指向类型为`T`的对象        |
| `shared_ptr<T> p(p2)`                              | `p`是`shared_ptr p2`的拷贝；此操作会递增`p2`中的计数器。`p2`中的指针必须能转换成`T*` |
| `shared_ptr<T> p(q)`                               | `p`管理内置指针`q`所指向的对象；`q`必须指向`new`分配的内存，且能够转换为`T*`类型 |
| `shared_ptr<T> p(u)`                               | `p`从`unique_ptr u`那里接管了对象的所有权，将`u`置为空       |
| `shared_ptr<T> p(q, d)`                            | `p`接管了内置指针`q`所指向的对象的所有权。`q`必须能转换为`T*`类型。`p`将使用可调用对象`d`来代替`delete` |
| `shared_ptr<T> p(p2, d)`                           | 和`shared_ptr<T> p(p2)`一样，唯一的区别是`p`将用可调用对象`d`来代替`delete` |
| `make_shared<T>(args)`                             | 返回一个`shared_ptr`，指向一个动态分配的类型为`T`的对象。使用`args`初始化此对象 |
| `*p`                                               | 解引用`p`，获得它指向的对象                                  |
| `p->mem`                                           | 等价于`(*p).mem`                                             |
| `p.get()`                                          | 返回`p`中保存的指针。<br />需要注意：若智能指针释放了其对象，返回的指针所指向的对象也就消失了 |
| `swap(p, q)`<br />`p.swap(q)`                      | 交换`p`和`q`中的指针                                         |
| `p = q`                                            | `p`和`q`都是`shared_ptr`，所保存的指针必须能够相互转换。<br />此操作会递减`p`的引用计数，递增`q`的引用计数；若`p`的引用计数变为 0，则将其管理的原内存释放 |
| `p.unique()`                                       | 若`p.use_count()`为 1，返回`true`；否则返回`false`           |
| `p.use_count()`                                    | 返回与`p`共享对象的智能指针数量；可能很慢，主要用于调试      |
| `p.reset()`<br />`p.reset(q)`<br />`p.reset(q, d)` | 若`p`是唯一指向其对象的`shared_ptr`，`reset`会释放此对象；<br />若传递了可选的参数内置指针`q`，会令`p`指向`q`，否则会将`p`置为空；<br />若还传递了参数`d`，将会调用`d`而不是`delete`来释放`q` |



## 二、shared_ptr 模型

要理解`shared_ptr`为何是“智能”指针，首先我们需要理解其内部构造和操作原理。

本小节将简述其内部构造和基本的构造函数、拷贝操作的原理。

### 1. 构造 shared_ptr

当我们使用默认初始化一个`shared_ptr`时，一个`shared_ptr`对象的结构如下图所示：

![01](/imgs/C++/01.jpg)

可以看到一个`shared_str`对象仅仅包含两个指针，分别是指向控制块的指针和指向资源的指针。只不过这个指向控制块的指针会立刻分配内存，其中弱引用计数会立即+1，而由于默认初始化没有资源对象，控制块中的资源指针和`shared_str`的资源指针都指向`nullptr`，所以引用计数仍然是 0。

:::info 弱引用计数和引用计数

从上图中可以看到，我们使用动态内存分配的对象有两部分，一个是控制块，另一个是实际的资源。

这两部分都通过计数器来决定其生存时间，当引用计数为 0 时，将自动释放资源的动态内存，而当弱引用计数为 0 时，将自动释放控制块的动态内存。

所以，实际上引用计数用来管理实际的资源，而弱引用计数用来管理控制块，一个`weak_ptr`只会增加一个控制块中的弱引用计数，而一个`shared_ptr`不仅会增加一个弱引用计数，也会根据实际情况增加引用计数。

:::



### 2. 赋值或给定初始值的构造

对一个空的智能指针赋值，我们首先需要手动分配一块动态内存，然后交给智能指针管理：

```cpp
shared_ptr<int> sp(new int(4));
```

这样的操作会导致原本的`shared_ptr`对象结构变化如下：

![02](/imgs/C++/02.jpg)

首先创建一个`int`对象的内存并初始化它，然后`shared_ptr`指向的控制块中的资源指针和其本身的资源指针都将指向这块内存，然后引用计数会+1.



### 3. 拷贝

当我们将一个`shared_ptr`拷贝给另一个对象时，并不会创建另一个控制块和另一个资源，而是会让它们指向同一块控制块和资源：

```cpp
shared_ptr<int> sp(new int(4));
shared_ptr<int> sp_copy(sp);
```

上述代码使此时的智能指针结构如下图所示：

![03](/imgs/C++/03.jpg)

具体分为三步：

- 第1步：系统创建一个`shared_ptr`对象，注意`shared_ptr`对象本身并不需要动态分配内存，所以这一步是系统做的
- 第2步：使拷贝对象中的控制块指针和资源指针都指向被拷贝对象中两个指针所指的相同的位置
- 第3步：递增引用计数和弱引用计数



### 4. 析构

智能指针可能是一个局部变量，当它离开其作用域时，会自动销毁这个智能指针，即调用该类型的析构函数。对于`shared_ptr`类型，这个析构函数执行如下操作：

1. 首先递减引用计数和弱引用计数
2. 当引用计数递减为 0 时，资源内存将被自动释放；
3. 当弱引用计数递减为 0 时，控制块内存将被自动释放

为了将这三个操作的效果都体现出来，我们再往其中添加一个`weak_ptr`：

```cpp
weak_ptr<int> sp_weak(sp);
```

这样，现在的结构就如下图所示了：

![04](/imgs/C++/04.jpg)

接下来将三个对象逐步进行析构：

**当 sp_copy 被销毁时**：

引用计数、弱引用计数递减 1 且递减后都不为零，控制块和资源无变化：

![05](/imgs/C++/05.jpg)

**当 sp 被销毁时**：

引用计数、弱引用计数递减 1，递减后引用计数为 0 故资源被释放，但弱引用计数还不为 0，控制块仍然保留：

![06](/imgs/C++/06.jpg)

**当 sp_weak 被销毁时**：

弱引用计数递减 1，递减后弱引用计数为 0，故自动释放控制块，随后释放`sp_weak`对象



### 5. make_shared 的不同

使用`new`分配的内存做初始值和使用`make_shared`创建的内存做初始值是有所不同的，前者我们在之前已经看到过了，这里我们来看一下`make_shared`具体有什么不同。

**示例代码**：

```cpp
shared_ptr<int> sp = make_shared<int>(42);
```

**内部结构**：

![07](/imgs/C++/07.jpg)

**不同点**：

- 原本的控制块对象和资源对象是两块分离的内存，但`make_shared`分配的这两部分对象在同一块连续内存中
- 控制块对象中不在存在指向资源对象的指针
- 由于上面的不同，所以仅仅当引用计数递减到 0 时并不会导致资源对象被释放，只有当弱引用计数也递减到 0 时，控制块内存被释放，其中的资源对象才随之释放



## 三、操作解析

### 1. make_shared

`make_shared`是一个函数模板，定义方式与模板类相同，在函数名之后跟一个尖括号，在其中给出类型：

```cpp
shared_ptr<int> p = make_shared<int>(42);
```

`make_shared`用其参数来构造给定类型的对象，所以函数中的参数和函数实例化的类型必须相容，例如`42`与`int`相容；另外实例化参数必须和被初始化的对象指向的类型相同，例如`make_shared<int>`中的`int`和`shared_ptr<int> p`中的`int`相同（相容）。

如果我们不向`make_shared<T>`函数传递任何参数，对象就会进行值初始化。



### 2. 拷贝和赋值

当对一个新的`shared_ptr`对象进行拷贝初始化时，这个对象会和被拷贝对象指向同一个控制块内存和同一个资源内存，这样的初始化效果仅仅是控制块的引用计数和弱引用计数会递增。

但如果对一个`shared_ptr`对象进行赋值操作，情况就不同了，因为被赋值对象并不是一个新的`shared_ptr`对象，它已经指向了一个存在的控制块内存和资源内存。所以对一个`shared_ptr`对象进行赋值操作，将首先把它原来指向的控制块内存中的引用计数和弱引用计数都递减 1，并判断是否需要释放内存，然后再将这个`shared_ptr`对象进行和拷贝操作一样的操作。



### 3. 初始化

- 初始化一个`shared_ptr<T>`的对象，可以使用`make_shared<T>`函数创建的对象作为初始值，这种初始化方式对应的构造函数是非`explicit`的，所以也可以用其拷贝形式

- 也可以用另一个`shared_ptr<T>`的对象作为初始值，同样直接初始化和拷贝初始化的形式都可以

- 除了以上两种初始值，还可以提供一个内置指针作为初始值，需要注意的是该构造函数是`explicit`的，所以不能使用拷贝形式，只能进行直接初始化。提供一个内置指针作为初始值，可以直接使用`new`表达式，也可以提供一个指向动态内存的指针：

  ```cpp
  shared_ptr<int> p1(new int(1024));	// 正确
  // highlight-start
  int *p = new int(128);
  shared_ptr<int> p2(p);				// 可以但不建议
  // highlight-end
  // error-start
  shared_ptr<int> p4 = new int(3);	// 错误：无拷贝形式
  shared_ptr<int> p5 = p;				// 错误：无拷贝形式
  // error-end
  ```

  对于先定义一个指向动态内存的内置指针，然后用该指针作为`shared_ptr`的初始值的行为并不建议，因为这个内置指针并不受`shared_ptr`控制，会导致很多问题，详情见[使用注意](#mention)



### 4. reset 操作

对一个`shared_ptr`对象调用`reset`操作可以更改调用者的指向，`reset(q)`其效果和赋值操作效果类似。

对于`reset()`，会将调用者的指向置为空，并按规定递减控制块的各计数值，当计数值为 0 时，按固定流程释放对应的内存；

对于`reset(q)`，则和`p = q`的操作是一样的，`p`和`q`都是`shared_ptr`对象；



### 5. 智能指针和异常

当程序抛出异常时，并且没有处理代码，从而在异常抛出点导致程序异常退出时，如果该点还有已分配的动态内存，如果该动态内存是使用内置指针进行管理的，那么这块内存无法得到回收，而如果使用的是智能指针进行管理，由于智能指针本身不是动态内存，所以它会被销毁，从而使动态内存得到释放。



### 6. 使用自定义的释放操作

包括 C++ 标准库类在内的很多 C++ 类都定义了析构函数，负责清理对象使用的资源，但是，不是所有的类都是这样良好定义的，特别是那些为 C 和 C++ 两种语言设计的类，通常都要求用户显式地释放所使用的任何资源。

我们可以使用`shared_ptr`来托管这样的类，从而使其可以自动地进行销毁和释放，但由于默认情况下，`shared_ptr`假定它们指向的是一个`new`分配的动态内存，因此，当一个`shared_ptr`被销毁时，它默认地对它管理的指针进行`delete`操作。为了用`shared_ptr`来管理这个类，我们必须首先定义一个函数来代替`delete`，这个**删除器**函数必须能够完成对`shared_ptr`中保存的指针进行释放的操作。

示例如下：

```cpp
struct connection;		// connection 类
struct destination;		// destination 类
connection connect(destination *);	// 根据一个 destination 指针返回一个 connection 对象
void end_connection(connection *p) { disconnection(*p); }	// connection 是一个类，end_connection 用来释放一个类对象
void f(destination &d /* 其他参数 */)
{
    connection c = connect(&d);						// 得到一个 conncetion 对象，需要手动关闭
    shared_ptr<connection> p(&c, end_connection);	// 使用 shared_ptr 托管该对象，须传入该 connectin 对象的指针和删除器函数
    // 使用 connection
    // 当程序退出时（可能是异常退出），connection c 都会被正确关闭
}
```

当我们添加了删除器函数之后，可传入作为初始值的指针就不是只能指向动态分配的内存了，或者说不是只能指向`new`分配的动态内存了。

其实`connection c`本身在函数退出时也会自动销毁，但之所以需要使用`shared_ptr`进行托管，是因为`connection`的成员中可能有动态分配的内存，同时`connection`又没有定义自己的析构函数，程序结束时只有`connection`本身被销毁，而其中分配的动态内存却无法被释放，所以我们至少需要一个释放函数来释放所有的动态内存。而之所以使用`shared_ptr`进行托管，是避免忘记手动调用释放函数导致内存泄漏。



## 四、使用注意 {#metion}

尽量不要混用内置指针和智能指针来管理动态内存，这会导致很多问题，需要注意：

- 如果混用内置指针和智能指针，`shared_ptr`会随着指针本身被销毁可能导致所有资源都被销毁，而内置指针并不被`shared_ptr`所管理，所以如果还有内置指针指向这块资源，将会在这样的情况下变成无效指针。

  这个问题看似还是可控的，只要注意也不会导致问题，但实际上可能会出现下面这样的情况：

  ```cpp
  void process(shared_ptr<int> ptr);
  
  int *x(new int(1024));
  // error-start
  process(x);						// 不能将一个内置指针作为初始值传递给 shared_ptr 对象做初始值
  process(shared_ptr<int>(x));	// 合法，但内存会被释放
  // error-end
  ```

  `process`只接受`shared_ptr`对象，所以我们不能传入内置指针做实参，但可以根据这个内置指针构造一个临时`shared_ptr`对象，从而成功调用`process`函数。但这个函数并不返回这个`shared_ptr`对象，我们传入的`shared_ptr`对象实参在函数处理结束之后就被销毁，从而导致其管理的资源被释放（因为只有这一个`shared_ptr`指向该资源），但主调程序中看似还指向这个资源的内置指针`x`还存在，但实际上它已经指向一块无效内存了。

- `shared_ptr`支持的`get`操作也不要作为另一个智能指针的初始值或拷贝值，这会导致一个问题：两个`shared_ptr`对象指向同一块资源内存，但却有两个独立的控制块内存，当其中一个`shared_ptr`被销毁时，其所指的资源也会被销毁，而另一个`shared_ptr`则会指向一个被销毁的资源，但其引用计数却不为 0.

- 使用`shared_ptr`中的`get`操作需要满足以下情况：我们需要向不能使用智能指针的代码传递一个内置指针，使用`get`返回的指针的代码不能`delete`此指针
