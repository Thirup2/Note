C++ 定义了两个运算符来分配和释放动态内存。运算符`new`分配内存，`delete`释放`new`分配的内存。

## 一、使用 new

在自由空间分配的内存是无名的，因此`new`无法为其分配的对象命名，而是返回一个指向该对象的指针：

```cpp
int *pi = new int;
```

### 1. 初始化

默认情况下，动态分配的对象是**默认初始化**的，类类型对象使用默认构造函数进行初始化。

或者使用**直接初始化**方式来初始化一个动态分配的对象，即圆括号或花括号的非拷贝形式：

```cpp
string *ps = new string;								// 默认初始化
int *pi = new int(1024);								// 圆括号直接初始化
vector<int> *pv = new vector<int>{0, 1, 2, 3, 4, 5};	// 列表直接初始化
```

也可以对动态分配的对象进行**值初始化**，只需在类型名后跟一对空括号即可：

```cpp
int *ps = new int();	// 值初始化为 0
```

对于提供了初始值的`new`语句，可以使用`auto`进行推断其类型，要求使用圆括号，但只能有一个初始值：

```cpp
auto p1 = new auto(obj);		// p1 指向一个与 obj 类型相同的对象，该对象用 obj 进行初始化
// error-next-line
auto p2 = new auto{a, b, c};	// 不能使用花括号，且括号内只能有单个初始值
```



### 2. 动态分配 const 对象

可以用`new`分配`const`对象：

```cpp
const int *pci = new const int(1024);
```

和其他`const`对象一样，一个动态分配的`const`对象必须进行初始化。对于一个定义了默认构造函数的类类型，其`const`动态对象可以隐式初始化，而其他类型的对象就必须显式初始化。

由于分配的对象是`const`的，`new`返回的指针是一个指向`const`的指针。



### 3. 分配失败

当自由空间被耗尽的情况下，`new`表达式会失败。默认情况下，如果`new`不能分配所要求的空间，它会抛出一个类型为`bad_alloc`的异常。

也可以向`new`传递一个`nothrow`的对象作为参数，从而阻止`new`抛出一个异常，这种情况下，如果分配失败，则会返回一个空指针：

```cpp
int *p2 = new (nothrow) int;
```



## 二、使用 delete

在动态内存使用完毕后，必须将其归还给系统，通过`delete`表达式来将动态内存归还给系统。

`delete`接受一个指针，这个指针必须指向动态分配的内存，或者是一个空指针。释放一块并非`new`分配的内存，或者将相同的指针值释放多次，其行为是未定义的。

```cpp
delete p;
```

与`new`类型类似，`delete`也执行两个动作：销毁给定的指针指向的对象；释放对应的内存。

动态对象的生存期直到被释放时为止，`new`分配的内存可以通过内置指针或`shared_ptr`来保存，如果使用内置指针，则必须记得释放内存。