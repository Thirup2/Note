## 一、简介

`new`有一些灵活性上的局限，其中一方面表现在它将内存分配和对象构造组合在了一起。类似的，`delete`将对象析构和内存释放组合在了一起。

对于单个对象而言，通常希望将内存分配和对象初始化组合在一起，因为在这种情况下，我们几乎肯定知道对象应该有什么值。

而当分配一大块内存时，我们通常计划在这块内存上按需构造对象，我们希望将内存分配和对象构造分离，意味着我们可以分配大块内存，但只在真正需要时才真正执行对象创建操作。

一般情况下，将内存分配和对象构造组合在一起可能会导致不必要的浪费，例如：

```cpp
string *const p = new string[n];		// 首次初始化
string s;
string *q = p;
while(cin >> s && q != p + n)			// 赋予元素真正需要的值
    *q++ = s;
const size_t size = q - p;
delete[] p;
```

这样，每个使用到的元素都被赋值了两次：第一次是在默认初始化时，随后是在赋值时。而第一次的初始化是完全没有必要的。

另外更重要的是，如果不能分离内存分配和对象构造，那些没有默认构造函数的类就不能动态分配数组了。



## 二、allocator 类

标准库`allocator`类定义在头文件`<memory>`中，它帮助我们将内存分配和对象构造分离开来。

`allocator`是一个类模板，实例化时须指定其分配的对象类型，其支持的操作如下表所示：

| 操作                   | 效果                                                         |
| ---------------------- | ------------------------------------------------------------ |
| `allocator<T> a`       | 定义了一个名为`a`的`allocator`对象，它可以为类型为`T`的对象分配内存 |
| `a.allocate(n)`        | 分配一段原始的、未构造的内存，返回一个`T*`类型的指针，保存`n`个类型为`T`的对象 |
| `a.deallocate(p, n)`   | 释放从`T*`指针`p`中地址开始的内存，这块内存保存了`n`个类型为`T`的对象；<br />`p`必须是一个先前由`allocate`返回的指针，且`n`必须是`p`创建时所要求的大小。<br />在调用`deallocate`之前，用户必须对每个在这块内存中创建的对象调用`destroy` |
| `a.construct(p, args)` | `p`必须是一个类型为`T*`的指针，指向一块原始内存；<br />`args`被传递给类型为`T`的构造函数，用来在`p`指向的内存中构造一个对象 |
| `a.destroy(p)`         | `p`为`T*`类型的指针，此算法对`p`指向的对象执行析构函数       |

注意：

- `allocate`操作分配的内存是未构造的，我们按需要在此内存中构造对象。
- 通过`construct`可以使用一块内存构造一个对象，不允许在未构造对象时就使用这块内存
- `deallocate`操作可以释放一整块内存，使用之前需保证该内存中构造的所有对象都已经使用`destroy`进行了销毁
- 我们只能对真正构造了的元素进行`destroy`操作，`destroy`操作之后，可构造新对象或进行`deallocate`



## 三、伴随算法

标准库还为`allocator`类定义了两个伴随算法，可以在未初始化内存中创建对象。它们都定义在头文件`<memory>`中，如下表所示：

| 操作                             | 效果                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| `uninitialized_copy(b, e, b2)`   | 从迭代器`b`和`e`指出的输入范围中拷贝元素到迭代器`b2`指定的未构造的原始内存中；<br />`b2`指向的内存必须足够大，能容纳输入序列中元素的拷贝<br />返回递增后的目的位置迭代器 |
| `uninitialized_copy_n(b, n, b2)` | 从迭代器`b`指向的元素开始，拷贝`n`个元素到`b2`开始的内存中<br />返回递增后的目的位置迭代器 |
| `uninitialized_fill(b, e, t)`    | 在迭代器`b`和`e`指定的元素内存范围中创建对象，对象的值均为`t`的拷贝 |
| `uninitialized_fill_n(b, n, t)`  | 从迭代器`b`指向的内存地址开始创建`n`个对象<br />`b`必须指向足够大的未构造的原始内存，能够容纳给定数量的对象 |

`allocator`类并没有配套的迭代器类型，使用以上算法时，涉及到原始内存的迭代器时，使用指向元素的指针代替。

以下是一个示例：

```cpp
allocator<string> alloc;						 // 创建分配器
vector<string> vi{/* 初始值 */};	  			  // 创建原数据
string *p = alloc.allocate(vi.size() * 2);		// 分配 string 数组原始内存
string *q = uninitialized_copy(
    vi.begin(), vi.end(), p);					// 根据原数据构造前半部分元素，并返回指向未构造的原始内存的首元素指针
uninitialized_fill_n(q, vi.size(), 42);			// 构造后半部分元素
```

