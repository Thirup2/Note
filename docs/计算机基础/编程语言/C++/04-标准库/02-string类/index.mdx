---
title: string类
description: C++ 标准库 -> string 类，本页为临时总结，暂未完成
keywords: [C++,标准库,string]
---

## 一、类成员类型

部分类成员类型如下：

- `value_type`：实例化字符类型
- `size_type`：标识字符串尺寸的类型
- `difference_type`：标识迭代器相减所得的差值的类型
- `reference`：实例化字符类型的引用类型
- `const_reference`：上述引用类型的常量版本
- `pointer`：实例化字符类型的指针类型
- `const_pointer`：上述指针类型的常量版本
- `iterator`：迭代器类型
- `const_iterator`：常量迭代器类型
- `reverse_iterator`：反向迭代器类型
- `const_reverse_iterator`：常量反向迭代器类型

:::info 注解

<Tabs>

<TabItem value="size_type" label="size_type">

`size_type`是用来标识字符串长度的类型，由于`size_type`是对一种具体类型的抽象，所以我们不知道其具体实现为了什么类型，但应该可以确定的是它应该是一个无符号类型，并且能足够存放下任何`string`对象的大小。

有些时候我们需要用到这个类型，比如获取成员函数`size()`返回的数值时，包括`[]`操作符内需要的数据也是该类型的值。

</TabItem>

<TabItem value="difference_type" label="difference_type">

此类型用来标识两个迭代器相减得到的数据的类型，在进行移动迭代器等操作时可以用到。

</TabItem>

<TabItem value="iterator" label="迭代器">

在`string`、`vector`等对象中使用迭代器的行为和在数组中使用指针的行为类似，我们需要抓住其中的不同点。

首先，数组是单纯的内置类型，没有什么类成员，其本身就是一个数据的集合，我们可以单纯地用指针去访问它以及其中的数据成员。

但是，`string`是一个类，它除了用来保存数据集合的成员之外，还有其他的一些成员。如果只是单纯的用指针去访问的话，那么有可能会干涉到其他的成员的值。甚至有可能`string`用来保存字符串的方法也不是使用类似于数组的连续内存，如果单纯使用指针，毫无疑问会出错。

而迭代器和指针的操作类似，但其却比指针的抽象程度更高，并且能够由类自定义其操作实现，毫无疑问比单纯使用指针更合适。

</TabItem>

</Tabs>

:::



## 二、初始化

初始化一个`string`对象的方式如下：

- `string s1`：默认初始化，`s1`是一个空串
- `string s2(s1)`：用另一个`string`对象直接初始化`s2`，`s2`是`s1`的副本
- `string s2 = s1`：用另一个`string`对象拷贝初始化，等价于`s2(s1)`
- `string s3("value")`：用 C 风格字符串直接初始化`s3`，`s3`是`"value"`的副本，除了字面值最后的那个空字符外
- `string s3 = "value"`：用 C 风格字符串拷贝初始化，等价于`s3("value")`
- `string s4(n, 'c')`：直接初始化（构造初始化）`s4`，把`s4`初始化为由连续`n`个字符`c`组成的串

其中最后一种初始化方式没有与之等价的拷贝初始化，但实际上也可以这样做，即显式地创建一个临时对象用于拷贝：

```cpp
string s5 = string(10, 'c');
```



## 三、操作

- `os << s`：将`s`写到输出流`os`当中，返回`os`
- `is >> s`：从输入流`is`中读取字符串赋给`s`，读取的字符串从第一个非空白字符开始到之后遇到的第一个空白字符结束（不包含空白字符）
- `getline(is, s)`：从`is`中读取一行赋给`s`，返回`is`
- `s.empty()`：`s`为空返回`true`，否则返回`false`
- `s.size()`：返回`s`中字符的个数
- `s[n]`：返回`s`中第`n`个字符的引用，位置`n`从 0 计起
- `s1 + s2`：返回`s1`和`s2`连接后的结果
- `s1 = s2`：用`s2`的副本代替`s1`中原来的字符
- `s1 == s2`/`s1 != s2`：如果`s1`和`s2`长度相等且相同位置字符相同，则两字符串相等；`string`对象的相等性判断对字母的大小写敏感
- `<`、`<=`、`>`、`>=`：利用字符在字典中的顺序进行比较，且对字母的大小写敏感
- `s.c_str()`：返回一个指向和`s`相同内容的 C 风格字符串的指针，该字符串和`s`本身相关，若改变`s`，指针可能失效。

:::caution 注意事项

<Tabs>

<TabItem value="io" label="输入输出">

不论是使用`<<`进行输出还是使用`>>`和`getline`进行输入，它们都返回输出或输入流本身，而一个输出或输入流本身包含了用于标识自身状态的成员。

当输入或输出操作出现错误时，其状态就会进行相应的变化，同时它们的状态还可以转换为布尔值，如果上一次输入/输出没有出现错误，则转换为`true`，否则将会转换为`false`。

由于这个特性，我们可以将一个输入/输出操作放在条件表达式中，只要上一次输入/输出操作没有出现错误，就可以持续进行输入/输出。

****

另外，对于`getline`，它可以同时读取一行输入，需要注意的是换行符被读进了输入流，但是没有写入`string`对象，而是被丢弃了。这种做法有两个好处，首先是输入区不会出现第一个字符是换行符的情况；第二点就是`string`对象没有保存换行符，就可以只在需要的时候添加。

</TabItem>

<TabItem value="eq" label="相等性及大小比较">

两个字符串只有当它们长度相等并且相同位置字符相同时两个字符串才算相等。

而至于它们之间的大小比较，则按照如下的比较方式进行比较：

1. 如果两个`string`对象的长度不同，而且较短`string`对象的每个字符都与较长`string`对象对应位置上的字符相同，就说较短`string`对象小于较长`string`对象
2. 如果两个`string`对象在某些对应的位置上不一样，则`string`对象比较的结果就是`string`对象中第一对相异字符比较的结果，而`string`中字符的比较依照大小写敏感的字典顺序进行。

</TabItem>

<TabItem value="addition" label="string 对象的加法">

**两个 string 对象相加**：该操作会得到一个新的`string`对象，其内容是将左侧的运算对象和右侧的运算对象串接而成

**字面值与 string 对象相加**：当`string`对象与字符字面值或字符串字面值相加时，会将字符字面值或字符串字面值转换成`string`对象，然后执行两个`string`对象的加法。而两个字符字面值和字符串字面值则没有加法操作，同时由于加法的结合律是从左往右，所以如果在一串加法表达式中，不要将两个字符字面值或字符串字面值放在最前面。例如：

```cpp
string s1 = "Hello", s2 = "World";
string s3 = s1 + ' ' + s2;					// 正确
string s4 = "Hey, " + s1 + ' ' + "World!";	// 正确
// error-next-line
string s5 = "Hello" + " " + s2;				// 错误
```

</TabItem>

<TabItem value="travel" label="处理每个字符">

1. **字符处理函数**

   可以通过包含在头文件`<cctype>`的函数对单个字符进行基本的处理，具体如下表所示：

   | 函数          | 功能                                                     |
   | ------------- | -------------------------------------------------------- |
   | `isalnum(c)`  | 当`c`是字母或数字时为真                                  |
   | `isalpha(c)`  | 当`c`是字母时为真                                        |
   | `iscntrl(c)`  | 当`c`是控制字符时为真                                    |
   | `isdigit(c)`  | 当`c`是数字时为真                                        |
   | `isgraph(c)`  | 当`c`不是空格但可打印时为真                              |
   | `islower(c)`  | 当`c`是小写字母时为真                                    |
   | `isprint(c)`  | 当`c`是可打印字符时为真（空格或其他可视形式）            |
   | `ispunct(c)`  | 当`c`是标点符号时为真                                    |
   | `isspace(c)`  | 当`c`是空白时为真                                        |
   | `issupper(c)` | 当`c`是大写字母时为真                                    |
   | `isxdigit(c)` | 当`c`是十六进制数字时为真                                |
   | `tolower(c)`  | 如果`c`是大写字母，则输出对应的小写字母；否则原样输出`c` |
   | `toupper(c)`  | 如果`c`是小写字母，则输出对应的大写字母；否则原样输出`c` |

2. **处理每个字符的方式**

   1. 范围 for 循环遍历

      `string`支持使用范围 for 语句对其字符进行遍历：

      ```cpp
      string str("some string");
      
      for (char c : str)
          cout << c << endl;
      ```

      `string`内置使用迭代器在每一次循环为`c`赋值，但此时是新建了一个`char`类型对象，所以改变`c`的内容并不会影响到`str`中的内容，如果要使用范围 for 语句修改`str`中的内容，则将循环控制量声明为引用：

      ```cpp
      string str("some string");
      
      for (char &c : str)
          c = toupper(c);
      cout << str << endl;
      ```

   2. 下标操作随机访问

      下标运算符接受一个`string::size_type`类型的值作为参数，这个参数从 0 开始，表示要访问的字符的位置；返回值是该位置上字符的引用。

      必须要注意的是，一个`string`对象`str`下标的范围是`[0, str.size()-1]`，我们在使用的时候不能使下标超过这个范围。C++ 标准并不要求标准库检测下标是否合法，所以一旦使用了一个超出范围的下标，就会产生不可预知的结果。

      **使用下标进行迭代**：

      ```cpp
      for (string::size_type index = 0; index != s.size() && !isspace(s[index]); ++index)
          s[index] = toupper(s[index]);
      ```

      **使用下标进行随机访问**：

      ```cpp
      const string hexdigits = "0123456789ABCDEF";
      string tenth = "13";
      
      string result;
      if(n < hexdigits.size())
          result += hexdigits[n];
      cout << "13's hex: " << result << endl;
      ```


</TabItem>

</Tabs>

:::