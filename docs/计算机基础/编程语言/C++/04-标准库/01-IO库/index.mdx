---
title: IO 库
---

## 一、IO 类

IO 类不仅定义了很多类型，还和`string`类一样定义了几个现有的对象。

IO 类根据流的类型不同，可以分为三类：标准 IO、文件 IO、字符串 IO

<Tabs>

<TabItem value="iostream" label="标准 IO">

```cpp
// 头文件
#include <iostream>
// 类型
using std::istream;
using std::ostream;
using std::iostream;
using std::wistream;
using std::wostream;
using std::wiostream;
// 对象
using std::cin;
using std::cout;
using std::cerr;
using std::clog;
using std::wcin;
using std::wcout;
using std::wcerr;
using std::wclog;
```

</TabItem>

<TabItem value="fstream" label="文件 IO">

```cpp
// 头文件
#include <fstream>
// 类型
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::wifstream;
using std::wofstream;
using std::wfstream;
```

</TabItem>

<TabItem value="sstream" label="字符串 IO">

```cpp
// 头文件
#include <sstream>
// 类型
using istringstream;
using ostringstream;
using stringstream;
using wistringstream;
using wostringstream;
using wstringstream;
```

</TabItem>

</Tabs>

:::info IO 类型间的关系

`ifstream`和`istringstream`都继承自`istream`，而`ofstream`和`ostringstream`都继承自`ostream`。因此，我们是如何使用`cin`、`cout`这些对象的，就可以按照相同的方法应用在其他类型的对象上。

唯一的区别是，`iostream`的对象都是既定的，而`fstream`和`stringstream`类型的对象则需要自己创建并初始化，以及对这些对象进行 IO 操作之后的结果肯定与`iostream`有所区别。所以需要掌握的东西总结下来就是：

- 通用的操作
- `fstream`和`stringstream`的对象创建及初始化操作
- 文件 IO 和字符串 IO 操作的结果

:::



## 二、通用操作

IO 类型最常用的通用操作实际上就两个：

- `operator<<`：对`<<`运算符的重载，用来向一个`ostream`对象写入输出数据。数据先写入到`ostream`对象，然后刷新到屏幕上，最后返回左侧运算对象
- `operator>>`：对`>>`运算符的重载，用来从一个`istream`对象读取输入数据。数据先从系统输入到`istream`对象，然后从`istream`对象读取到运算符右侧运算对象，最后返回左侧运算对象。

### IO 对象不允许拷贝或赋值

我们不能拷贝或对 IO 对象赋值，因此我们也不能将形参或返回类型设置为流类型。

进行 IO 操作的函数通常以**引用方式**传递和返回流，读写一个 IO 对象会改变其状态，因此传递和返回的引用**不能是 const** 的。

### 条件状态

还有一个比较通用的是 IO 类的条件状态，每一次 IO 操作，进行该操作的 IO 对象的状态都可能会发生改变，可以根据这些状态确定其是否发生了错误。

IO 类的条件状态包括 1 个类型、一些函数和标志：

| 类型 | 名字                                    | 效果                                                         |
| ---- | --------------------------------------- | ------------------------------------------------------------ |
| 类型 | `strm::iostate`（`strm`是一种 IO 类型） | `iostate`是一种机器相关的类型，提供了表达条件状态的完整功能  |
| 标志 | `strm::badbit`                          | 一种特定位模式，指出流已崩溃                                 |
| 标志 | `strm::failbit`                         | 一种特定位模式，指出一个 IO 操作失败了                       |
| 标志 | `strm::eofbit`                          | 一种特定位模式，指出流到达了文件结束                         |
| 标志 | `strm::goodbit`                         | 一种特定位模式，指出流未处于错误状态。此值保证为 0           |
| 函数 | `s.eof()`（`s`是一个 IO 对象）          | 若`s`的`eofbit`置位，则返回`true`                            |
| 函数 | `s.fail()`                              | 若`s`的`failbit`或`badbit`置位，则返回`true`                 |
| 函数 | `s.bad()`                               | 若`s`的`badbit`置位，则返回`true`                            |
| 函数 | `s.good()`                              | 若`s`处于有效状态，则返回`true`                              |
| 函数 | `s.clear()`                             | 若`s`中所有条件状态位复位，将流的状态设置为有效。<br />返回`void` |
| 函数 | `s.clear(flags)`                        | 根据给定的`flags`标志位，将流`s`中对应条件状态位复位。<br />`flags`的类型为`strm::iostate`。返回`void` |
| 函数 | `s.setstate(flags)`                     | 根据给定的`flags`标志位，将流`s`中对应条件状态位置位。<br />`flags`的类型为`strm::iostate`。返回`void` |
| 函数 | `s.rdstate()`                           | 返回流`s`的当前条件状态，返回值类型为`strm::iostate`         |

:::info 条件状态的工作原理

- 类型与标志

  `iostate`是每种 IO 类型内都内置的一种类型，实际上可以将这种类型看成一个位序列，所以很大可能这实际上是一个整型。

  每一个 IO 类型还定义了 4 个`iostate`类型的常量值，即 4 种特定的位模式。由于`goodbit`状态是没有任何错误的状态，所以我们可以用 3 个位来实现这样的功能：`goodbit`的位模式为`000`，`badbit`为`001`，`failbit`为`010`，`eofbit`为`100`。当然，这只是我们的模拟实现，实际上的实现方式或许会有差异。

以上的类型以及标志都是属于类的，而并不属于每一个具体的对象，所以我们通常使用`strm::`的格式来访问这些类型和标志。

由于这一点，我们并不通过这些内容来判断一个 IO 对象出了什么错误，而是通过后面的一系列操作。

- 判定函数

  每一个 IO 对象中都应该有一个该类型所属的`iostate`类型的数据成员（姑且称其为`iobit`），其初始值应该和`goodbit`相同，每对该对象进行一次 IO 操作，该对象中的`iobit`成员都可能会发生相应的改变，例如当一个 IO 操作失败时，我们可能需要让其表现出 IO 操作失败和流已崩溃两种状态，所以当 IO 操作检测到 IO 操作失败时，就可能执行这样的操作：`iobit = iobit | badbit | failbit`，这样`iobit`中的两个位就被置位了，从而根据这个数据成员我们就可以了解到这个 IO 对象的状态。

  当然，如果先获取一个 IO 对象的条件状态，再将其与类定义的常量标志位进行比较这样的操作比较麻烦，所以提供了`fail()`、`bad()`、`eof()`、`good()`这一组操作来快速地判断当前 IO 对象的状态。

  实际上，无论 IO 对象发生了何种错误，`failbit`都会被置位，所以通过`fail()`和`good()`两个函数我们就能掌握 IO 对象的总体状态了，而`bad()`和`eof()`只是为了判断具体的错误类型。所以通常`good() == !fail()`。

  为了支持前述的那种比较麻烦的操作，姑且还是提供了一个操作用来获取 IO 对象的条件状态，即：`rdstate()`

- 置位与复位操作

  为了用户可以自定义解决 IO 错误的代码（例如使用`try`代码块来处理 IO 错误），也提供了一组函数来更改当前 IO 对象的状态。

  例如当我们在`catch`子句中解决了 IO 错误之后，可以调用`clear()`来将该 IO 对象进行复位，该函数将默认复位为`goodbit`的状态。

  另外，还提供了两个函数可以将 IO 对象的状态进行选择性的复位和置位。

:::

### 管理输出缓冲

每个输出流都管理一个缓冲区，用来保存程序读写的数据。当我们执行下面的操作：

```cpp
os << "please enter a value: ";
```

文本串可能立即打印出来，但也有可能被操作系统保存在缓冲区中，随后再打印。

有了缓冲机制，操作系统就可以将程序的多个输出操作合成单一的系统级写操作。由于设备的写操作可能很耗时，允许操作系统将多个输出操作合为单一的设备写操作可以带来很大的性能提升。但这样的机制也可能导致一些错误。

**缓冲区刷新的原因**：

- 程序正常结束，作为`main`函数的`return`操作的一部分，缓冲刷新被执行；
- 缓冲区满时，需要刷新缓冲，而后新的数据才能继续写入缓冲区；
- 当我们使用操纵符如`endl`等来显式刷新缓冲区
- 在每个输出操作之后，我们可以使用操纵符`unitbuf`设置流的内部状态，来清空缓冲区。默认情况下，对`cerr`是设置`unitbuf`的，因此写到`cerr`的内容都是立即刷新的。
- 一个输出流可能被关联到另一个流，在这种情况下，当读写到被关联的流时，关联到的流的缓冲区会被刷新。例如，默认情况下，`cin`和`cerr`都关联到`cout`。因此，读`cin`或写`cerr`都会导致`cout`的缓冲区被刷新。

**可能导致的问题**：

缓冲机制可能导致的问题是当程序异常终止时，输出缓冲区可能不会刷新。它所输出的数据可能停留在缓冲输出区中等待打印。

特别是当我们在调试一个已经崩溃的程序时，需要确认那些我们认为已经输出的数据确实已经刷新了。否则，可能将大量时间浪费在追踪代码为什么没有执行上，而实际上代码已经执行了，只是程序崩溃后缓冲区没有被刷新，输出数据被挂起没有打印而已。

为了解决这个问题，所以有了以下的显式刷新缓冲区的方法。

**显式刷新方法**：

我们可以通过`endl`、`flush`、`ends`这几个操纵符来显式刷新缓冲区：

- `endl`：向缓冲区插入换行符并刷新缓冲区
- `flush`：刷新缓冲区但不输出任何额外字符
- `ends`：向缓冲区插入空字符并刷新缓冲区

还有两个操纵符可以直接设定流的状态而不是指示流的操作：

- `unitbuf`：将流设置为`unitbuf`状态，这样的流在接下来的每次操作之后都进行一次`flush`操作
- `nounitbuf`：将流重置为正常的系统管理的缓冲区刷新机制

**关联输入和输出流**：

标准 IO 的对象已经默认定义好了相互的关联性。而其他 IO 的对象则需要用户自己进行关联。

通过下面的操作来关联或解关联流对象：

- `tie()`：返回指向输出流的指针。如果调用该函数的对象当前关联到一个输出流，则返回的就是指向这个流的指针，如果对象未关联到流，则返回空指针。
- `tie(ostream *)`：提供一个指向`ostream`的指针，将调用该函数的 IO 对象关联到这个`ostream`。当我们提供一个空指针时，调用该函数的 IO 对象将不再关联到任何对象

每个流同时最多关联到一个输出流，但多个流可以同时关联到同一个输出流。



## 三、类定义类型转换

IO 类定义了一种隐式转换：即 IO 对象到`bool`值的转换。

该转换根据 IO 对象的条件状态进行，当 IO 对象的条件状态为`goodbit`时，转换为`true`；否则，转换为`false`。