除了顺序容器外，标准库还定义了三个顺序容器适配器：`stack`、`queue`和`priority_queue`。

它们提供和其他顺序容器不同的接口，但却需要使用其他顺序容器作为适配者。

## 一、通用操作

所有容器适配器都支持如下的操作和类型：

- 类型

  | 类型             | 含义                                       |
  | ---------------- | ------------------------------------------ |
  | `size_type`      | 一种类型，足以保存当前类型的最大对象的大小 |
  | `value_type`     | 元素类型                                   |
  | `container_type` | 实现适配器的底层容器实现                   |

- 初始化

  | 操作     | 效果                                           |
  | -------- | ---------------------------------------------- |
  | `A a`    | 创建一个名为`a`的空适配器                      |
  | `A a(c)` | 创建一个名为`a`的适配器，带有容器`c`的一个拷贝 |

- 操作

  | 操作                                 | 效果                                                         |
  | ------------------------------------ | ------------------------------------------------------------ |
  | `==`、`!=`<br />`<`、`<=`、`>`、`>=` | 关系运算符                                                   |
  | `a.empty()`                          | 当容器为空时返回`true`，否则返回`false`                      |
  | `a.size()`                           | 返回`a`中的元素数目                                          |
  | `swap(a, b)`<br />`a.swap(b)`        | 交换`a`和`b`的内容，`a`和`b`必须有相同类型，包括底层容器类型也必须相同 |

### 适配器的实现

默认情况下，`stack`和`queue`是基于`deque`实现的，`priority_queue`是在`vector`之上实现的。

适配器的实例化和其他容器相同，一般只需要一个元素类型参数，但如果想重载适配器的默认容器实现，需要添加第二个类型参数，第二个类型参数必须是元素类型和适配器元素类型相同的容器类型：

```cpp
stack<string, vector<string>> str_stk;
stack<string, vector<string>> str_stk2(svec);
```

对于一个给定的适配器，可以使用哪些容器是有限制的。所有适配器都要求容器具有添加和删除元素的能力。因此，适配器不能构造在`array`之上。类似的，我们也不能使用`forward_list`来构造适配器，因为所有适配器还要求容器具有访问尾元素的能力。

除此之外，`stack`只要求`push_back`、`pop_back`和`back`操作；`queue`要求`back`、`push_back`、`front`和`push_front`；而`priority_queue`除了`front`、`push_back`、`pop_back`之外，还要求随机访问的能力。



## 二、特殊操作

### 1. 栈适配器

| 操作                                  | 效果                                                         |
| ------------------------------------- | ------------------------------------------------------------ |
| `s.pop()`                             | 删除栈顶元素，但不返回该元素值                               |
| `s.push(item)`<br />`s.emplace(args)` | 创建一个新元素压入栈顶，该元素通过拷贝或移动`item`而来，或者由`args`构造 |
| `s.top()`                             | 返回栈顶元素，但不将元素弹出栈                               |



### 2. 队列适配器

| 操作                                  | 效果                                                         |
| ------------------------------------- | ------------------------------------------------------------ |
| `q.pop()`                             | 返回`queue`的首元素或`priority_queue`的最高优先级的元素，但不返回此元素 |
| `q.front()`                           | 返回首元素或尾元素，但不删除此元素                           |
| `q.back()`                            | （<Highlight color="#25c2a0">只适用于 queue</Highlight>）    |
| `q.top()`                             | 返回最高优先级元素，但不删除该元素（<Highlight color="#25c2a0">只适用于 priority_queue</Highlight>） |
| `q.push(item)`<br />`q.emplace(args)` | 在`queue`末尾或`priority_queue`中恰当的位置创建一个元素<br />其值为`item`，或者由`args`构造 |

