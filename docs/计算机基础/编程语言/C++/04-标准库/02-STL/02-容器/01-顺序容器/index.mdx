---
title: 顺序容器
---

## 一、概述

**顺序容器**为程序员提供了控制元素存储和顺序访问的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。

所有的顺序容器如下表所示：

| 容器类型       | 描述                                                         |
| -------------- | ------------------------------------------------------------ |
| `vector`       | 可变大小数组类模板。<br />支持快速随机访问；<br />在尾部之外的位置插入或删除元素可能很慢 |
| `deque`        | 双端队列类模板。<br />支持快速随机访问；<br />在头尾位置插入/删除速度很快 |
| `list`         | 双向链表类模板。<br />只支持双向顺序访问。<br />在`list`中任何位置进行插入/删除操作速度都很快 |
| `forward_list` | 单向链表类模板。<br />只支持单向顺序访问。<br />在链表任何位置进行插入/删除操作都很快 |
| `array`        | 固定大小数组类模板。<br />支持快速随机访问。<br />不能添加或删除元素 |
| `string`       | 可变长度`char`类型字符串类型。<br />专门用于保存字符，支持快速随机访问；<br />在尾部插入/删除速度很快。 |

- 除了`string`之外，其他的容器类型都是类模板，使用前是需要实例化的。而`string`实际上也来自于一个类模板`basic_string`，但由于字符串只用来保存字符，所以`basic_string`的所有实例化类型都已定义了，包括：`string`、`wstring`、`u16string`、`u32string`。
- 除了`array`之外，其他容器都提供高效、灵活的内存管理。可以添加和删除元素，扩张和收缩容器的大小。
- `vector`、`string`将元素保存在连续的内存空间中，所以下标访问非常快速，但在这两种容器的中间添加或删除元素会非常耗时
- `list`、`forward_list`中的元素并不在连续的内存空间中，所以不支持随机访问，但这两种容器可以在容器任何位置快速的添加或删除元素
- `deque`是双端队列，也就是可以快速地在两端插入或删除元素，而在中间插入或删除元素可能会很快也可能会很慢，这是由于`deque`的具体实现方式决定的。另外`deque`也支持随机访问



## 二、顺序容器操作

- 定义和初始化（<Highlight color="#25c2a0">array 不支持</Highlight>）

  | 操作          | 效果                                                         |
  | ------------- | ------------------------------------------------------------ |
  | `C seq(n)`    | `seq`包含`n`个元素，这些元素进行了值初始化。（<Highlight color="#25c2a0">string 不支持</Highlight>） |
  | `C seq(n, t)` | `seq`包含`n`个初始化为值`t`的元素                            |

- 赋值（<Highlight color="#25c2a0">array 不支持</Highlight>）

  | 操作               | 效果                                                         |
  | ------------------ | ------------------------------------------------------------ |
  | `seq.assign(b, e)` | 将`seq`中的元素替换为迭代器`b`和`e`所表示范围内的元素。迭代器`b`和`e`不能指向`seq`中的元素 |
  | `seq.assign(il)`   | 将`seq`中的元素替换为初始化列表（`initializer_list`）`il`中的元素 |
  | `seq.assign(n, t)` | 将`seq`中的元素替换为`n`个值为`t`的元素                      |

- 插入元素（<Highlight color="#25c2a0">array 不支持</Highlight>）

  | 操作                                           | 效果                                                         |
  | ---------------------------------------------- | ------------------------------------------------------------ |
  | `c.push_back(t)`<br />`c.emplace_back(args)`   | 在`c`的尾部创建一个值为`t`或由`args`创建的元素。返回`void`（<Highlight color="#25c2a0">forward_list 不支持</Highlight>） |
  | `c.push_front(t)`<br />`c.emplace_front(args)` | 在`c`的头部创建一个值为`t`或由`args`创建的元素。返账`void`（<Highlight color="#25c2a0">vector 和 string 不支持</Highlight>） |
  | `c.insert(p, t)`<br />`c.emplace(p, args)`     | 在迭代器`p`指向的元素之前创建一个值为`t`或由`args`创建的元素<br />返回指向新添加的元素的迭代器 |
  | `c.insert(p, n, t)`                            | 在迭代器`p`指向的元素之前插入`n`个值为`t`的元素。<br />返回指向新添加的第一个元素的迭代器；若`n`为 0，返回`p` |
  | `c.insert(p, b, e)`                            | 将迭代器`b`和`e`指定范围内的元素插入到迭代器`p`指向的元素之前。`b`和`e`不能指向`c`中的元素。<br />返回指向新添加的第一个元素的迭代器；若范围为空，则返回`p` |
  | `c.insert(p, il)`                              | `il`是一个`initializer_list`的元素值列表。将这些给定值插入到迭代器`p`指向的元素之前。<br />返回指向新添加的第一个元素的迭代器，若列表为空，则返回`p` |

  注：`forward_list`有自己的专有版本的`insert`和`emplace`，不使用上表中的`insert`和`emplace`

- 访问元素

  | 操作        | 效果                                                         |
  | ----------- | ------------------------------------------------------------ |
  | `c.back()`  | 返回`c`中尾元素的引用。若`c`为空，函数行为未定义（<Highlight color="#25c2a0">forward_list 不支持</Highlight>） |
  | `c.front()` | 返回`c`中首元素的引用。若`c`为空，函数行为未定义             |
  | `c[n]`      | 返回`c`中下标为`n`的元素的引用。下标越界时行为未定义（<Highlight color="#25c2a0">只适用于 string、vector、deque、array</Highlight>） |
  | `c.at(n)`   | 返回下标为`n`的元素的引用。下标越界时，抛出`out_of_range`异常（<Highlight color="#25c2a0">只适用于 string、vector、deque、array</Highlight>） |

- 删除元素（<Highlight color="#25c2a0">array 不支持</Highlight>）

  | 操作            | 效果                                                         |
  | --------------- | ------------------------------------------------------------ |
  | `c.pop_back()`  | 删除`c`中尾元素。若`c`为空，函数行为未定义。返回`void`（<Highlight color="#25c2a0">forward_list 不支持</Highlight>） |
  | `c.pop_front()` | 删除`c`中首元素。若`c`为空，函数行为未定义。返回`void`（<Highlight color="#25c2a0">vector、string 不支持</Highlight>） |
  | `c.erase(p)`    | 删除迭代器`p`所指定的元素，返回一个指向被删元素之后元素的迭代器<br />若`p`指向尾元素，则返回尾后迭代器。<br />若`p`是尾喉迭代器，则函数行为未定义 |
  | `c.erase(b, e)` | 删除迭代器`b`和`e`所指范围内的元素，返回一个指向最后一个被删元素之后元素的迭代器<br />若`e`本身就是尾后迭代器，则函数也返回尾后迭代器 |
  | `c.clear()`     | 删除`c`中所有元素。返回`void`                                |

  注：`forward_list`有特殊版本的`erase`，不使用上表中的`erase`

- 改变容器大小（<Highlight color="#25c2a0">array 不支持</Highlight>）

  | 操作             | 效果                                                         |
  | ---------------- | ------------------------------------------------------------ |
  | `c.resize(n)`    | 调整`c`的大小为`n`个元素。<br />若`n<c.size()`，则多出的元素被丢弃。若必须添加新元素，对新元素进行值初始化 |
  | `c.resize(n, t)` | 调整`c`的大小为`n`个元素。<br />任何新添加的元素都初始化为值`t` |
  
- 管理容量（<Highlight color="#25c2a0">仅 vector、string、deque 支持</Highlight>）

  | 操作                | 效果                                                         |
  | ------------------- | ------------------------------------------------------------ |
  | `c.shrink_to_fit()` | 请求将`capacity()`减少为与`size()`相同的大小，具体实现可以忽略此请求。 |
  | `c.capacity()`      | 返回当前容器的容量（<Highlight color="#25c2a0">deque 不支持</Highlight>） |
  | `c.reserve(n)`      | 分配至少能容纳`n`个元素的内存空间，只有当`n>size()`时才重新分配（<Highlight color="#25c2a0">deque 不支持</Highlight>） |

  注：容量管理操作是来源于`vector`、`string`和`deque`的实现方式，由于它们采用动态分配内存的方式实现，所以可以对实际的容量进行管理。



## 三、迭代器失效

向容器中添加元素和从容器中删除元素的操作可能会使指向容器元素的指针、引用或迭代器失效。一个失效的指针、引用或迭代器将不再表示任何元素。

具体的失效情况如下：

- 在向容器添加元素后：
  - 如果容器是`vector`或`string`，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用将会失效
  - 对于`deque`，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。
  - 对于`list`和`forward_list`，指向容器的迭代器（包括尾后迭代器和首前迭代器）、指针和引用仍有效。
- 当我们从一个容器删除元素后，指向被删除元素的迭代器、指针和引用会失效。当我们删除一个元素后：
  - 对于`list`和`forward_list`，指向容器其他位置的迭代器（包括尾后迭代器和首前迭代器）、引用和指针仍有效。
  - 对于`deque`，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、引用或指针也会失效。如果是删除`deque`的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不受影响；如果是删除首元素，这些也不会受影响
  - 对于`vector`和`string`，指向被删元素之前元素的迭代器、引用和指针仍有效。当我们删除元素时，尾后迭代器总是会失效。
