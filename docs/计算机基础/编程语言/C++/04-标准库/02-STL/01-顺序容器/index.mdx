---
title: 顺序容器
---

## 一、概述

容器是 C++ 提供的一组数据结构，用来保存一些特定类型对象的集合。

**顺序容器**为程序员提供了控制元素存储和顺序访问的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。

所有的顺序容器如下表所示：

| 容器类型       | 描述                                                         |
| -------------- | ------------------------------------------------------------ |
| `vector`       | 可变大小数组类模板。<br />支持快速随机访问；<br />在尾部之外的位置插入或删除元素可能很慢 |
| `deque`        | 双端队列类模板。<br />支持快速随机访问；<br />在头尾位置插入/删除速度很快 |
| `list`         | 双向链表类模板。<br />只支持双向顺序访问。<br />在`list`中任何位置进行插入/删除操作速度都很快 |
| `forward_list` | 单向链表类模板。<br />只支持单向顺序访问。<br />在链表任何位置进行插入/删除操作都很快 |
| `array`        | 固定大小数组类模板。<br />支持快速随机访问。<br />不能添加或删除元素 |
| `string`       | 可变长度`char`类型字符串类型。<br />专门用于保存字符，支持快速随机访问；<br />在尾部插入/删除速度很快。 |

- 除了`string`之外，其他的容器类型都是类模板，使用前是需要实例化的。而`string`实际上也来自于一个类模板`basic_string`，但由于字符串只用来保存字符，所以`basic_string`的所有实例化类型都已定义了，包括：`string`、`wstring`、`u16string`、`u32string`。
- 除了`array`之外，其他容器都提供高效、灵活的内存管理。可以添加和删除元素，扩张和收缩容器的大小。
- `vector`、`string`将元素保存在连续的内存空间中，所以下标访问非常快速，但在这两种容器的中间添加或删除元素会非常耗时
- `list`、`forward_list`中的元素并不在连续的内存空间中，所以不支持随机访问，但这两种容器可以在容器任何位置快速的添加或删除元素
- `deque`是双端队列，也就是可以快速地在两端插入或删除元素，而在中间插入或删除元素可能会很快也可能会很慢，这是由于`deque`的具体实现方式决定的。另外`deque`也支持随机访问



## 二、操作

容器类型上的操作形成了一种层次：

- 通用操作：所有容器类型都提供的操作
- 容器大类操作：仅支持顺序容器、关联容器或无序容器的操作
- 特殊容器操作：某个或某几个容器支持的操作



### 1. 通用操作

- **类型别名**

  | 类型别名                 | 含义                                                   |
  | ------------------------ | ------------------------------------------------------ |
  | `iterator`               | 此容器类型的迭代器类型                                 |
  | `const_iterator`         | 可以读取元素，但不能修改元素的迭代器类型               |
  | `size_type`              | 无符号整数类型，足够保存此种容器类型最大可能容器的大小 |
  | `difference_type`        | 带符号整数类型，足够保存两个迭代器之间的距离           |
  | `value_type`             | 元素类型                                               |
  | `reference`              | 元素的左值类型；与`value_type&`含义相同                |
  | `const_reference`        | 元素的`const`左值类型                                  |
  | `reverse_iterator`       | 反向迭代器（`forward_list`不支持持）                   |
  | `const_reverse_iterator` | 常量反向迭代器（`forward_list`不支持）                 |

- 构造函数

  | 构造函数            | 效果                                                         |
  | ------------------- | ------------------------------------------------------------ |
  | `C c`               | 默认构造函数，构造空容器                                     |
  | `C c1(c2)`          | 构造`c2`的拷贝`c1`。非`explicit`，故可拷贝                   |
  | `C c(b, e)`         | 构造`c`，将迭代器`b`和`e`指定的范围内的元素拷贝到`c`（`array`不支持） |
  | `C c{a, b, c, ...}` | 列表初始化`c`。非`explicit`，故可拷贝                        |

  注：`array`类型的实例化需要额外提供一个参数，即数组大小，这也是类型的一部分：

  ```cpp
  array<int, 42> ivec;			// 保存 42 个 int 的数组
  array<int, 42>::size_type i;	// 使用该类型时必须包含数组大小
  ```

- 赋值与 swap

  | 操作                  | 效果                                            |
  | --------------------- | ----------------------------------------------- |
  | `c1 = c2`             | 将`c1`中的元素替换为`c2`中元素                  |
  | `c1 = {a, b, c, ...}` | 将`c1`中的元素替换为列表中元素（`array`不支持） |
  | `a.swap(b)`           | 交换`a`与`b`的元素                              |
  | `swap(a, b)`          | 与`a.swap(b)`等价                               |

- 大小

  | 操作           | 效果                                    |
  | -------------- | --------------------------------------- |
  | `c.size()`     | `c`中元素的数目（`forward_list`不支持） |
  | `c.max_size()` | `c`可保存的最大元素数目                 |
  | `c.empty()`    | 若`c`为空返回`true`，否则返回`false`    |

- 添加/删除元素（`array`不支持）

  | 操作               | 效果                            |
  | ------------------ | ------------------------------- |
  | `c.insert(args)`   | 将`args`中的元素拷贝进`c`       |
  | `c.emplace(inits)` | 使用`inits`构造`c`中的一个元素  |
  | `c.erase(args)`    | 删除`args`指定的元素            |
  | `c.clear()`        | 删除`c`中的所有元素，返回`void` |

- 关系运算符

  | 操作                 | 效果                             |
  | -------------------- | -------------------------------- |
  | `==`、`!=`           | 相等性判断                       |
  | `<`、`<=`、`>`、`>=` | 关系运算符（无序关联容器不支持） |

  注：容器的关系运算符使用元素的关系运算符完成比较。元素至少需要定义了`==`和`<`运算符。

- 迭代器

  | 操作                       | 效果                                                         |
  | -------------------------- | ------------------------------------------------------------ |
  | `c.begin()`、`c.end()`     | 返回指向`c`的首元素和尾元素之后位置的迭代器                  |
  | `c.cbegin()`、`c.cend()`   | 返回`const_iterator`                                         |
  | `c.rbegin()`、`c.rend()`   | 返回指向`c`的尾元素和首元素之前位置的迭代器（`forward_list`不支持） |
  | `c.crbegin()`、`c.crend()` | 返回`const_reverse_iterator`（`forward_list`不支持）         |



### 2. 顺序容器操作

- 定义和初始化（`array`不支持）

  | 操作          | 效果                                                         |
  | ------------- | ------------------------------------------------------------ |
  | `C seq(n)`    | `seq`包含`n`个元素，这些元素进行了值初始化。（`string`不支持） |
  | `C seq(n, t)` | `seq`包含`n`个初始化为值`t`的元素                            |

- 赋值（`array`不支持）

  | 操作               | 效果                                                         |
  | ------------------ | ------------------------------------------------------------ |
  | `seq.assign(b, e)` | 将`seq`中的元素替换为迭代器`b`和`e`所表示范围内的元素。迭代器`b`和`e`不能指向`seq`中的元素 |
  | `seq.assign(il)`   | 将`seq`中的元素替换为初始化列表（`initializer_list`）`il`中的元素 |
  | `seq.assign(n, t)` | 将`seq`中的元素替换为`n`个值为`t`的元素                      |

- 插入元素（`array`不支持）

  | 操作                                           | 效果                                                         |
  | ---------------------------------------------- | ------------------------------------------------------------ |
  | `c.push_back(t)`<br />`c.emplace_back(args)`   | 在`c`的尾部创建一个值为`t`或由`args`创建的元素。返回`void`（`forward_list`不支持） |
  | `c.push_front(t)`<br />`c.emplace_front(args)` | 在`c`的头部创建一个值为`t`或由`args`创建的元素。返账`void`（`vector`和`string`不支持） |
  | `c.insert(p, t)`<br />`c.emplace(p, args)`     | 在迭代器`p`指向的元素之前创建一个值为`t`或由`args`创建的元素<br />返回指向新添加的元素的迭代器 |
  | `c.insert(p, n, t)`                            | 在迭代器`p`指向的元素之前插入`n`个值为`t`的元素。<br />返回指向新添加的第一个元素的迭代器；若`n`为 0，返回`p` |
  | `c.insert(p, b, e)`                            | 将迭代器`b`和`e`指定范围内的元素插入到迭代器`p`指向的元素之前。`b`和`e`不能指向`c`中的元素。<br />返回指向新添加的第一个元素的迭代器；若范围为空，则返回`p` |
  | `c.insert(p, il)`                              | `il`是一个`initializer_list`的元素值列表。将这些给定值插入到迭代器`p`指向的元素之前。<br />返回指向新添加的第一个元素的迭代器，若列表为空，则返回`p` |

  注：`forward_list`有自己的专有版本的`insert`和`emplace`，不使用上表中的`insert`和`emplace`

- 访问元素

  | 操作        | 效果                                                         |
  | ----------- | ------------------------------------------------------------ |
  | `c.back()`  | 返回`c`中尾元素的引用。若`c`为空，函数行为未定义（`forward_list`不支持） |
  | `c.front()` | 返回`c`中首元素的引用。若`c`为空，函数行为未定义             |
  | `c[n]`      | 返回`c`中下标为`n`的元素的引用。下标越界时行为未定义（只适用于`string`、`vector`、`deque`、`array`） |
  | `c.at(n)`   | 返回下标为`n`的元素的引用。下标越界时，抛出`out_of_range`异常（只适用于`string`、`vector`、`deque`、`array`） |

- 删除元素（`array`不支持）

  | 操作            | 效果                                                         |
  | --------------- | ------------------------------------------------------------ |
  | `c.pop_back()`  | 删除`c`中尾元素。若`c`为空，函数行为未定义。返回`void`（`forward_list`不支持） |
  | `c.pop_front()` | 删除`c`中首元素。若`c`为空，函数行为未定义。返回`void`（`vector`、`string`不支持） |
  | `c.erase(p)`    | 删除迭代器`p`所指定的元素，返回一个指向被删元素之后元素的迭代器<br />若`p`指向尾元素，则返回尾后迭代器。<br />若`p`是尾喉迭代器，则函数行为未定义 |
  | `c.erase(b, e)` | 删除迭代器`b`和`e`所指范围内的元素，返回一个指向最后一个被删元素之后元素的迭代器<br />若`e`本身就是尾后迭代器，则函数也返回尾后迭代器 |
  | `c.clear()`     | 删除`c`中所有元素。返回`void`                                |

  注：`forward_list`有特殊版本的`erase`，不使用上表中的`erase`

- 改变容器大小（`array`不支持）

  | 操作             | 效果                                                         |
  | ---------------- | ------------------------------------------------------------ |
  | `c.resize(n)`    | 调整`c`的大小为`n`个元素。<br />若`n<c.size()`，则多出的元素被丢弃。若必须添加新元素，对新元素进行值初始化 |
  | `c.resize(n, t)` | 调整`c`的大小为`n`个元素。<br />任何新添加的元素都初始化为值`t` |



## 三、迭代器失效

向容器中添加元素和从容器中删除元素的操作可能会使指向容器元素的指针、引用或迭代器失效。一个失效的指针、引用或迭代器将不再表示任何元素。

具体的失效情况如下：

- 在向容器添加元素后：
  - 如果容器是`vector`或`string`，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用将会失效
  - 对于`deque`，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。
  - 对于`list`和`forward_list`，指向容器的迭代器（包括尾后迭代器和首前迭代器）、指针和引用仍有效。
