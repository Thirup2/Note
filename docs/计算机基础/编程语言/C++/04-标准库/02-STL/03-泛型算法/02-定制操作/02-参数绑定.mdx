当一个函数需要多于算法要求的参数数量时，除了使用 lambda 表达式，也可以对普通函数进行参数绑定的方式来构造一个新的可调用对象从而传入算法。

## 一、基本格式

对于那种只在一两个地方使用的简单操作，lambda 表达式是最有用的。如果我们需要在很多地方使用相同的操作，通常应该定义一个函数，而不是多次编写相同的 lambda 表达式。类似的，如果一个操作需要很多语句才能完成，通常使用函数更好。

如果 lambda 的捕获列表为空，通常可以使用函数来代替它。但是，对于捕获局部变量的 lambda，用函数来替换它就不是那么容易了。尽管函数可以使用默认实参，但实际上却并不能做到获取局部变量作为默认实参的功能。

我们可以用一种方法解决一个函数的参数问题，即使用`bind`这个标准库函数，定义在头文件`functional`中。可以将`bind`看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来适应原对象的参数列表。

调用`bind`的一般形式为：

```cpp
auto newCallable = bind(callable, arg_list);
```

其中，`newCallable`本身是一个可调用对象，`arg_list`是一个逗号分隔的参数列表，对应给定的`callable`的参数。即，当我们调用`newCallable`时，`newCallable`会调用`callable`，并传递给它`arg_list`中的参数。

也就是说：

```cpp
newCallable();
```

等价于

```cpp
callable(arg_list);
```



## 二、绑定参数

`arg_list`中的参数可能是形如`_n`的名字，其中`n`是一个整数，这些参数是“占位符”，表示`newCallable`的参数，它们占据了传递给`newCallable`的参数的“位置”。数值`n`表示生成的可调用对象中参数的位置：`_1`为`newCallable`的第一个参数，`_2`为第二个参数，以此类推。

例如：

```cpp
auto check6 = bind(check_size, _1, 6);
```

此`bind`调用只有一个占位符，表示`check6`只接受单一参数，并且接受的这个参数会放在`_1`的位置用于调用`check_size`。

下例是提供两个占位符的情况，占位符可以不按顺序给出：

```cpp
auto g = bind(f, a, b, _2, c, _1);
```

其中由于有两个占位符，所以`g`接受两个参数，第一个参数用来填充`_1`的位置，第二个参数用来填充`_2`的位置，然后用这些参数调用`f`这个可调用对象。

:::info 指定 _n 所在命名空间

名字`_n`都定义在一个名为`placeholders`的命名空间中，而这个命名空间本身定义在`std`命名空间中。所以，使用之前应该：

```cpp
using std::placeholders::_1;
using std::placeholders::_2;
// ...
```

或者：

```cpp
using std::placeholders;
```

:::



## 三、绑定引用参数

默认情况下，`bind`的那些不是占位符的参数被拷贝到`bind`返回的可调用对象中。但是，与 lambda 类似，有时对有些绑定的参数我们希望以引用方式传递，或是要绑定参数的类型无法拷贝。

这种情况下就只有使用标准库`ref`函数，它返回一个对象，包含给定的引用，此对象是可以拷贝的。另外还有一个`cref`函数，生成一个保存`const`引用的类。与`bind`一样，`ref`和`cref`也定义在头文件`functional`中。

```cpp
for_each(words.begin(), words.end(),
        bind(print, ref(os), _1, ' '));
```

只有给出值的参数可能需要传入引用类型，定义为`_n`的占位符其包含明确的类型并且已经暴露在了`bind`中，所以无需定义为引用类型。

`ref`函数接受一个引用类型的形参，其作用是创建一个类类型的对象，其中包含该引用类型的成员。如果将这个类型的对象传给该引用类型，则会自动将这个成员赋值给对应的引用类型。