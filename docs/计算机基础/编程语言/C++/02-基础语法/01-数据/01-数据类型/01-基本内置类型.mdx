C++ 中基本内置类型包括**算术类型**和**空类型**。其中算术类型包含了字符、整型数、布尔值和浮点数。而空类型不对应具体的值，仅用于一些特殊的场合，例如当函数不返回任何值的时候使用空类型作为返回类型。

## 一、布尔类型

| 类型     | 声明符 | 最小尺寸   |
| -------- | ------ | ---------- |
| 布尔类型 | `bool` | **未定义** |



## 二、字符类型

| 类型                | 声明符     | 最小尺寸 |
| ------------------- | ---------- | -------- |
| 字符类型            | `char`     | 8 位     |
| 宽字符类型          | `wchar_t`  | 16 位    |
| Unicode16 字符类型  | `char16_t` | 16 位    |
| Unicode 32 字符类型 | `char32_t` | 32 位    |

:::tip 字符类型的底层实现

字符类型保存的实际上是一个整数，即字符的编码，通过 C++ 的字符打印功能可以直接打印出字符或字符串。而如果经过一些处理，你可以将其中的整数值打印出来。

你也可以直接用整数字面值向字符类型赋值，将产生相同的效果。

在此基础上，你可以用一个`char`类型保存一个比较小的整数，但并不建议您这么做，因为`char`可能被实现为带符号或不带符号类型中的任意一种。也就是说，`char`类型可能表示的是`0-255`，也可能表示`-127-127`（通常是`-128-127`）。如果你只用它来表示`0-127`这个范围的值，倒是不会出现什么问题。

如果你无论如何想要用`char`类型来保存一个整数，请声明其符号，如`signed char`或`unsigned char`

:::

### 字符及字符串的编码

程序中的字符或字符串有两类来源，一类是程序中的字面值，一类是用户的输入。

<Tabs>

<TabItem value="literal" label="字面值的编码">

字面值的编码首先与源文件编码和编译器选项有关。在编译器中有一套选项可以指示源文件的编码以及输出的程序使用的编码。具体内容可以参考我的博客：[编程中乱码出现的原因](https://blog.syunn.cn/posts/c77f42f7/)。简单来说，当编译器的源文件编码选项和源文件编码匹配时，所有字符和字符串字面值都会被正确地保存或转换。另外，为了程序的输出不会乱码，通常我们还需要同时将编译器的输出程序编码选项和终端编码相匹配。为方便后续讨论，我们将编译器中指示源文件编码的选项称为***输入选项***，将指示输出程序编码的选项称为***输出选项***

对于所有类型的字符和字符串字面值，其中不带任何前缀的字面值即`char`和`char[]`类型的字面值将进行从***输入选项***的设定值到***输出选项***的设定值的转换。假设源文件为 UTF-8 编码，如果使用 MinGW 进行编译，它的两个选项默认都为 UTF-8，也就是说不会进行任何转换，如果将这些字面值直接输出到终端（假设是中文 Windows，GB2312 编码），将会导致乱码。当然如果你将源文件编码改为 GB2312，再进行编译，这些字面值仍然不会进行任何转换，但这次不会产生乱码。但并不建议这么做，因为你的其他类型的字符和字符串字面值将无法正确保存。更好的解决方案是修改***输出选项***的值，将其修改为用户环境的编码，根据此处的假设应该是 GB2312，这样这些字符和字符串字面值将执行从 UTF-8 到 GB2312 的转换并保存到程序中，如果直接输出，也将得到正确的输出。

对于`L`前缀的字符和字符串字面值，它们采用的编码通常根据平台和编译器而异。在 Windows 中通常是 UTF-16LE。在 Linux 中则通常是 UTF-32LE，它的尺寸也将是 32 位而非 16位。在编译器正确识别源文件编码的前提下，`L`前缀的字符和字符串字面值将从源文件编码转换为`wchar_t`在不同平台和编译器下对应的编码。

对于`u`前缀的字符和字符串字面值，它们采用的编码是 UTF-16，但通常实现为 UTF-16BE。在编译器正确识别源文件编码的前提下，`u`前缀的字符和字符串字面值将从源文件编码转换为 UTF-16，通常是 UTF-16BE。

对于`U`前缀的字符和字符串字面值，它们采用的编码是 UTF-32，但通常实现为 UTF-32BE。在编译器正确识别源文件编码的前提下，`U`前缀的字符和字符串字面值将从源文件编码转换为 UTF-32，通常是 UTF-32BE。

如果使用`u8`前缀，则只对字符串生效，指示字符串采用 UTF-8 编码保存。在编译器正确识别源文件编码的前提下，`u8`前缀的字符和字符串字面值将从源文件编码转换为 UTF-8。

</TabItem>

<TabItem value="input" label="用户输入的编码">

而对于用户的输入，实际上则更简单一些，C++ 只提供了`char`和`wchar_t`类型的输入输出函数，你的输入首先会按照你的终端字符集进行编码，然后传输到程序中，如果你想在程序中处理这些字符，则需要手动执行一些编码转换函数，因为编译器并不会自动进行用户输入字符串的编码转换。

在此基础上，我们可以知道如果我们想要输出字符或者字符串，则需要先将其编码转换为你的终端字符集才能正常输出。

</TabItem>

</Tabs>



## 三、整数类型

| 类型             | 声明符                                                       | 最小尺寸 |
| ---------------- | ------------------------------------------------------------ | -------- |
| 短整型           | `short`、`short int`、`signed short`、`signed short int`     | 16 位    |
| 整型             | `int`、`signed int`                                          | 16 位    |
| 长整型           | `long`、`long int`、`signed long`、`signed long int`         | 32 位    |
| 扩展长整型       | `long long`、`long long int`、`signed long long`、`signed long long int` | 64 位    |
| 无符号短整型     | `unsigned short`、`unsigned short int`                       | 16 位    |
| 无符号整型       | `unsigned`、`unsigned int`                                   | 16 位    |
| 无符号长整形     | `unsigned long`、`unsigned long int`                         | 32 位    |
| 无符号扩展长整型 | `unsigned long long`、`unsigned long long int`               | 64 位    |

:::info 整数类型的尺寸

在 C++ 标准中，只规定了每种类型的最小尺寸，同时还满足一个限定条件：一个`int`至少和一个`short`一样大，一个`long`至少和一个`int`一样大，一个`long long`至少和一个`long`一样大。

按照习惯而言，短整型通常被实现为 16 位，整型被实现为 32 位，扩展长整型则被实现为 64 位。稍微有点不同的是长整型，它在 Windows 下通常被实现为 32 位，而在 Linux 下则通常被实现为 64 位。

在不需要严格考虑程序兼容性的情况下可以按照习惯使用这些类型。但如果在需要严格兼容的要求下，可以使用`<cstdint>`库中的定宽整数类型以及其配套的输入输出以及处理函数。

:::

:::tip 有符号整数的表示范围

由于`char`类型也是整型，同时它的位数比较少，比较适合举例，故此处用`signed char`类型进行举例。

一个`signed char`类型有 8 个 bit，理论上来说能表示 256 个数字，如果是`unsigned char`类型，则能够表示 0-255 的数字。

可如果是`signed char`，那么将有可能表示`-127-127`，也可能表示`-128-127`。这取决于整型在底层的实现，常见的实现有反码和补码，前者只能表示 255 个数字的就是反码，而后者就是补码。

通常现在的机器都是补码实现，但不排除有反码实现。故如果在高严格兼容的要求下，请默认使用`-127-127`这个范围，其他整型也以此类推。

:::



## 四、浮点类型

| 类型           | 声明符        | 最小尺寸      |
| -------------- | ------------- | ------------- |
| 单精度浮点数   | `float`       | 6 位有效数字  |
| 双精度浮点数   | `double`      | 10 位有效数字 |
| 扩展精度浮点数 | `long double` | 10 位有效数字 |

:::info 为什么是有效数字

对于浮点数的尺寸定义并不是用占用多少 bit，而是其有效数字位数。

在 CPU 中整数的计算和浮点数的计算是有两套不同的计算线路的，所以使用的寄存器也不同。浮点数将从内存转移到 CPU 中保存浮点数的那些寄存器中，所以 CPU 对于浮点数的解释也和整数不同。

通常一个浮点数被分成三个部分，一个位用来表示正负；第二个部分用来表示被处理过的浮点数，这种处理就是移动小数点将其移动到整个浮点数的最左端，使整数部分为 0 或者 1；然后第三部分用来表示指数部分。

因为有指数部分的存在，所以浮点数实际上可以表示很大的数字，于是第二部分就变成了整个浮点数最重要的部分。如果规定浮点数的位数，由于没有具体规定其指数部分的位数，所以最后浮点部分就不确定了，那么精度也就不确定了。

同时为了使编译器的实现更加灵活，所以决定只规定浮点类型的有效数字长度。

当然，通常来说，一个`float`有 32 个 bit，一个`double`有 64 个 bit，而一个`long double`有 96 或 128 个 bit。

:::
