## 一、声明

声明包含两个最重要的部分，即变量的**类型**和**名字（标识符）**，所以一条声明语句最少也是必须包含这两个部分。

基本的语法是：`Type Identifier;`，以分号结尾，示例如下：

```cpp
int ival;
double dval;
char *string;
char str[20];
```

声明语句的作用是向程序提供一个名字（标识一块地址）和其类型（需要被解释为几个 bit 以及是整型还是浮点型）。但在声明发生后定义发生前，也只会提供一个名字，而没有该名字对应的内存被分配（大多数情况下，以上声明同时也是定义，故会分配内存）。

另外，一条声明语句可以同时声明多个相同类型变量：

```cpp
int ival1, ival2;
```

### 标识符命名规则

1. 标识符由**字母**、**数字**、**下划线**组成，其中必须以字母或下划线开头；

2. 标识符的长度没有限制，但对大小写字母敏感；

3. 以下关键字不能用于标识符名字：

   ```
   // C++ 关键字
   alignas			continue		friend			register			true
   alignof			decltype		goto			reinterpret_cast	try
   asm				default			if				return				typedef
   auto			delete			inline			short				typeid
   bool			do				int				signed				typename
   break			double			long			sizeof				union
   case			dynamic_cast	mutable			static				unsigned
   catch			else			namespace		static_assert		using
   char			enum			new				static_cast			virtual
   char16_t		explicit		noexcept		struct				void
   char32_t		export			nullptr			switch				volatile
   class			extern			operator		template			wchar_t
   const			false			private			this				while
   constexpr		float			protected		thread_local
   const_cast		for				public			throw
   
   // C++ 操作符替代名
   and				bitand			compl			not_eq				or_eq			xor_eq
   and_eq			bitor			not				or					xor
   ```

4. C++ 标准库保留关键字：

   1. 用户自定义的标识符不能连续出现两个下划线
   2. 不能以下划线紧连大写字母开头
   3. 定义在函数体外的标识符不能以下划线开头



## 二、定义

大多数类型的声明语句同时也进行了定义过程，故变量无需额外进行定义。

### 仅声明变量的方法

对于初学者来说，一个变量通常只在一个源文件中使用。而 C++ 支持分离式编译机制，允许将程序分割为若干个文件，每个文件可以被独立编译。

在程序中只要有变量的声明，我们就能够使用它，并且在将其编译为可重定向目标文件时是不会报错的，编译器只会在链接多个可重定向目标文件时会查找这些声明的定义。

所以，我们完全可以在一个文件中只使用某个变量的声明，而将其定义在其他文件中，其做法就是在只需要声明的变量的声明语句前添加`extern`关键字，并且不要赋予其初始值。

```cpp
int a;				// 声明并定义，一个新的变量
extern int b;		// 仅声明，b 定义在别处
extern int c = 0;	// 在函数外此语句正确，强调此变量具有外部链接；在函数内此语句错误，不允许初始化一个由 extern 关键字标识的变量
```

关于`extern`，具体信息可参考[变量属性](../变量属性/)部分。



## 三、初始化

大部分类型的声明语句不仅同时进行了定义过程，也会同时进行初始化过程，即默认初始化。

某些默认初始化我们可以相信，但大部分内置类型的默认初始化过程将会为变量赋予一个垃圾值，即随机值，无法进行控制，所以通常内置类型还是手动初始化比较好。

另外，还有一些类型不允许默认初始化，必须赋予其初始值，例如引用。

和声明写法一样，初始化也可以在一条语句中对多个变量进行初始化，同一条语句中后初始化的变量可以使用前初始化的变量的值进行初始化，反之不行。即：

```cpp
int a = 2, b = a + 2;
int c = d, d = 2;		// 错误：d 在 c 之后定义并初始化，故 c 不能使用 d 的值进行初始化
```

### 初始化的方法

#### 1. 默认初始化

无需额外指定初始值，即语法与声明语句相同：

```cpp
int a;		// 垃圾值
double b;	// 垃圾值
string s;	// s 为空字符串
```

对支持默认初始化的类型的变量进行默认初始化，变量将被赋予**默认值**。该默认值由类型决定。

对于内置类型而言，通常情况下，定义于任何函数体之外的变量将被初始化为 0，而定义在函数体内部的内置类型变量的值是未定义的，即垃圾值。

对于自定义类来说，每个类各自决定其初始化对象的方式，并决定其是否支持默认初始化，以及默认初始化的行为。



#### 2. 拷贝初始化

大部分类型可以使用`=`进行初始化，称作拷贝初始化：

```cpp
int a = 0;
double b = 3.14;
char *str = "string";
```

:::caution 初始化与赋值的区别

需要格外注意的是在 C++ 中使用等号进行初始化和赋值这二者是完全不同的。

首先从逻辑含义上来说，初始化是在创建变量时赋予其一个初始值，而赋值则是把对象的当前值擦除，而以一个新值来替代。

尽管它们在实现上可能差不多，并且事实上这种区别在 C++ 中有时也根本无关紧要，但我们仍需要区别这两个概念。其必要性在于这个概念将深刻影响你对自定义类的初始化的理解。

:::



#### 3. 直接初始化

还可以使用`()`进行初始化，称作直接初始化：

```cpp
int a(0);
double b(3.14);
string str1("string");
string str2(3, 'c');	// str2 由 3 个字符 c 连接而成
```

需要注意的是对于所有内置类型而言，此初始化方式的区别仅在于符号的改变。

但对于非内置类来说，`()`意味着一个构造函数，它可能和平常的习惯相同，也可能和平常的习惯不同，甚至还可能有多种括号初始化方式，例如上面的`string`类型。

:::caution 直接初始化必须给初始值

直接初始化如果不给初始值，则形如：

```cpp
int a();
string str1();
```

其效果是声明了一个不接受任何参数的函数，而不是初始化。

:::



#### 4. 列表初始化

列表初始化即使用花括号`{}`进行初始化，于此同时还可以添加`=`符号，例如：

```cpp
int a = {0};
double b{3.14};
```

对于内置类型来说，和括号初始化一样，除了初始化的符号改变了之外，几乎没有什么变化。唯一的一个重要特点是：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错：

```cpp
int c{b};		// 错误：b 是 double 类型，赋值给 int 类型将导致浮点部分丢失
```

对于数组等容器类型，列表初始化是为容器类各元素依次初始化的方式，具体的初始化方式将在各容器类型处介绍。



#### 5. 值初始化

通常发生在容器类型只指定元素个数而不指定元素具体内容时。

内置类型初始值自动设为 0；类类型由类默认初始化。

需要注意的是以下两点：

- 容器中元素类型不允许进行默认初始化，即必须提供初始值时，不能使用值初始化
- 使用值初始化时必须使用直接初始化的形式，即圆括号初始化方式