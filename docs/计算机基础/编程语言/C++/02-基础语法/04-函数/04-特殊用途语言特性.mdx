## 一、默认实参

我们可以为函数的参数指定一个默认的实参值，对于有默认实参的函数，如果调用这个函数，那么如果不提供该参数的实参，那么将会使用这个默认实参对其进行初始化。

向函数添加默认实参需要遵循以下原则：

- 默认实参可以在函数声明和函数定义中进行添加
- 局部变量不能作为默认实参，除此之外，只要表达式的类型能够转换成形参所需的类型，该表达式就能作为默认实参。
- 默认实参只能从后往前赋予。
- 可以在后续的函数声明中添加默认实参，但不允许重复添加已经赋予过的默认实参。（函数可以进行多次声明，包括函数定义也包含一次函数声明，这些函数声明需要按从前到后的顺序依次排序，并检查默认实参是否是从后往前依次赋予的）

下面是一个正确的例子：

```cpp
// file1
string screen(double, int, int, char = ' ');					// 提供默认实参的函数声明形参依然可以不取名

// file2
string screen(double ini, int width, int hight = 80, char c);	// 当然，也是可以取名的

// file3
string screen(double = 3.14, int = 24, int, char);				// 注意不能为已经添加过默认实参的形参添加默认实参，且须按照从后往前的顺序。以及可以同时添加多个默认实参
```

需要注意，这些声明理所应当是在不同的文件中，所以在每个函数声明上方标注了文件名表示它们在不同文件中。

如果在同一个文件中的同一个定义域声明这些函数，那么它们将变成一组重载函数，而不是同一个函数。而且这样它们还是一组重载错误的函数。

而如果是在同一个文件中不同定义域声明这些函数，那么首先它们将既不是重载函数，也不是同一个函数。并且这样后续的函数声明的默认实参添加顺序将会出错。

### 调用提供了默认实参的函数

一个提供了默认实参的函数实际上可以看成多个函数，如果默认实参数量为`n`，那么这个函数就可以看成`n+1`个函数。

例如一个如下所示的提供了默认实参的函数：

```cpp
string screen(double, int, int = 80, char = ' ');
```

那么它可以当做 3 个函数，分别如下：

```cpp
string screen(double, int);
string screen(double, int, int);
string screen(double, int, int, char);
```

也就是说可以按照上面 3 种函数中的任意一种形式进行调用。如果调用时为已经添加默认实参的参数重新提供实参值，那么将用调用时提供的实参值作为初始值初始化对应的形参。



## 二、内联函数

调用一个函数存在调用过程，其中会有性能损耗，如果是一些只有一条语句的函数，那么函数调用过程的消耗和函数执行本身的消耗比起来可能会比较显著而无法忽略。

可以将函数定义成内联函数，从而使该函数的调用语句被替换为函数体本身而不必进行函数调用过程。

使用内联函数需要注意以下事项：

- 内联函数只是向编译器发出的一个请求，如果一个函数的函数体明显不支持内联或编译器拒绝将其内联，那么该函数的内联请求将被忽略
- 内联函数需要在声明和定义处都添加`inline`关键字
- 编译一个调用了内联函数的程序时，内联函数的定义必须可见，为了使多个文件调用的内联函数是同一个函数，通常将内联函数定义在头文件中

将`inline`关键字添加到函数定义前就可以声明一个内联函数：

```cpp
inline const string & shorterString(const string &s1, const string &s2)
{
    return s1.size() <= s2.size() ? s1 : s2;
}
```



## 三、constexpr 函数