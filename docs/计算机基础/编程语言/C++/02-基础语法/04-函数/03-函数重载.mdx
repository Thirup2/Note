如果位于同一作用域的的几个同名函数具有不同的参数列表，则称它们是一组**重载函数**，例如：

```cpp
void print(const char *cp);
void print(const int *beg, const int *end);
void print(const int ia[], size_t size);
```

当一个同名函数的参数列表和已有的每一个函数参数列表都不相同时，才可以加入这一组重载函数。

关于如何判断两个参数列表是否相同的方法，将在后面进行介绍。

几乎所有函数都可以进行重载，但`main`函数是不能重载的。

另外，返回类型并不影响是否是重载函数。

## 一、参数列表相同性判断

- 首先判断数量，如果形参列表从参数数量上就不相同，那么它们就是不同的。
- 如果数量相同，但对应位置的形参类型至少有一对不相同，那么它们也是不同的。

> 对于提供了默认实参的函数，它有`n`个默认实参，就相当于有`n+1`个函数被声明了，需要对每一个可能的函数进行上面两步比较。

如果不满足上面两种情况的任意其他情况，那么它们的参数列表就是相同的。

当然，在第二种情况中我们需要判断每一对类型是否相同，其中有一种情况看上去不同，但实际上是相同的：具有顶层`const`的类型和不具有顶层`constl`的类型的形参是相同的。因为无论是否具有顶层`const`，都不影响传入的实参的类型。



## 二、`const_cast`和重载

`const_cast`最大的用途是用在重载函数中。

试想：如果我们想要一个函数既能接受具有底层`const`属性的类型的实参，也能接受不具有底层`const`属性的类型的实参，应该怎么做？

这当然很简单，把这个函数的形参声明为具有底层`const`属性的类型就可以了。

但如果我希望接受底层`const`类型的函数也返回具有底层`const`属性的类型，而不接受底层`const`类型的函数也返回不具有底层`const`属性的类型应该怎么做呢？

此时将它们定义成同一个就行不通了，至少需要两个函数，这时就可以定义两个重载函数了，一个接受底层`const`并返回底层`const`，一个接受非底层`const`并返回非底层`const`。

但即使这样，也并未体现出`const_cast`的必要性，但如果这个函数很长，很多细节需要考虑，基于重复代码尽量只出现一次的原则，我们不应该在两个函数中写出一样的内容，最简单的解决方法就是定义其中一个函数，然后用另一个函数调用它。

也就是说要在某个函数中使用`const_cast`添加或去掉底层`const`属性，而一般我们更倾向于添加底层`const`属性而不是去掉，所以我们通常定义的是接受并返回底层`const`的那个函数，而接受并返回非底层`const`的那个函数则调用前者。

例如：

```cpp
// 定义接受并返回底层 const 的函数
const string &shorterString(const string &s1, const string &s2)
{
    return s1.size() <= s2.size() ? s1 : s2;
}

// 接受并返回非底层 const 的函数通过 const_cast 调用前者
string &shorterString(string &s1, string &s2)
{
    // 添加底层 const 属性并调用前者
    auto &r = shorterString(const_cast<const string&>(s1), const_cast<const string&>(s2));
    // 安全地去掉刚刚添加的底层 const 属性并返回
    return const_cast<string&>(r);
}
```



## 三、函数匹配

当我们调用了一个重载函数之后，将会进行**函数匹配**过程来找到最合适的那个重载函数。

### 1. 匹配结果

函数匹配可能有三种结果：

- 编译器找到一个与实参**最佳匹配**的函数，并生成调用该函数的代码
- 找不到任何一个函数与调用的实参匹配，此时编译器发出**无匹配**的错误信息
- 有多于一个函数可以匹配，但是每一个都不是明显的最佳选择，将发生**二义性调用**的错误信息



### 2. 匹配过程

