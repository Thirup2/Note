## 一、简介

**右值引用**是为了支持移动操作而存在的。它只能绑定到一个将要销毁的对象，因此，我们可以自由地将一个右值引用的资源“移动”到另一个对象中。

我们通过`&&`而不是`&`来获得右值引用，对于常规引用，我们可以称之为**左值引用**。我们不能将一个左值引用绑定到要求转换的表达式、字面常量或是返回右值的表达式。而右值引用则完全相反：我们可以将一个右值引用绑定到这类表达式上，但不能将一个右值引用直接绑定到一个左值上：

```cpp
int i = 42;
int &r = i;					// 正确：r 引用 i
// error-start
int &&rr = i;				// 错误：不能将一个右值引用绑定到一个左值上
int &r2 = i * 42;			// 错误：不能将一个左值引用绑定到一个右值上
// error-end
// highlight-start
const int &r3 = i * 42;		// 正确：我们可以将一个 const 的引用绑定到一个右值上
int &&rr2 = i * 42;			// 正确：将 rr2 绑定到右值上
// highlight-end
```

- 左值：返回左值引用的函数，连同赋值、下标、解引用和前置递增/递减运算符，都是返回左值表达式的例子
- 右值：返回非引用类型的函数，连同算术、关系、位以及后置递增/递减运算符，都生成右值

:::info const引用和右值引用的区别

从它们支持的操作上来说：

- const 引用能够绑定左值、const 左值、右值，但不能修改 const 引用对象的值
- 右值引用只能绑定右值，却能够修改引用对象的值

而如果它们都绑定右值，它们之间的区别则如下：

- const 引用仍然是一个左值引用，虽然它绑定在一个临时量上，但这个临时量无法被修改且生存期被延长到了这个 const 引用被销毁时
- 右值引用绑定的右值也是临时量，这个临时量可以修改但生存期在表达式结束之后即被销毁

:::

总的来说，左值有持久的状态而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。而右值引用只能绑定到临时对象，所以我们可以得知其所引用的对象将要被销毁且该对象没有其他用户。这样的特性意味着使用右值引用的代码可以自由地接管所引用的对象的资源。

:::info 特殊现象

因为变量都是左值，所以我们不能将一个右值引用绑定到变量上，而一个右值引用本身也是一个变量，即左值，所以一个右值引用不能绑定到一个右值引用类型的变量上：

```cpp
int &&rr1 = 42;
// error-next-line
int &&rr2 = rr1;	// 错误
```

:::



## 二、std::move

我们不能直接将一个右值引用直接绑定到一个左值上，但我们可以显式地将一个左值转换为对应的右值引用类型，即使用`std::move`这个标准库函数来获得绑定到左值上的右值引用，此函数定义在头文件`<utility>`中：

```cpp
int &&rr3 = std::move(rr1);
```

调用`move`之后可以将右值引用绑定到一个左值上，但也意味着做出如下承诺：除了对这个左值进行赋值或销毁操作外，我们将不再使用它。



## 三、基于右值引用的函数重载

对于需要使用到元素的拷贝控制操作的函数来说，可以将它们设计成一对重载函数。

通常基于右值引用的重载函数接受的参数都是这样的两种：

- 接受左值引用的版本：`const T&`
- 接受右值引用的版本：`T&&`

接受左值引用的版本通常是`const T&`的，以保证它能够接受`const`的和非`const`的实参，且并不需要对参数的值进行修改。而接受右值引用版本则通常是`T&&`的，因为我们需要修改它的值。



## 四、右值对象和成员函数

通常来说，我们可以对一个类对象调用它的成员函数而无须关心该对象是一个左值还是一个右值：

```cpp
string s1 = "a value", s2 = "another";
auto n = (s1 + s2).find('a');
```

而赋值运算符作为类类型的一个成员函数，也保持这个特性，也就是说，可以对一个右值对象进行赋值操作，例如：

```cpp
s1 + s2 = "wow";
```

在旧标准中，没有办法阻止这种使用方式，而在新标准库为了维持向后兼容性，新标准库仍然允许向右值赋值，也就是说上面的代码到现在仍然是合法的。

### 引用限定符

我们虽然无法改变标准库，但我们肯定希望在自己的类中阻止这样的用法，例如我们希望强制赋值运算符的左侧运算对象（即`this`指向的对象）是一个左值。

指出`this`的左值/右值属性的方式与定义`const`成员函数相同，即在参数列表后放置一个**引用限定符**。和`const`限定符类似，引用限定符只能用于非`static`成员函数，且必须同时出现在函数的声明和定义中，位置在`const`限定符之后。

引用限定符有两种：

- `&`：指定`this`指向的对象是一个左值
- `&&`：指定`this`指向的对象是一个右值

示例如下：

```cpp
class Foo {
public:
    Foo &operator=(const Foo&) &;
};
Foo &Foo::operator=(const Foo &rhs) &
{
    return *this;
}
```

和`const`限定符一样，也可以定义基于引用限定符的重载函数。具体方法参考`const`限定符一节。
