## 一、基本格式

### 1. 移动构造函数

**函数签名**：移动构造函数的第一个参数是该类类型的一个右值引用，且其他任何额外的参数都必须有默认实参。

**函数操作**：将资源移动到`this`对象，并确保移动后源对象处于这样一个状态——销毁它是无害的。特别是，一旦资源完成移动，源对象必须不再指向被移动的资源。

例如：

```cpp
StrVec::StrVec(StrVec &&s) noexcept
    : elements(s.elements), first_free(s.first_free), cap(s.cap)
{
    s.elements = s.first_free = s.cap = nullptr;
}
```

其中`StrVec`有三个指针，分别管理三块资源，很显然，这个类类型的析构函数应该会释放这些资源。而上面的代码执行的操作是先将`this`对象的三个指针接管这三块资源，然后使源对象指向空指针，也就是使源对象处于“销毁它是无害的”这样一种状态，当这个函数结束时，源对象被销毁，将对三个空指针执行释放操作，不会导致新对象管理的资源被销毁。



### 2. 移动赋值运算符

其执行的操作和移动构造函数类似，其基本格式如下：

```cpp
StrVec &StrVec::operator=(StrVec &&rhs) noexcept
{
    if(this != &rhs) {
        free();		// StrVec 的成员函数，释放 this 对象管理的资源
        elements = rhs.elements;
        first_free = rhs.first_free;
        cap = rhs.cap;
        rhs.elements = rhs.first_free = rhs.cap = nullptr;
    }
    return *this;
}
```

仍然需要注意，赋值操作需要防范自赋值的情况。



## 二、noexcept

移动操作“窃取”资源，它通常不分配任何资源。因此，移动操作通常不会抛出任何异常。

而标准库默认情况下会认为移动我们的类对象时可能会抛出异常，从而为了处理这种可能做一些额外的工作，所以我们需要实现通知标准库我们不会抛出任何异常。

一种方法是在函数中使用`noexcept`关键字指明，其位置出现在参数列表之后，对于构造函数来说，其位置出现在参数列表和初始化列表开始的冒号之间。并且`noexcept`应该在声明和定义中都指定`noexcept`：

```cpp
class StrVec {
public:
    StrVec(StrVec&&) noexcept;
};
StrVec::StrVec(StrVec &&s) noexcept : /* 成员初始化器 */
{ /* 构造函数体 */ }
```



## 三、移动语义

一个移动构造函数实际上仍然是在拷贝一些内容，通常对于一个包含管理资源的指针和其他数据成员的类来说，我们在这个类中定义的移动构造函数执行的操作一般是将源对象管理资源的指针值拷贝给新对象的指针，即移动源对象管理的资源。而对于除此之外的其他数据成员，我们或许仍然进行依次拷贝的操作。

而对于一个拷贝语义的构造函数，如果是一个行为类似值的类型，那么通常需要分配新的资源并对资源也进行拷贝；如果是一个行为类似指针的类型，那么它们还是可以指向同一资源，但需要递增它们管理的引用计数，其操作并不是简单的移动。

除此之外，移动构造函数需要保证移动后源对象是有效的（能使用但不能假设其值）、可析构（析构是无害的）的状态。



## 四、合成的移动操作

与拷贝操作不同，编译器根本不会为某些类合成移动操作。例如如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符。换种说法也可以说合成的移动操作有可能是删除的移动操作。

只有当一个类没有定义任何自己版本的拷贝控制成员，且它的所有数据成员都能移动构造或移动赋值时（包括内置类型和定义了移动操作的类类型），编译器才会为它合成移动构造函数或移动赋值运算符。

**显式合成与删除**：

一个拷贝操作会因为数据成员的特性而可能是隐式删除的，而移动操作永远不会隐式定义为删除的函数，即如果不显式定义，那么永远都会隐式地定义合成的移动操作。但一个重要的特性是合成的移动操作有可能是删除的。

实际上这样的概念区分如果一直使用隐式的操作则看不出来什么区别，但如果显式使用`=default`和`=delete`就可以看出区别了。`=delete`仍然是将操作定义为删除的，这点没有什么疑问，重点是`=default`，一个显式定义为`=default`的移动操作，有可能是删除的。

具体遵循如下规则：

- 一个类定义了自己的拷贝构造函数、拷贝赋值运算符或析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符
- 当有类成员定义了自己的拷贝构造函数且未定义移动构造函数，或者是有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数时，类的移动构造函数被定义为删除的。移动赋值运算符的情况类似
- 如果有类成员的移动构造函数或移动赋值运算符被定义为删除的或不可访问的，则类的移动构造函数或移动赋值运算符被定义为删除的
- 如果类的析构函数被定义为删除的或不可访问的，则类的移动构造函数被定义为删除的
- 如果有类成员是`const`的或是引用，则类的移动赋值运算符被定义为删除的

**移动操作对拷贝操作的限制**：

如果定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作。否则，这些成员默认地被定义为删除的。

