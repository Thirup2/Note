## 一、概述

析构函数执行与构造函数相反的操作：构造函数初始化对象的非`static`数据成员，还可能做一些其他工作；析构函数释放对象使用的资源，并销毁对象的非`static`数据成员。

**基本格式**：

析构函数名为`~ClassName`，没有返回值，也不接受参数：

```cpp
class Foo {
public:
    ~Foo();
};
```

因为析构函数不接受参数，因此它不能被重载。

**执行的工作**：

构造函数有一个初始化部分和一个函数体，对于析构函数来说，也有一个函数体和一个析构部分。对于构造函数来说，先执行初始化部分然后执行函数体，对于析构函数来说，先执行函数体然后执行析构部分，析构部分成员按初始化顺序的逆序销毁。

对于析构函数来说，析构部分总是隐式的，成员销毁时发生什么完全依赖于成员的类型，销毁类类型的成员会隐式调用成员自己的析构函数，而内置类型则没有析构函数。

所以析构函数的终点在于函数体部分，一般来说，函数体用来释放对象在生存期分配的所有资源。

**被调用的时机**：

无论何时一个对象被销毁，就会自动调用其析构函数：

- 变量在离开其作用域时被销毁
- 当一个对象被销毁时，其成员被销毁
- 容器（无论是标准库容器还是数组）被销毁时，其元素被销毁
- 对于动态分配的对象，当对指向它的指针应用`delete`运算符时被销毁
- 对于临时对象，当创建它的完整表达式结束时被销毁

**合成的析构函数**：

当一个类未定义自己的析构函数时，编译器会为它定义一个**合成析构函数**。

通常情况下，合成析构函数的函数体都为空，意味着合成析构函数将只对所有成员调用析构函数（内置类型不用）。但其并不管理动态分配的内存资源。

大多数情况下，我们只需要合成的析构函数即可，但如果我们的对象分配了动态内存，就需要自定义析构函数并在函数体内对这些资源进行释放。