---
  slug: /CPP_Language/Data/Data_Type/Basic_Type
---

C++ 的基本内置类型只有两类：**算术类型**（arithmetic type）和**空类型**（void）。其他的内置类型如数组、指针以及引用都是复合类型。

## 一、空类型

空类型是一种特殊的类型，它不对应具体的类型，一般用于在语法上需要一个类型但实际上不需要的地方，比如最常见的是，当函数不返回任何值时使用空类型作为返回类型。



## 二、算术类型

算术类型的含义主要是表示只要属于算术类型下的某个具体类型，它的值都是可以在表达式里直接参与运算的。

算术类型分为两类：**整型**（integral type）和**浮点型**（float type）。其分类依据主要在于整型数和浮点数在存储时的编码不同，在整型中无论是字符型还是布尔类型都和一般整型使用的是相同的编码，只是解释到语言层面之后产生了区别。而浮点数的编码则和整型数的编码有直接的区别，它会将二进制位拆成几个部分，分别表示浮点部分、指数部分和符号部分，所以整型值和浮点型数值在底层需要进行转换。虽然看上去不同的整型值之间也需要进行转换，但实际上它们的编码并没有发生改变。（当然比较特殊的一个是布尔类型，当其他整型转换为布尔类型时，无论之前是什么值，但最后都会变成 0 或 1。主要是因为在逻辑上布尔类型只有一个二进制位，而且其定义和其他整型有所区别，所以涉及到其他整型转换为布尔类型时编码需要进行一些转换，但这是由于 C++ 语言层面的定义区别导致的转换，并非硬件层面需要的转换，所以布尔类型仍然属于整型）。

算术类型的尺寸在不同机器上有所差别，C++ 标准只规定了它们的最小值，如下表所示：

| 类型          | 含义           | 最小尺寸      |
| ------------- | -------------- | ------------- |
| `bool`        | 布尔类型       | 未定义        |
| `char`        | 字符           | 8 位          |
| `wchar_t`     | 宽字符         | 16 位         |
| `char16_t`    | Unicode 字符   | 16 位         |
| `char32_t`    | Unicode 字符   | 32 位         |
| `short`       | 短整型         | 16 位         |
| `int`         | 整型           | 16 位         |
| `long`        | 长整型         | 32 位         |
| `long long`   | 长整型         | 64 位         |
| `float`       | 单精度浮点数   | 6 位有效数字  |
| `double`      | 双精度浮点数   | 10 位有效数字 |
| `long double` | 扩展精度浮点数 | 10 位有效数字 |

### 1. 布尔类型

布尔类型用来表示逻辑运算或关系运算的结果

#### 字面值

- **真**：`true`
- **假**：`false`



### 2. 字符类型

C++ 提供了几种字符类型，除了`char`类型之外，其他几种字符类型都是为了支持国际化而存在的。

<Tabs>

<TabItem value="char" default>

最基本的字符类型是`char`，它使用 ASCII 编码来映射字符与整数值之间的关系。ASCII 码一共 127 个，加上表示空字符的`'\0'`，一共 128 个字符，由于最大值是 127，所以只需要 7 个二进制位就足以表示所有 ASCII 码。而之所以使用 8 个二进制位表示，是因为大多数计算机都以 2 的整数次幂个二进制位作为块来处理内存，可寻址的最小内存块称为 “字节（byte）”，大多数机器的字节由 8 个二进制位组成。

由于`char`类型和一般整型的可转换性，你可以将一个`char`类型当作比`short`还短的整型使用，但实际情况下并不建议这样做。

</TabItem>

<TabItem value="wchar_t" label="宽字符类型">

`wchar_t`类型表示宽字符，这是最初用来支持国际化的字符类型。`wchar_t`并未表明自己使用的是哪一种编码，比较常见的两种是多字节编码和 Unicode 编码。其中多字节编码并非每个字符都是固定的长度比如 UTF-8 编码、GBK 编码等，由于这种编码处理起来可能会产生问题，所以一般都使用`wchar_t`保存 Unicode 编码。Unicode 编码是固定长度的字符编码，包括 UTF-16 和 UTF-32，它们的每个字符分别用 2 个字节或 4 个字节表示。在 C++ 中，`wchar_t`使用的应该是 Unicode 编码，但具体实现为哪一种，在标准中并未规定，一般来说，根据平台或编译器的不同会有不同的实现，故我们不应该假设其为任何一种实现，好在 C++ 的`string`库对不同的字符类型都提供了非常好的描述和实现，可以让我们直接使用抽象好了的`wstring`字符串以及相关操作而不用关心其底层实现。

`char16_t`和`char32_t`则明确地说明了其保存的类型是 UTF-16 和 UTF-32

</TabItem>

</Tabs>

:::danger 请谨慎使用 char 类型表示整数

一般整型都有两类，分别是有符号整型和无符号整型，在默认情况下，`int`、`short`等一般整型都是有符号类型的数，这表示它们有一个二进制位将用来表示数据的符号，于是它们虽然尺寸相同，但表示的数据范围却不相同了。

但`char`类型的默认符号性并未明确定义，也就是说这取决于编译器。`char`类型将可能是`signed char`，也可能是`unsigned char`类型。这表示你可以使用`char`类型表示整数，但为了程序的兼容性以及安全性，在使用`char`类型时，最好保证它所保存的值在 0 - 127 之间。

更好的做法是使用显式声明的`signed char`或者`unsigned char`类型保存整数。

:::

#### 字面值

- `char`类型：用单引号括起来的单个字符是`char`类型字符，如`'a'`；用双引号括起来的零个或多个字符是`char`类型字符串，如`"Hello World!"`。另外，可以在字符串字面值前添加前缀`u8`将字符串保存为 UTF-8 编码的`char`类型字符串，但该前缀只能用于字符串字面值，而不能是字符字面值。

- `wchar_t`类型：如果要将字符或字符串字面值保存为`wchar_t`类型，需要在字符或字符串字面值前添加前缀`L`，如`L'a'`、`L"Hello World!"`

- `char16_t`、`char32_t`类型：在字符或字符串字面值前添加前缀`u`将其存储为`char16_t`类型，添加前缀`U`将其存储为`char32_t`类型，如`u'a'`、`U'a'`、`u"Hello World!"`、`U"Hello World!"`

  :::caution 不同前缀的编码转换

  编译器在处理程序的时候，实际上有两个选项可以会影响到最后保存在可执行文件中的字符或字符串字面值数据的编码，对于 GCC 来说，分别是`-finput-charset`和`-fexec-charset`，其中前者用于告诉编译器当前需要编译的文件所采用的字符集，后者告诉编译器需要将字符或字符串字面值数据按哪种字符集下的编码保存在可执行程序中，如果你将这个字符或字符串字面值数据直接输出而不经过任何处理，则最后输出的就是第二个编译器选项所指定的编码。实际上还有一个选项可以调控`wchar_t`类型具体采用什么实现，就是`-fwide-exec-charset`。关于编译器这方面的内容，可以参考我的博客中的一篇文章：[编程中乱码出现的原因](https://blog.syunn.cn/posts/c77f42f7/)。

  简单来说，编译器会按照`-finput-charset`设定的字符集去识别源文件的内容，然后将其按照`-fexec-charset`设定的字符集保存到可执行文件中，如果这两个设定相同，则字符或字符串编码不会发生任何转换，但如果不同，则编译器会先将字符或字符串字面值编码进行转换，然后再保存到可执行文件中。

  单纯的`char`类型字符或字符串字面值将按照源文件使用的字符集进行编码，而添加了`u8`前缀的`char`类型字符串则会转换为 UTF-8 对应的编码。同理，如果是添加`u`或`U`前缀的`char16_t`和`char32_t`类型的字符或字符串则会转换为 UTF-16 和 UTF-32 进行保存。而添加`L`前缀的`wchar_t`类型的字符或字符串则会保存为 Unicode 对应的编码，但具体是哪一种 Unicode 则根据编译器或系统决定，或者使用`-fwide-exec-charset`进行设定。

  **需要注意的是**：添加前缀并能正确转换字符或字符串字面值编码的前提是编译器能够正确识别源文件的字符或字符串字面值编码，即编译器的`-finput-charset`设定必须和源文件字符集匹配。

  :::

- 转义序列：用于在字符串中表示一些**不可打印**和在 C++ 语言中有特殊含义的字符，具体如下表所示

  | 含义       | 转义序列 |      | 含义       | 转义序列 |      | 含义           | 转义序列 |
  | ---------- | -------- | ---- | ---------- | -------- | ---- | -------------- | -------- |
  | 换行符     | `\n`     |      | 横向制表符 | `\t`     |      | 报警（响铃）符 | `\a`     |
  | 纵向制表符 | `\v`     |      | 退格符     | `\b`     |      | 双引号         | `\"`     |
  | 反斜线     | `\\`     |      | 问号       | `\?`     |      | 单引号         | `\'`     |
  | 回车符     | `\r`     |      | 进纸符     | `\f`     |      |                |          |

  除此之外，还有一类转义序列，即用 ASCII 码来表示其他所有 C++ 程序用到的字符，其又有以下两种形式：

  | 转义序列 | 用法                                                         |
  | -------- | ------------------------------------------------------------ |
  | `\ooo`   | 其中`ooo`表示最多 3 个八进制数字，整个转义序列表示 ASCII 编码中八进制数字`ooo`对应的字符<br />（实际上，`ooo`被限制在`0-377`（对应十进制`0-255`）这个范围内，<br />如果超过该范围，则转义序列会截取一个位数尽量多并且范围合法的数字） |
  | `\xOOO`  | 其中`OOO`表示 1 个或多个十六进制数字，整个转义序列表示 ASCII 编码中十六进制数字`OOO`对应的字符<br />（由于该形式的转义序列没有位数限制，但`char`类型一般只有 8 位，<br />所以如果超过了 8 位所能表示的最大值，则可能会出错） |

  :::info 转义序列的使用

  从形式上来说，转义序列应该等同于一个一般的不带引号的字符，即`\115`等同于`M`。

  如果要将一个转义序列赋值给一个`char`类型字符对象，则需要添加单引号，即`'\115'`和`'M'`。

  字符串同理，需要将转义序列放到一对双引号中，即`"Hello, World\n"`

  :::



### 3. 整数类型

这些整型用于表示（可能）不同尺寸的整数，因为 C++ 只规定了它们的最小尺寸，同时保持一个原则：一个`int`至少和一个`short`一样大，一个`long`至少和一个`int`一样大，一个`long long`至少和一个`long`一样大。

另外，除了`char`类型分为带符号和无符号之外，所有的整数类型也都分为带符号和无符号的。

在默认情况下，`int`、`short`、`long`、`long long`都是带符号的，在它们前面添加上`unsigned`就可以得到无符号的类型，其中`unsigned int`可以缩写为`unsigned`。如果想要明示变量为带符号的，也可以在前面加上`signed`。

:::caution 整数类型的范围

为了表示无符号数，在编码上有几种方法。一种是补码，这是大多数现代计算机使用的方法，使用这种编码方法，如果是 8 位带符号数，则可以表示 -128 - 127 这个范围的数；另外还有反码，8 个二进制位它只能表示 -127 - 127 这个范围的数。

由于编码的不同影响了数的表示范围，所以 C++ 只规定了带符号数的最小范围，比如`signed char`类型被规定为至少能表示 -127 - 127 区间内的数。而由于大多数计算机都使用补码，所以基本上都可以表示 -128 - 127。

我们不能依赖于当前计算机的编码规则，即不能将`signed char`类型的表示范围默认当成 -128 - 127，其他整数类型也是同理。当你要表示的数超过了 C++ 规定的最小范围的边界时，就使用更大的数据类型。

:::

#### 字面值

我们可以将整型字面值写作十进制数、八进制数或十六进制数的形式。以`0`开头的整数代表八进制数，以`0x`或`0X`开头的代表十六进制数。例如，我们可以用下面的任意一种形式表示数值 20：

- 20（十进制）
- 024（八进制）
- 0x14（十六进制）

默认情况下，十进制字面值是带符号数，八进制和十六进制字面值既可能是带符号的也可能是无符号的。十进制字面值的类型是`int`、`long`、`long long`中能容纳字面值并且尺寸最小的那个。而八进制和十六进制字面值的类型是`int`、`unsigned`、`long`、`unsigned long`、`long long`、`unsigned long long`中能容纳字面值并且尺寸最小的那个。如果一个字面值连与之关联的最大的数据类型都放不下，将产生错误。

:::info 提示

不知你有没有想过，字面值类型如此多变，如何才能知道我正在使用的这个字面值是什么类型。实际上，通常我们不需要关心这个字面值的类型，因为我们在使用字面值的时候，总是将其赋值给一个给定类型的变量，如果二者类型不同则会发生类型转换。

一般来说，这个转换不会出问题，我们通常在需要一个变量的时候就已经想好了这个变量要存储的是多大的数，从而选择适合的类型，然后在初始化该变量的时候使用的字面值也是在该范围内的。例如，如果你清楚的知道`unsigned short`可以保存的最大值为 65535 ，那你是不会把 65536 赋值给一个`unsigned short`类型的，我们只会把一个 0 - 65535 之间的整数比如 32 赋值给`unsigned short`，此时虽然 32 是一个`int`类型的字面值，但是`int`到`unsigned short`的转换却并不会出错，因为我们在选择保存 32 的类型的时候已经判断过 32 不会超过`unsigned short`的最大值。

:::

一个默认的整数字面值不可能是`short`类型，也不可能是任何无符号的类型，以及一个没超过`int`最大值的整数字面值默认情况下也不可能是`long`类型，所以为了控制字面值的类型，可以通过添加后缀的方式：

- `u`或`U`：`unsigned`
- `l`或`L`：`long`
- `ll`或`LL`：`long long`

需要注意的是，整数字面值的后缀仅仅改变字面值的最小匹配类型，如果你指定的类型仍然无法保存，则会继续寻找更大的类型保存字面值。其中`u`/`U`后缀会让字面值只在所有无符号类型中查找。



### 4. 浮点型

浮点型可以表示单精度、双精度和扩展精度值，而 C++ 指定了它们的最小精度，之所以选择规定最小精度而不是最小值是因为浮点数和整数的编码表示不一样。浮点数由几部分组成，最主要的就是浮点部分和指数部分，它们之间的位数分配可能会不太一样，而浮点部分的位数则决定了数据的精度，指数部分的位数决定了数据的大小。

通常，`float`以 32 位表示，`double`以 64 位表示，而`long double`则以 96 位或 128 位来表示。一般来说，`float`和`double`分别有 7 和 16 个有效位；`long double`则常常被用于有特殊浮点需求的硬件，它的具体实现不同，精度也各不相同。

看上去`double`以 64 位表示，会让人不太愿意使用这么大的数据来表示浮点数。但实际上执行浮点运算通常选用`double`，这是因为`float`通常精度不够而同时双精度浮点数和单精度浮点数的计算代价相差无几。事实上，对于某些机器来说，双精度运算甚至比单精度还快。而`long double`提供的精度在一般情况下是没有必要的，况且它带来的运行时消耗也不容忽视。

#### 字面值

浮点型字面值表现为一个小数或以科学计数法表示的指数，其中指数部分用`E`或`e`标识：

`3.14159`、`3.14159E0`、`0.`、`0e0`、`.001`

在默认情况下，浮点型字面值是一个`double`，如果想把字面值保存为`float`或`long double`类型，则使用下面的后缀：

- `f`或`F`：`float`
- `l`或`L`：`long double`