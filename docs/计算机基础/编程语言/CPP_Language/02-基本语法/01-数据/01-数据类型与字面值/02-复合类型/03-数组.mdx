## 一、声明定义与初始化

### 1. 声明与定义

数组的声明方式需要用到下标操作符`[]`，如下所示：

```c++
int arr[10];
```

其中`arr`是数组的名字，`10`说明了数组中元素的个数即数组的维度，必须大于 0。

另外，维度必须是一个常量表达式，其必须在编译阶段就获得其值，并为数组分配内存。并且数组一旦被定义，就无法再变更大小。

关于数组的类型，必须明确指定而不允许使用`auto`关键字由初始值列表推断类型，同时数组的元素应为对象，因此不存在引用的数组。



### 2. 初始化

**默认初始化**：默认情况下，数组的元素被默认初始化，即对数组中每个元素执行默认初始化。

**显式初始化**：可以对数组的元素进行列表初始化，此时允许忽略数组的维度。如果忽略数组的维度，则最终创建的数组的元素个数与初始值列表中的元素个数相同；如果指定了数组的维度，则初始值列表中的元素个数不得超过该维度，如果提供的元素个数小于该维度值，则用提供的值从前往后开始初始化，剩下的元素执行值初始化。

**字符数组的初始化**：对于字符数组除了以上的初始化方式外，还可以用字符串字面值对其进行初始化。需要记住的是，一个字符串字面值永远比看到的字符个数多一个位置用于存放空字符，也就是 C 风格的字符串。需要注意的是，该方法实际上是列表初始化的一个特例，所以必须满足列表初始化的要求。

:::caution 关于初始化方式

数组的初始化方式总共就只有以上几种，而并不像`string`或`vector`那样还可以通过拷贝或者构造进行初始化。实际上，数组本身根本不允许拷贝和赋值。

:::



### 3. 复杂的数组声明

数组能存放多数类型的对象，也能声明数组的指针和引用，它们的声明方式比较复杂，但只需要把握一个原则就能完全把握其声明方式，那就是运算符的优先级，例如：

```c++
int *ptrs[10];				// `[]` 的优先级高于 `*`，所以 ptrs 优先与 [] 结合，表示这是一个数组，然后再先后和 *、int 结合，即指向 int 类型的指针的数组
// error-next-line
int &refs[10] = /* ? */;	// 和上面的逻辑相同，这是一个 int 类型的引用的数组，但 C++ 不允许该数组类型，故发生错误
int (*Parray)[10] = &arr;	// 指向 int [10] 类型数组的指针
int (&arrRef)[10] = arr;	// 与 int [10] 类型数组绑定的指针
```



## 二、操作

### 1. 范围 for 语句

数组支持使用范围 for 语句依次访问其元素

```c++
int a[10] = {};
for (int &elem : a) {
    elem = 1;
}
for (int elem : a) {
    cout << elem << endl;
}
```



### 2. 下标访问

数组的下标接受的参数和其他类似，使用数组下标的时候，通常将其定义为`size_t`类型，`size_t`是一种机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象的大小。但这只是推荐使用的类型，我们在使用数组（准确来说是指向数组元素的指针）的时候，还可以使用负值作为下标。

数组除了大小固定这一特点外，其他用法和`vector`基本类似。

同时，我们仍然需要检查下标的值是否越界。



### 3. 指针与数组

**获取指向数组元素的指针**：

在大部分情况下，数组名会隐式转换为指向其元素类型的指针，例如：

```c++
int ia[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
auto ia2(ia);		// ia2 是一个 int * 类型，并指向 ia 中的首元素
```

实际上就是`ia`这个数组名被隐式转换为了指向其元素类型的指针，等价于：

```c++
int *ia2(&ia[0]);
```

但该特点在我们使用`decltype`的时候不会发生，`decltype(ia)`将严格返回一个`int [10]`类型。

另外，如果我们要声明一个指向数组整体的指针，则使用：

```c++
int (*PtA)[10] = &ia;		// 注意此处取地址的方法和 &ia[0]、ia 都不一样，只有这样取地址得到的才是指向一个指向数组的指针
```



**指针作为迭代器**：

指针本身支持的操作可以让我们像用迭代器一样使用指针，实际上迭代器才是模仿指针写出的。

我们可以自行移动指针来获取首指针和尾后指针，但这种方法错误率较高。我们也可以用迭代器库提供的函数来获取，它们都返回指针类型：

```c++
#include <iterator>
using std::begin;
using std::end;

int *pbeg = begin(arr), *pend = end(arr);
while (pbeg != pend && *pbeg >= 0)
    ++pbeg;
```



**指针运算**：

- `*p`：类似于指针解引用。返回指针`p`所指元素的引用
- `p->mem`：类似于指针的类成员访问。接引用`p`并获取该元素的名为`mem`的成员，等价于`(*p).mem`
- `++p`：类似于指针向数组后方移动一个元素。令`p`指向容器中的下一个元素
- `--p`：类似于指针向数组前方移动一个元素。令`p`指向容器中的上一个元素
- `p1 == p2`/`p != p2`：判断两个指针是否相等（不相等），如果两个指针指向的是同一个元素或者它们是同一个容器的尾后指针，则相等；否则则不等。
- `p + n`：运算结果是一个指针，该指针指向原指针向尾部方向移动`n`个元素的位置
- `p - n`：运算结果是一个指针，该指针指向原指针向首部方向移动`n`个元素的位置
- `p1 += n`：将指针向尾部方向移动`n`个元素
- `p1 -= n`：将指针向首部方向移动`n`个元素
- `p1 - p2`：得到`p1`与`p2`的距离，其值的类型为`ptrdiff_t`，定义在`cstddef`头文件中，也是前四个运算中`n`所使用的类型
- `<`、`<=`、`>`、`>=`：指针的大小判断，当同一个容器中某指针所指位置在另一个指针所指位置之前，则指前者小于后者。参与运算的两个指针必须指向同一个容器中的元素或者尾元素的下一位置。
- `p[n]`：等价于`*(p + n)`，返回`p`所指位置后移`n`个位置的元素的引用。

:::caution 关于 p[n]

和其他迭代器不同，指针还允许使用下标运算符，但通常只有当指针指向数组中某元素或数组尾后位置时，该表达式才是有效的，这一点编译器不会进行检查，我们需要自行检查。

而且与其他类自定义的下标运算符不同的是，内置的下标运算允许输入一个负值，只要结果地址指向原来的指针所指同一数组中的元素（或尾后位置）即可：

```c++
int ia[] = {0, 2, 4, 6, 8};
int *p = &ia[2];
int k = p[-2];		// 将 ia[0] 赋值给 k
```

同样，编译器并不会检查访问的地址是否是有效地址，仍需我们自行检查。

:::



## 三、C风格字符串

### 1. 简介

C 风格字符串即使用原生数组实现的字符串，这种字符串将字符依序存放在数组中，并以空字符`\0`作为结束。一般利用指针来操作这些字符串。



### 2. C 标准库字符串操作

在`<cstring>`头文件中提供了一组函数用于操作 C 风格字符串，如下：

- `strlen(p)`：返回字符串指针`p`的长度，空字符不计算在内
- `strcmp(p1, p2)`：比较两个字符串指针`p1`、`p2`的相等性。如果`p1==p2`，返回 0；如果`p1>p2`，返回一个正值；如果`p1<p2`，返回一个负值
- `strcat(p1, p2)`：将`p2`附加到`p1`之后，返回`p1`（**注意**：该函数不检查`p1`的容量，如果`p1`数组的容量不足以容纳两个字符串以及一个空字符的内容，将引发错误）
- `strcpy(p1, p2)`：将`p2`拷贝给`p1`，返回`p1`（**注意**：该函数不检查`p1`的容量，如果`p1`数组的容量小于`p2`字符串的长度以及一个空字符的内容，将引发错误）



### 3. string 类与 C 风格字符串的接口

1. **何处使用 C 风格字符串**

   需要注意的是 C 风格字符串和字符串字面值在 C++ 中是两个概念，虽然字符串字面值实际上也是一个 C 风格字符串，但 C 风格字符串这个词还包括以空字符结束的字符数组，为避免歧义同时减少重复声明，后文也将用 C 风格字符串作为以空字符结束的字符数组的专称，但你应该清楚其还包括字符串字面值。

   在 string 类中，我们常常会用到字符串字面值，而在任何能用到字符串字面值的地方，都可以用 C 风格字符串替代。

2. **string 对象转换为 C 风格字符串**

   在需要 C 风格字符串的地方，我们不能使用一个 string 对象去代替，但可以使用 string 类提供的一个成员函数获得一个指向和 string 对象相同内容的 C 风格字符串的指针。该成员函数为`c_str()`，返回一个`const char *`，如：

   ```c++
   string s("Hello World!");
   const char *str = s.c_str();
   ```

   **需要注意的是**：通过该成员函数获取的 C 风格字符串应该**当时获取当时使用**，因为如果后续的操作改变了用于获取 C 风格字符串的 string 对象的值，则该指针可能会失效。

