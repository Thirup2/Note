---
slug: /CPP_Language/Data/Data_Type/Compound_Type/Pointer
---

## 一、声明定义初始化

**指针**和引用类似，都可以实现对对象的间接访问，但也有不同，即指针是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。

### 1. 声明与定义

声明指针需要将声明符写成`*d`的形式，其中`d`是变量名。如果在一条语句中定义了几个指针变量，则每个变量前都必须有符号`*`：

```c++
int *ip1, *ip2;		// ip1 和 ip2 都是指向 int 类型对象的指针
double dp, *dp2;	// dp2 是指向 double 类型对象的指针，dp 是 double 类型对象
```

和其他变量类似，指针的定义也在声明时默认进行。如果要只进行声明，可以使用`extern`关键字。



### 2. 初始化

如果不进行任何显式的初始化，则指针将执行与内置类型相同逻辑的**默认初始化**，即在函数体外的指针被初始化`nullptr`，而在函数体内则**不被初始化**，意味着其具有一个垃圾值。

如果进行显式初始化，则通常其初始值有三种选择：`nullptr`（字面值）、某对象的地址、另一个指针，如下所示：

```c++
int *p1 = nullptr;	// 字面值作初始值
int ival = 42;
int *p2 = &ival;	// ival 的地址作初始值
int *p3 = p2;		// 另一个指针作初始值
```

**注意**：获取对象的地址使用`&`运算符

当然，或许你觉得还有第四种选择，即手写地址字面值，但这种选择似乎只有地址为 0 时（`nullptr`）有用。



## 二、指针的使用

### 1. 访问

通过指针间接访问对象需要用到**解引用符**（`*`）：（前提是指针确实指向一个对象）

```c++
int ival = 42;
int *p = &ival;
cout << *p;		// 程序输出 42 而非 p 中保存的 ival 的地址
```

使用解引用获得的结果是指针指向的对象，并且是一个左值，故我们可以给解引用的结果赋值，实际上也就是给指针所指的对象赋值：

```c++
*p = 0;			// ival 赋值为 0
cout << *p;		// 此时将输出 0
```



### 2. 其他操作

- **类型转换**：将指针用于条件表达式中，将转换为布尔值。当指针为`nullptr`或`0`时，为`false`，其他情况都是`true`
- **相等性判断**：对于两个类型相同的合法指针，可以用相等操作符（`==`）或不等操作符（`!=`）来比较



## 三、特殊指针类型

### 1. `void*`指针

`void*`是一种特殊的指针类型，可用于存放任意对象的地址。一个`void*`指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址中到底是个什么类型的对象并不了解：

```c++
double obj = 3.14, *pd = &obj;
void *pv = &obj;
pv = pd;
```

其中`pv`分别两次指向了两个不同类型的指针，但都是正确的。

`void*`指针可以和别的指针比较、作为函数的输入或输出，或者赋给另外一个`void*`指针。而不能直接操作`void*`指针所指的对象，因为我们并不知道这个对象到底是什么类型。



### 2. 指向指针的指针

```c++
int ival = 1024;

int *pi = &ival;		// 指向 int 的指针
int **ppi = &pi;		// 指向‘指向 int 的指针’的指针
```

