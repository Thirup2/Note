---
slug: /CPP_Language/Data/Data_Type/Basic_Type
---

C++ 的基本内置类型只有两类：**算术类型**（arithmetic type）和**空类型**（void）。其他的内置类型如数组、指针以及引用都是复合类型。

## 一、空类型

空类型是一种特殊的类型，它不对应具体的值，一般用于在语法上需要一个值但实际上不需要的地方，比如最常见的是，当函数不返回任何值时使用空类型作为返回类型。



## 二、算术类型

算术类型的含义主要是表示只要属于算术类型下的某个具体类型，它的值都是可以在表达式里直接参与运算的。

算术类型分为两类：**整型**（integral type）和**浮点型**（float type）。其分类依据主要在于整型数和浮点数在存储时的编码不同，在整型中无论是字符型还是布尔类型都和一般整型使用的是相同的编码，只是解释到语言层面之后产生了区别。而浮点数的编码则和整型数的编码有直接的区别，它会将二进制位拆成几个部分，分别表示浮点部分、指数部分和符号部分，所以整型值和浮点型数值在底层需要进行转换。虽然看上去不同的整型值之间也需要进行转换，但实际上它们的编码并没有发生改变。（当然比较特殊的一个是布尔类型，当其他整型转换为布尔类型时，无论之前是什么值，但最后都会变成 0 或 1。主要是因为在逻辑上布尔类型只有一个二进制位，而且其定义和其他整型有所区别，所以涉及到其他整型转换为布尔类型时编码需要进行一些转换，但这是由于 C++ 语言层面的定义区别导致的转换，并非硬件层面需要的转换，所以布尔类型仍然属于整型）。

算术类型的尺寸在不同机器上有所差别，C++ 标准只规定了它们的最小值，如下表所示：

| 类型          | 含义           | 最小尺寸      |
| ------------- | -------------- | ------------- |
| `bool`        | 布尔类型       | 未定义        |
| `char`        | 字符           | 8 位          |
| `wchar_t`     | 宽字符         | 16 位         |
| `char16_t`    | Unicode 字符   | 16 位         |
| `char32_t`    | Unicode 字符   | 32 位         |
| `short`       | 短整型         | 16 位         |
| `int`         | 整型           | 16 位         |
| `long`        | 长整型         | 32 位         |
| `long long`   | 长整型         | 64 位         |
| `float`       | 单精度浮点数   | 6 位有效数字  |
| `double`      | 双精度浮点数   | 10 位有效数字 |
| `long double` | 扩展精度浮点数 | 10 位有效数字 |

### 1. 布尔类型

布尔类型用来表示逻辑运算或关系运算的结果，其结果只有两个分别是**真**（true）与**假**（false）。



### 2. 字符类型

C++ 提供了几种字符类型，除了`char`类型之外，其他几种字符类型都是为了支持国际化而存在的。

<Tabs>

<TabItem value="char" default>

最基本的字符类型是`char`，它使用 ASCII 编码来映射字符与整数值之间的关系。ASCII 码一共 127 个，加上表示空字符的`'\0'`，一共 128 个字符，由于最大值是 127，所以只需要 7 个二进制位就足以表示所有 ASCII 码。而之所以使用 8 个二进制位表示，是因为大多数计算机都以 2 的整数次幂个二进制位作为块来处理内存，可寻址的最小内存块称为 “字节（byte）”，大多数机器的字节由 8 个二进制位组成。

由于`char`类型和一般整型的可转换性，你可以将一个`char`类型当作比`short`还短的整型使用，但实际情况下并不建议这样做。

:::danger 请谨慎使用 char 类型表示整数

一般整型都有两类，分别是有符号整型和无符号整型，在默认情况下，`int`、`short`等一般整型都是有符号类型的数，这表示它们有一个二进制位将用来表示数据的符号，于是它们虽然尺寸相同，但表示的数据范围却不相同了。

但`char`类型的默认符号性并未明确定义，也就是说这取决于编译器。`char`类型将可能是`signed char`，也可能是`unsigned char`类型。这表示你可以使用`char`类型表示整数，但为了程序的兼容性以及安全性，在使用`char`类型时，最好保证它所保存的值在 0 - 127 之间。

更好的做法是使用显式声明的`signed char`或者`unsigned char`类型保存整数。

:::

</TabItem>

<TabItem value="wchar_t" label="宽字符类型">

`wchar_t`类型表示宽字符，这是最初用来支持国际化的字符类型。`wchar_t`并未表明自己使用的是哪一种编码，比较常见的两种是多字节编码和 Unicode 编码。其中多字节编码并非每个字符都是固定的长度比如 UTF-8 编码、GBK 编码等，由于这种编码处理起来可能会产生问题，所以一般都使用`wchar_t`保存 Unicode 编码。Unicode 编码是固定长度的字符编码，包括 UTF-16 和 UTF-32，它们的每个字符分别用 2 个字节或 4 个字节表示。

`char16_t`和`char32_t`则似乎明确地说明了你应该将 UTF-16 和 UTF-32 的编码保存在这两种类型中。

:::caution 注意

如果你使用过 Windows 进行编程并处理过中文字符，相信你应该多多少少遇到过乱码问题。这里说明几个编程过程中的关键点：

1. 当你在程序中声明字符或字符串常量时，它们会被保存为什么编码取决于你的文件使用的编码而不在于你使用的字符类型，所以即使你使用了`wchar_t`甚至`char16_t`、`char32_t`这种明确了保存字符编码的类型，它们所保存的仍然是你的文件对应的字符编码。

2. 千万不要因为上一点所说的原因就将文件的编码改为 UTF-16 然后在程序中使用`char16_t`或`wchar_t`类型（UTF-32 和`char32_t`同理），因为程序最终输出是否乱码还取决于你终端的字符集。中国地区的 Windows 几乎都是 GBK 编码，将使用 UTF-16 保存的编码通过 GBK 编码的终端解释毫无疑问还是会产生乱码。

   而且由于 GBK 是一种多字节编码，所有的多字节编码基本上都有一个特点就是从 0 - 127 的这些字符和 ASCII 编码完全相同。而 UTF-16 是固定 2 字节编码，在 ASCII 码中的所有字符在 UTF-16 中的表示都不相同，这将导致程序在编译阶段，编译器读取文件的时候就会出错，因为代码基本上都是用 ASCII 码中的字符写的。

3. 更不要因为第 2 点所说的原因就去修改终端的编码环境。首先，这是一种很不好的行为，我们应该永远修改程序本身而不是环境，因为即使修改环境让程序正确运行了，也无法保证它可以在其他电脑上运行，难道让每个运行程序的用户都去修改自己的终端环境？

   其次，UTF-16 和 UTF-32 由于采用了每个字符都固定编码长度的表示方法，所以它们比起多字节编码来说肯定会多占用很多空间，导致空间的浪费，所以现在最常用的还是将文件保存为 UTF-8 编码。

   另外，就算无论如何你都还是决定将终端编码环境改成 UTF-16 或 UTF-32，如果文件编码使用 UTF16 或 UTF-32，那么肯定可以预测的是你无法再在你的程序里使用普通的`char`类型，这两种编码的大部分字符很有可能含有`'\0'`字节，这标记着普通`char`类型字符串的结束。

:::

:::info 如何避免乱码同时处理 Unicode 字符

由于上面所说的三个原因，所以看上去似乎没有一个很好的解决办法。但实际上是有的：

1. 在编译前将文件编码转换成终端编码，这样基本上程序可以避免乱码问题。实际上这个方法也并不算好，因为这样你就没有选择的余地，在程序中你就只能用`wchar_t`保存 GBK 编码（其他地区则是其他代码页），并且处理 GBK 编码。
2. 在遇到任何字符串的时候都将编码进行转换。比如，如果你要声明并保存一个字符串常量，你可以先将这个字符串常量从文件编码转换为你要处理的编码；当你要处理输入输出的时候，你可以将待输出字符串先转换为终端编码再进行输出，将待输入字符串先转换为你要处理的编码再进行保存。这种方法看上去过程比较繁琐，但实际上 C++ 标准库就提供了编码转换的函数，如果你进行 Windows 编程，Win32 API 中也有针对编码转换的函数。

:::

</TabItem>

</Tabs>



### 3. 整数类型

这些整型用于表示（可能）不同尺寸的整数，因为 C++ 只规定了它们的最小尺寸，同时保持一个原则：一个`int`至少和一个`short`一样大，一个`long`至少和一个`int`一样大，一个`long long`至少和一个`long`一样大。

另外，除了`char`类型分为带符号和无符号之外，所有的整数类型也都分为带符号和无符号的。

在默认情况下，`int`、`short`、`long`、`long long`都是带符号的，在它们前面添加上`unsigned`就可以得到无符号的类型，其中`unsigned int`可以缩写为`unsigned`。如果想要明示变量为带符号的，也可以在前面加上`signed`。

:::caution 整数类型的范围

为了表示无符号数，在编码上有几种方法。一种是补码，这是大多数现代计算机使用的方法，使用这种编码方法，如果是 8 位带符号数，则可以表示 -128 - 127 这个范围的数；另外还有反码，8 个二进制位它只能表示 -127 - 127 这个范围的数。

由于编码的不同影响了数的表示范围，所以 C++ 只规定了带符号数的最小范围，比如`signed char`类型被规定为至少能表示 -127 - 127 区间内的数。而由于大多数计算机都使用补码，所以基本上都可以表示 -128 - 127。

我们不能依赖于当前计算机的编码规则，即不能将`signed char`类型的表示范围默认当成 -128 - 127，其他整数类型也是同理。当你要表示的数超过了 C++ 规定的最小范围的边界时，就使用更大的数据类型。

:::



### 4. 浮点型

浮点型可以表示单精度、双精度和扩展精度值，而 C++ 指定了它们的最小精度，之所以选择规定最小精度而不是最小值是因为浮点数和整数的编码表示不一样。浮点数由几部分组成，最主要的就是浮点部分和指数部分，它们之间的位数分配可能会不太一样，而浮点部分的位数则决定了数据的精度，指数部分的位数决定了数据的大小。

通常，`float`以 32 位表示，`double`以 64 位表示，而`long double`则以 96 位或 128 位来表示。一般来说，`float`和`double`分别有 7 和 16 个有效位；`long double`则常常被用于有特殊浮点需求的硬件，它的具体实现不同，精度也各不相同。

看上去`double`以 64 位表示，会让人不太愿意使用这么大的数据来表示浮点数。但实际上执行浮点运算通常选用`double`，这是因为`float`通常精度不够而同时双精度浮点数和单精度浮点数的计算代价相差无几。事实上，对于某些机器来说，双精度运算甚至比单精度还快。而`long double`提供的精度在一般情况下是没有必要的，况且它带来的运行时消耗也不容忽视。