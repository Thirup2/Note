## 一、类型别名

### 1. 变量类型

在讨论类型别名之前我们需要先搞清楚一个变量的类型如何观察。

直接说结论，一个变量的类型就是除了标识符之外的其他部分，例如：

```cpp
int i;				// int 类型
int *p;				// int* 类型
int &r;				// int& 类型
const int *pci;		// const int* 类型
int *const cpi;		// int *const 类型
int iarr[10];		// int [10] 类型
int *parr[10];		// int *[10] 类型
```

可以看到，将声明语句中的标识符去掉就是这个变量的类型。



### 2. 定义类型别名

**typedef 定义**：

使用`typedef`定义类型别名的方法和声明一个变量的方法几乎相同，只需要在整个声明语句前添加一个`typedef`关键字，原先声明语句中的标识符就成了其类型的类型别名，例如：

```cpp
typedef int Int;			// Int = int
typedef int *PtrInt;		// PtrInt = int *
typedef int *PtrArr[10];	// PtrArr = int *[10]
```

**using 定义**：

使用`using`定义类型别名的方法就跟上面代码中注释中的表示方法相同，只需在前添加一个`using`关键字即可：

```cpp
using Int = int;
using PtrInt = int *;
using PtrArr = int *[10];
```

**注意**：

还有一种使用宏定义的方法也可以做到类似于类型别名的效果，但二者有着根本的区别。

宏定义是在编译时的预处理阶段就将所有用到 “类型别名” 的地方替换成宏的值，例如：

```cpp
#define PtrInt int *
PtrInt p, q, w;		// 替换成 int * p, q, w;
```

最终就只有`p`是`int *`类型，其他都是`int`类型。

而类型别名则不会这样，类型别名是一种类型，它平等的作用于声明列表中的每一个标识符，例如：

```cpp
using int * = PtrInt;
PtrInt p, q, w;		// 不会替换，PtrInt 平等作用于 p, q, w 三者
```

则`p`，`q`，`w`都将是`int *`类型。



## 二、auto 类型说明符

用`auto`替代类型名用在表达式中，可以让编译器分析表达式所属的类型。由于`auto`通过初始值推算变量的类型，所以`auto`定义的变量**必须有初始值**。

### 1. 基本推断

```cpp
auto ival = 42;				// ival 推断为 int
double dval = 3.14;
auto item = dval + ival;	// item 推断为 double
```

另外，使用`auto`也能在一条语句中声明多个变量，但因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样：

```cpp
auto i = 0, *p = &i;		// 正确：auto 可以直接用 int 替换
// error-next-line
auto sz = 0, pi = 3.14;		// 错误：auto 无法只用一种类型适配这两种字面值
```

正如注释中所说的那样，判断一个使用`auto`的多变量声明语句是否正确，就看`auto`用某个类型替换能否适用于所有字面值



### 2. 复合类型、常量和 auto

**引用与 auto：**

当初始值是一个引用时，`auto`将根据引用绑定的对象的类型进行推断：

```cpp
int i = 0, &r = i;
auto a = r;			// a 推断为 int 类型
```

如果确实要用`auto`声明一个引用，则添加`&`声明符：

```cpp
auto &a = r;		// a 为 int& 类型
```



**常量与 auto：**

`auto`一般会忽略掉顶层`const`，而保留底层`const`：

```cpp
int i = 42;
const int ci = 1024;
const int *const p = &ci;

auto i2 = ci;		// i2 推断为 int 类型
auto pi = &i;		// pi 推断为 int * 类型
auto pci = &ci;		// pci 推断为 const int * 类型
auto pci2 = p;		// pci2 推断为 const int * 类型
```

另外，当用`auto`声明引用时，只有初始值为常量对象或常量引用时，`auto`可推断为常量引用类型，其他情况（常量表达式、非常量对象、非常量表达式以及字面值）都将被推断为非常量引用，故会发生错误：

```cpp
const int i = 42;
const int &ri = i;

auto &r1 = ri;		// auto & = const int &
auto &r2 = i;		// auto & = const int &
// error-next-line
auto &r3 = 42;		// 错误：auto & = int &
```

如果希望推断出来的`auto`是一个顶层`const`或者是一个常量引用，可以显式使用`const`进行声明：

```cpp
const auto cpi = &i;	// 此时 cpi 是 int *const 类型
const auto cpci1 = &ci;	// 此时 cpci1 是 const int *const 类型
const auto cpci2 = p;	// 此时 cpci2 是 const int *const 类型

const auto &r4 = 42;	// 此时 r4 推断为一个常量引用
```



## 三、decltype 类型指示符

**基本用法：**

在使用`auto`的时候需要提供初始值并对变量进行初始化，但有时我们希望能只根据表达式判断类型而不作为初始值，`decltype`就能做到这件事：

```cpp
decltype(f()) sum = x;		// sum 的类型是函数 f 的返回类型
```

`decltype`的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。

**原则：**

`decltype`将严格返回其操作数的类型，但也有需要注意的情况，具体的分类如下：

- 当`decltype`使用的表达式是一个变量，则`decltype`返回包括顶层`const`和引用在内的该变量的类型
- 若`decltype`使用的表达式不是一个变量，则`decltype`返回表达式结果对应的类型。其中比较特殊的是当表达式的结果是一个左值时，返回对应类型的引用。

**举例：**

```cpp
int i = 42, &r = i;
const int *const p = &i;

decltype(p) ...;		// 返回 const int *const 类型
decltype(r) ...;		// 返回 int & 类型
    
decltype(i) ...;		// 返回 int 类型
decltype(i * 2) ...;	// 返回 int 类型
decltype((i)) ...;		// 返回 int & 类型，(i) 是一个左值表达式
```

