---
slug: /CPP_Language/Object/const&constexpr
---

## 一、常量的声明与定义

通过`const`关键字我们可以声明并定义一种值不能改变的变量，即：

```c++
const int bufSize = 512;
```

这样`bufSize`就被定义成了一个常量。任何试图为`bufSize`赋值的行为都将引发错误：

```c++
// error-next-line
bufSize = 512;		// 错误：试图向 const 对象写值
```

和引用类似，由于`const`对象一旦创建后其值就不能再改变，所以`const`对象必须初始化。初始值可以是任意复杂的表达式：

```c++
const int i = get_size();
const int j = 42;
// error-next-line
const int k;		// 错误：k 未经初始化
```

`const`对象在初始化时并不会发挥其常量的作用，所以能够对其进行初始化，直到初始化完成，`const`对象才具有了常量的特征。

**`const`对象的链接属性**：

当初始化一个`const`对象所使用的初始值在编译时就能获取时，编译器会在编译过程就将所有用到该`const`对象的地方用这个值替换。为了执行上述替换，编译器必须知道变量的初始值。如果程序包含多个文件，则每个用了`const`对象的文件都必须得能够在编译阶段访问到它的初始值才行。要做到这一点，必须在每一个用到变量的文件中都有对它的定义。为了支持这一用法，同时避免对同一变量的重复定义，默认情况下，`const`对象被设定为仅在文件内有效，即默认为内部链接属性。

但有时`const`变量的初始值并非常量表达式，即无法在编译阶段就获取其值，同时又有必要在文件间共享，这种情况下，我们不希望编译器为每个文件分别生成独立的变量。此时在`const`变量定义处添加`extern`关键字，可以使其变为外部链接属性，然后在每一个用到该变量的地方都用`extern`进行声明，表示此处是一个纯声明而非定义同时表示此处声明的`const`变量定义在别处，使编译器去别处查找定义。简单来说，就是对于`const`变量不管是声明还是定义都添加`extern`关键字：

```c++ title="file1.cc"
extern const int bufSize = fcn();		// 声明并定义，同时具有外部链接属性
```

```c++ title="file2.cc"
extern const int bufSize;			// 仅声明，同时表示定义在别处
```



## 二、对 const 的引用

一个形如`const int &`类型的引用就是一个对`const`的引用。

一个常量引用的初始化可以用任意表达式作为初始值，只要该表达式的结果能够转换成引用的类型即可，例如：

```c++
const int i1 = 1024;
int i2 = 42;

const int &r1 = i1;		// 类型完全相同，可以绑定
const int &r2 = i2;		// 正确
const int &r3 = r1 * 2;	// 正确
const int &r4 = 42;		// 正确
```

在以上代码中，最后三行中的初始化语句对于一般的引用都是不合法的，但对于常量引用来说却是合法的。但实际上，常量引用的初始化也并未违背必须绑定到类型完全相同的对象上这一原则，因为对于常量引用的初始化实际上进行了两步操作，首先如果右侧表达式并非对象或与左侧引用类型不完全相同时，编译器会创建一个与左侧引用类型完全相同的**临时对象**并用右侧的表达式对该临时对象进行初始化，然后再将引用绑定到这个临时对象上。

而非常量引用之所以不用**临时对象**的方法来使其他初始化方式变得合法，是因为对于非常量引用，我们总会通过引用改变绑定对象的值，如果此时绑定的是一个临时对象，那改变也就没有了意义。



## 三、const 和指针

### 1. 声明与定义

由于指针指向的对象是一个实体，指针本身也是一个实体，所以我们可以分别指定哪一个实体是常量或都是常量：

```c++
int a = 1024;

int *p1 = &a;				// 普通指针
const int *p2 = &a;			// 指向常量的指针
int *const p3 = &a;			// 指向非常量的常量指针
const int *const p4 = &a;	// 指向常量的常量指针
```

根据`const`所在的位置，我们可以判断该指针本身是一个常量还是表示其所指的对象是一个常量（对该指针而言）。如果`const`和基本类型`int`结合，则说明指针所指的对象是一个常量（对该指针而言），而如果`const`和指针的标识符相结合，则说明指针本身是一个常量，也就意味着必须进行初始化且无法改变指向。



### 2. 顶层 const

由于指针可以用来直接或间接的表示两个对象，所以用**顶层 const** 表示指针本身是个常量，而用**底层 const** 表示指针所指的对象是一个常量（对该指针而言）。

更一般地，顶层`const`可以表示任意的对象是常量，对于任何数据类型都适用，底层`const`则与指针和引用等复合类型的基本类型部分有关。

对于引用来说，由于其本身不具有实体，即不可能为顶层`const`，所以只有可能具有底层`const`。

**原则**：当执行对象的拷贝操作时，对于顶层`const`来说没有影响，对于底层`const`来说拷入和拷出的对象必须具有相同的底层`const`，或者两个对象的数据类型必须能够转换，一般来说，非常量可以转换成常量，反之则不行。

具体而言，对于顶层`const`来说，当其作为被拷贝对象时，无论左侧是否是顶层`const`，都能够拷贝成功；当其作为拷入对象时，由于常量的性质将无法成功，但如果是在初始化阶段，无论右侧是否具有顶层`const`，也都会成功。

而对于底层`const`而言，则需要类型完全相同或者能够转换。当一个具有底层`const`的对象放在等号左侧时，右侧的对象就必须也是一个具有底层`const`或者能够转换的类型，如果右侧是对一个常量取地址，则得到的就是一个具有底层`const`的指针，如果右侧对一个非常量取地址，则得到一个不具有底层`const`的指针，但其可以转换为具有底层`const`的指针。而如果一个具有底层`const`的对象放在等号右侧，那么左侧就必须是一个具有底层`const`的对象。



## 四、constexpr 和常量表达式

### 1. 简介

**常量表达式**：是指值不会改变并且在编译过程就能得到计算结果的表达式。

如前所述，`const`常量实际上有两类，一类是用常量表达式初始化的，则该`const`常量也是常量表达式，可以在编译阶段就得到结果；另一类则是只有在程序执行过程中才能知道其值，包括将其定义为外部链接的情况也是如此。

但 C++ 语言中有几种情况下是要用到常量表达式的，而有时我们无法判断或不想花时间去判断一个`const`是否是常量表达式，于是 C++ 新增了一个`constexpr`类型，这种类型一定是常量表达式，换言之，如果不用常量表达式去初始化，则会出错。



### 2. 声明与定义

`constexpr`和`const`的用法基本一致：

```c++
constexpr int mf = 20;
constexpr int limit = mf + 1;
constexpr int sz = size();		// 只有当 size 是一个 constexpr 函数时才正确
```

**constexpr 与指针：**

需要注意`constexpr`用在指针上和`const`用在指针上是有区别的，`constexpr`只用于说明指针是一个常量，所以：

```c++
constexpr int *pi = nullptr;
```

表示的是`pi`是一个指针类型的常量表达式，而非其所指对象的，如果要将其指向对象设置为常量（对该指针而言），则像下面这样：

```c++
constexpr const int *pi = &i;
```



### 3. 初始值与字面值类型

用于初始化一个`constexpr`的初始值必须是一个常量表达式，而一些类型不可能被定义成常量表达式，例如 IO 库和 string 类。

所以用**字面值类型**表示可以定义成`constexpr`的类型，包括算术类型、引用和指针。

而用于初始化一个`constexpr`的初始值必须是一个常量表达式，对于指针来说必须是`nullptr`、`0`或者某个固定地址中的对象。
