---
slug: /CPP_Language/Object/const&constexpr
---

## 一、常量的声明与定义

通过`const`关键字我们可以声明并定义一种值不能改变的变量，即：

```c++
const int bufSize = 512;
```

这样`bufSize`就被定义成了一个常量。任何试图为`bufSize`赋值的行为都将引发错误：

```c++
// error-next-line
bufSize = 512;		// 错误：试图向 const 对象写值
```

和引用类似，由于`const`对象一旦创建后其值就不能再改变，所以`const`对象必须初始化。初始值可以是任意复杂的表达式：

```c++
const int i = get_size();
const int j = 42;
// error-next-line
const int k;		// 错误：k 未经初始化
```

`const`对象在初始化时并不会发挥其常量的作用，所以能够对其进行初始化，直到初始化完成，`const`对象才具有了常量的特征。

**`const`对象的链接属性**：

当初始化一个`const`对象所使用的初始值在编译时就能获取时，编译器会在编译过程就将所有用到该`const`对象的地方用这个值替换。为了执行上述替换，编译器必须知道变量的初始值。如果程序包含多个文件，则每个用了`const`对象的文件都必须得能够在编译阶段访问到它的初始值才行。要做到这一点，必须在每一个用到变量的文件中都有对它的定义。为了支持这一用法，同时避免对同一变量的重复定义，默认情况下，`const`对象被设定为仅在文件内有效，即默认为内部链接属性。

但有时`const`变量的初始值并非常量表达式，即无法在编译阶段就获取其值，同时又有必要在文件间共享，这种情况下，我们不希望编译器为每个文件分别生成独立的变量。此时在`const`变量定义处添加`extern`关键字，可以使其变为外部链接属性，然后在每一个用到该变量的地方都用`extern`进行声明，表示此处是一个纯声明而非定义同时表示此处声明的`const`变量定义在别处，使编译器去别处查找定义。简单来说，就是对于`const`变量不管是声明还是定义都添加`extern`关键字：

```c++ title="file1.cc"
extern const int bufSize = fcn();		// 声明并定义，同时具有外部链接属性
```

```c++ title="file2.cc"
extern const int bufSize;			// 仅声明，同时表示定义在别处
```



## 二、对 const 的引用

一个形如`const int &`类型的引用就是一个对`const`的引用。

一个常量引用的初始化可以用任意表达式作为初始值，只要该表达式的结果能够转换成引用的类型即可，例如：

```c++
const int i1 = 1024;
int i2 = 42;

const int &r1 = i1;		// 类型完全相同，可以绑定
const int &r2 = i2;		// 正确
const int &r3 = r1 * 2;	// 正确
const int &r4 = 42;		// 正确
```

在以上代码中，最后三行中的初始化语句对于一般的引用都是不合法的，但对于常量引用来说却是合法的。但实际上，常量引用的初始化也并未违背必须绑定到类型完全相同的对象上这一原则，因为对于常量引用的初始化实际上进行了两步操作，首先如果右侧表达式并非对象或与左侧引用类型不完全相同时，编译器会创建一个与左侧引用类型完全相同的**临时对象**并用右侧的表达式对该临时对象进行初始化，然后再将引用绑定到这个临时对象上。

而非常量引用之所以不用**临时对象**的方法来使其他初始化方式变得合法，是因为对于非常量引用，我们总会通过引用改变绑定对象的值，如果此时绑定的是一个临时对象，那改变也就没有了意义。



## 三、const 和指针

