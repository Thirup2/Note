## 一、值的类型

在 C++ 中有两种类型的值，分别是左值和右值。C++ 的表达式要不然是**左值**，要不然就是**右值**。

在 C++ 中，如果一个表达式的求值结果是一个对象并且将其以**对象的身份**（在内存中的位置）的形式使用时，这个表达式就是一个左值，例如最简单的变量名，还有对指针解引用的表达式等等；而其他情况则认为表达式是一个右值，包括一个对象以**对象的值**（对应内存中的内容）的形式使用的情况。

通常左值也可以当成右值使用，但右值则不一定可以当成左值使用。

:::info C 语言中的左值和右值

C++ 中的左值和右值实际上本身就继承于 C 语言中的这两个词，但定义却有所区别。

在 C 语言中这两个词只是为了帮助记忆：左值可以位于赋值语句的左侧，而右值不能。

在 C++ 中，很明显定义不同，主要有两个不同点：

1. 在 C 语言中，左右值独立于表达式而存在，我们不需要一个具体的表达式就能判断一个表达式是左值还是右值；而在 C++ 中，左右值依附于具体的表达式，根据表达式的不同而对左右值有所区分，比如在`a = b`中`a`就是一个左值，而在`c = a`中`a`就是一个右值。

2. 在 C++ 中，有时左值并不能作为赋值语句的左侧运算对象，例如常量对象。

   实际上，C++ 并不以赋值语句作为判断左右值的标准，C++ 中的每一个运算符都明确定义了需要的值的类型，只要是在需要左值的地方能够使用的对象就是一个左值。例如递增递减运算符就需要一个左值对象，此时如果`a++`成立，则`a`就是一个左值。

:::



## 二、表达式求值

一个表达式由任意数量的操作符以及操作符需要的操作数或者操作对象组成，通常在使用中只包含一个操作符和对应数量的操作数的表达式用得很少。

因此，理解一个复合表达式如何求值就非常重要了。

运算符是一个表达式的核心，和运算符相关的**优先级**、**结合律**以及**运算对象的求值顺序**对最终求值的结果都有影响。而与运算对象相关的**类型转换**也对求值结果有相当的影响。

### 1. 优先级

在一个包含多个不同优先级的运算符的表达式中，运算符的优先级决定了哪些运算对象应该优先匹配在一起，例如：

```cpp
6 + 3 * 4 / 2 + 2
```

其中`*`和`/`的优先级相同且最高，所以结果是`3`和`4`优先匹配，而非`6`和`3`优先匹配。

:::danger 为什么不是优先执行？

之所以采用了 “运算符的优先级决定了哪些运算对象应该优先匹配在一起” 的说法而非 “哪一个运算符应该优先执行” 的说法是因为 C++ 的标准并未规定优先级高的运算符要比优先级低的运算符先求值，优先级只用来确定哪个运算符周围的运算对象应该优先匹配在一起，但并不求值。

当然，由于这个特点，也导致了一部分后文中所述的求值顺序的问题。

:::



### 2. 结合律

**对相同运算符而言**：

在一串多个相同操作符的表达式中，运算符的结合律决定了哪一个运算符周围的运算对象先匹配在一起，例如：

```cpp
1 + 2 + 3 + 4
```

由于`+`具有左结合律（即从左往右），所以`1`和`2`先被匹配在一起，而不是`2`和`3`。

包括最常用的输入输出运算符：

```cpp
cin >> v1 >> v2;
cout << v1 << v2;
```

由于其也具有左结合律，所以输入流中的内容将从左到右依次给到表达式给出的对象中，输出表达式中的对象也将从左到右依次写入到输出流中。

**对相同优先级的运算符而言**：

另外，由于相同优先级的运算符通常具有相同结合律，所以可以将这个规律推广为：在一串具有多个相同优先级的操作符的表达式中，运算符的结合律可以决定哪一个运算符周围的运算对象先匹配在一起：

```cpp
1 + 2 - 3 + 4
```

该表达式还是从左往右依次匹配

:::danger 结合律也不决定运算符的执行顺序

和优先级一样，运算符的结合率也并不会导致最先匹配的两个运算对象最先求出值来。

:::



### 3. 求值顺序

运算符还有一个属性叫做运算对象的求值顺序，需要注意**运算对象的求值顺序**实际上是**运算符**的属性而非运算对象的属性。

这个求值顺序决定了**一个运算符**支配的运算对象的求值顺序，上述的两个属性都是在多个运算符构成的表达式上发挥作用，而这个属性则是针对一个运算符而言的。

如字面意思，**求值顺序规定了一个运算符所支配的运算对象哪一个先进行求值**。

如果你用`1 + 2`这个简单的例子去思考这个属性的意义，那你很有可能会搞不明白这个属性的作用。所以我们以另一个简单例子为例：

```cpp
(1 - 1) + (2 - 3)
```

此时`+`两边都不再是简单的数字，而是另一个表达式（实际上即使不加括号也可以看成整体）。而`+`的求值顺序则规定了`(1 - 1)`和`(2 - 3)`哪一个先执行。

即使这样，你可能还是觉得这个求值顺序可有可无，毕竟无论哪一个先求值，答案都一样，所以下面举了一个求值顺序可能会影响到求值结果的例子：

```cpp
int i = 0;
cout << i << " " << ++i << endl;
```

其中如果提前对`++i`进行求值，那么最先输出的`i`则也会发生变化。该表达式的本意是先输出`i`的现值，然后再对`i`递增并输出递增后的值，但在实际情况下，该表达式的求值是否按照预想顺序进行则是未定义的，有可能满足你的预想，也有可能先对`++i`求值然后开始依次输出。这一切都源自于`<<`运算符并未规定其操作对象的求值顺序（实际上大部分运算符都未规定）。

:::danger 求值顺序的影响

如果前面的内容你并没有搞清楚，那你可能会疑惑这个例子为什么会引起未定义问题，你可能会想明明`++`运算符的优先级最高，应该已经先执行了，然后才是`<<`运算符从左往右依次执行，顶多只是在每一次的输出操作中需要决定左操作数和右操作数谁先执行罢了，在这个例子中完全没有影响才对。

但实际上正如我在优先级和结合律这两节的警告栏中所写的那样，优先级和结合律并不会对表达式进行求值，而只是将操作对象进行匹配。

匹配完成后，再由编译器决定应该如何求值，在上面的例子中，它可能从左往右依次一边求值一边执行输出操作，也有可能先将表达式中所有相对独立的部分求值完成后再从左往右依次进行输出操作，毕竟对于大部分表达式来说，这两者的结果都是相同的，但此时它却明显地造成了上面这个表达式的问题。

所以需要谨记一个原则：**如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象**。

但该原则有一个**例外**，就是表达式中一个相对独立的部分是另一个相对独立部分的运算对象时，不会发生问题，例如`*++iter`，将先对`iter`进行递增然后进行解引用，而不会发生歧义。

:::



### 4. 类型转换

表达式的值还有一个重要的影响因素就是运算对象的类型转换，它会导致你所看到的值不一定是你所得到值，例如：

```cpp
double pi = 3.14;
int a = pi;
```

实际上`pi`被隐式转换为`int`类型，于是将会截断小数部分，所以`a`得到`3`。

需要注意的是类型转换发生在运算符执行之前，在上例中则是`pi`先发生转换，然后才进行赋值；而非先赋值，再将`a`进行转换。