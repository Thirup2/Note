---
title: vector类
---

## 一、类类型成员

部分类成员类型如下：

- `value_type`：实例化元素类型
- `size_type`：标识`vector`尺寸的类型
- `difference_type`：标识迭代器相减所得的差值的类型
- `reference`：实例化元素类型的引用类型
- `const_reference`：上述引用类型的常量版本
- `pointer`：实例化元素类型的指针类型
- `const_pointer`：上述指针类型的常量版本
- `iterator`：迭代器类型
- `const_iterator`：常量迭代器类型
- `reverse_iterator`：反向迭代器类型
- `const_reverse_iterator`：常量反向迭代器类型



## 二、初始化

### 1. 类模板

`vector`是一个类模板，在实例化之前元素类型为未定义状态，所以要定义一个`vector`对象，首先需要进行类模板的**实例化**。

```c++
vector<int> ivec;
vector<string> str_vec;
vector<vector<string>> file;
```

在类模板名后添加一对`<>`，在其中的参数就是用于实例化的元素类型，如你所见，用于实例化的元素可以是几乎任何类型的对象，但由于引用不是对象，所以不能用引用类型实例化`vector`。

实例化后的类模板就可以成为一个类型，像其他类型一样使用。

实际上，`string`也是由一个类模板实例化而来的类型，该类模板将字符串进行了抽象，使其不与具体的字符类型相关。由于字符类型有限，所以标准库已经将所有可能的实例化类型都定义好了，我们可以直接像一般类型一样使用。



### 2. 定义和初始化

- `vector<T> v1`：`v1`是一个空`vector`，它潜在的元素是`T`类型的，执行默认初始化
- `vector<T> v2(v1)`：使用另一个`vector<T>`类型对象进行直接初始化，`v2`中包含有`v1`所有元素的副本
- `vector<T> v2 = v1`：使用另一个`vector<T>`类型对象进行拷贝初始化，等价于`v2(v1)`，`v2`中包含有`v1`所有元素的副本
- `vector<T> v3(n, val)`：`v3`包含了`n`个值为`val`的元素
- `vector<T> v4(n)`：`v4`包含了`n`个重复地执行了值初始化的对象，如果元素类型要求必须明确提供初始值或不支持默认初始化，则不能使用该方法。
- `vector<T> v5{a, b, c...}`：容器类型的字面值初始化方式，列表初始化，包含了初始值个数的元素，每个元素被赋予相应的初始值
- `vector<T> v5 = {a, b, c...}`：等价于`v5{a, b, c...}`
- `vector<T> v6(iter1, iter2)`：使用同一个容器中的按前后顺序给出的两个迭代器或同一个数组中按前后顺序给出的两个指针进行初始化，具体范围是`[iter1, iter2)`。

:::caution 注意

<Tabs>

<TabItem value="list_initialize" label="关于列表初始化">

需要注意的是，列表初始化在类定义时也是构造函数的一种，其调用逻辑实际上和直接初始化相同。

当我们使用列表初始化的时候，我们放在列表中的初始值会优先用来进行列表初始化，但如果我们提供的值无法进行列表初始化，则会尝试调用另外的直接初始化方式，如果都不行，则会报错，具体如下例所示：

```c++
vector<int> ivec1(10, 5);			// ivec1 包含 10 个 5
vector<int> ivec2{10, 5};			// ivec2 包含 10 和 5
vector<string> str_vec1{2, "hi"};	// str_vec 包含 2 个 "hi"
// error-next-line
vector<string> str_vec2{2, 5};		// 错误：无法匹配任何初始化方式
```

</TabItem>

<TabItem value="Iter_initialize" label="关于使用迭代器或指针的初始化">

使用另一个相同类型的`vector<T>`的迭代器或者相同元素类型的数组中的指针可以对一个`vector<T>`类型的对象进行初始化。

需要注意的是使用的迭代器或指针必须指向同一个容器，并且参数1必须指向参数2所指元素之前的元素，此时所拷贝的元素为`[iter1, iter2)`；或者两个参数指向同一个位置，此时不拷贝元素，容器初始化为空。

具体示例如下：

```c++
vector<int> ivec1{1, 3, 5, 7, 9};
int iarr1[] = {0, 2, 4, 6, 8};

vector<int> ivec2(ivec1.begin(), ivec1.end());			// 完全拷贝
vector<int> ivec3(begin(iarr1), end(iarr1));			// 完全拷贝
vector<int> ivec4(ivec1.begin() + 2, ivec1.end() - 2);	// 部分拷贝，只拷贝了 5
vector<int> ivec5(iarr1 + 1, iarr1 + 4);				// 部分拷贝，只拷贝了 2, 4, 6
```

</TabItem>

</Tabs>

:::



## 三、操作

- `v.empty()`：如果`v`不含有任何元素，返回`true`；否则返回`false`
- `v.size()`：返回`v`中元素的个数
- `v.push_back(t)`：向`v`的尾端添加一个值为`t`的元素
- `v[n]`：返回`v`中第`n`个位置上元素的引用
- `v1 = v2`：用`v2`中元素的拷贝替换`v1`中的元素
- `v1 = {a, b, c...}`：用列表中元素的拷贝替换`v1`中的元素
- `v1 == v2`/`v1 != v2`：`v1`和`v2`相等当且仅当他们的元素数量相同且相同位置元素值都相等
- `<`、`<=`、`>`、`>=`：以字典顺序比较两个`vector`对象

**注意**：

1. 比较需要注意的是`push_back(t)`操作，该操作会向容器中高效地添加元素，但由于该操作会改变容器的大小，所以当使用范围 for 语句遍历`vector`容器时，不要使用该操作。
2. 下标访问操作还是一样，注意不要越界。另外，下标操作只能用来访问或修改元素，不能用该方法添加元素。
3. 对于`vector`的字典顺序比较，和`string`的比较方式完全相同
4. `vector`也支持范围 for 循环进行操作
