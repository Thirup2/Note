---
sidebar_position: 2
hide_title: false
slug: /Basic_C++/Syntax/Data/Literal
---



一个形如 42 的值被称作**字面值常量**（literal），这样的值一望而知。每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。

## 一、整型

我们可以将整型字面值写作十进制数、八进制数或十六进制数的形式。以`0`开头的整数代表八进制数，以`0x`或`0X`开头的代表十六进制数。例如，我们可以用下面的任意一种形式表示数值 20：

- 20（十进制）
- 024（八进制）
- 0x14（十六进制）

默认情况下，十进制字面值是带符号数，八进制和十六进制字面值既可能是带符号的也可能是无符号的。十进制字面值的类型是`int`、`long`、`long long`中能容纳字面值并且尺寸最小的那个。而八进制和十六进制字面值的类型是`int`、`unsigned`、`long`、`unsigned long`、`long long`、`unsigned long long`中能容纳字面值并且尺寸最小的那个。如果一个字面值连与之关联的最大的数据类型都放不下，将产生错误。

:::info 提示

不知你有没有想过，字面值类型如此多变，如何才能知道我正在使用的这个字面值是什么类型。实际上，通常我们不需要关心这个字面值的类型，因为我们在使用字面值的时候，总是将其赋值给一个给定类型的变量，如果二者类型不同则会发生类型转换。

一般来说，这个转换不会出问题，我们通常在需要一个变量的时候就已经想好了这个变量要存储的是多大的数，从而选择适合的类型，然后在初始化该变量的时候使用的字面值也是在该范围内的。例如，如果你清楚的知道`unsigned short`可以保存的最大值为 65535 ，那你是不会把 65536 赋值给一个`unsigned short`类型的，我们只会把一个 0 - 65535 之间的整数比如 32 赋值给`unsigned short`，此时虽然 32 是一个`int`类型的字面值，但是`int`到`unsigned short`的转换却并不会出错，因为我们在选择保存 32 的类型的时候已经判断过 32 不会超过`unsigned short`的最大值。

:::

一个默认的整数字面值不可能是`short`类型，也不可能是任何无符号的类型，以及一个没超过`int`最大值的整数字面值默认情况下也不可能是`long`类型，所以为了控制字面值的类型，可以通过添加后缀的方式：

- `u`或`U`：`unsigned`
- `l`或`L`：`long`
- `ll`或`LL`：`long long`

需要注意的是，整数字面值的后缀仅仅改变字面值的最小匹配类型，如果你指定的类型仍然无法保存，则会继续寻找更大的类型保存字面值。其中`u`/`U`后缀会让字面值只在所有无符号类型中查找。



## 二、浮点型

浮点型字面值表现为一个小数或以科学计数法表示的指数，其中指数部分用`E`或`e`标识：

`3.14159`、`3.14159E0`、`0.`、`0e0`、`.001`

在默认情况下，浮点型字面值是一个`double`，如果想把字面值保存为`float`或`long double`类型，则使用下面的后缀：

- `f`或`F`：`float`
- `l`或`L`：`long double`



## 三、字符

字符型字面值有几种形式，它们默认都是`char`类型的：

- 一般字符：`'a'`

- 转义序列：`'\n'`（换行符），具体的转义序列表如下：

  | 含义       | 序列 | 含义       | 序列 | 含义           | 序列 |
  | ---------- | ---- | ---------- | ---- | -------------- | ---- |
  | 换行符     | `\n` | 横向制表符 | `\t` | 报警（响铃）符 | `\a` |
  | 纵向制表符 | `\v` | 退格符     | `\b` | 双引号         | `\"` |
  | 反斜线     | `\\` | 问号       | `\?` | 单引号         | `\'` |
  | 回车符     | `\r` | 进纸符     | `\f` |                |      |

  另外，还有一类转义序列，是在反斜杠`\`后面加上数字表示字符集中该数字作为编码时对应的字符。可以在`\x`后面紧跟 1 个或多个十六进制数字，或者`\`后面紧跟 1 个、2 个或 3 个八进制数字，如：

  - `\7`（响铃）
  - `\115`（字符`'M'`）
  - `\0`（空字符）
  - `\x4d`（字符`'M'`）

  :::caution 注意

  1. 使用转义序列的时候也需要像一般字符一样用单引号括起来（在字符串中不用单独括出，包含在双引号包括的字符串中即可）
  2. 如果反斜杠`\`后面跟着的八进制数字超过 3 个，那么只有前 3 个数字与`\`构成转义序列。而如果是`\x`，则后面跟着的所有 16 进制数字都会与`\x`一起构成转义序列。（此处只是说明构成转义序列的数字将如何进行组合，并不代表你所写出的任何被视为一个转义序列的组合都是正确的）

  :::

由于字符默认格式为`char`类型，C++ 提供了一些**前缀**来改变字面值的保存类型：

- `u`：`char16_t`（Unicode16）
- `U`：`char32_t`（Unicode32）
- `L`：`wchar_t`（Unicode）

:::caution 注意

1. 和介绍字符数据类型时所说的不同，此处的字符前缀会确实改变字符的编码，如果你的文件采用 UTF-8 编码，则会被转换成前缀所指示的编码。其中`wchar_t`和`char16_t`所用的编码几乎是一样的
2. 使用`u`、`U`、`L`前缀时编译器都会对字符编码内容进行检查，由于 gcc 识别 UTF-8 编码，所以如果你的文件采用 GBK 编码并使用这些前缀来修饰字符可能会报错，因为将无法进行转换。

:::



## 四、字符串

尽管在 C++ 中有两种方式表示字符串（字符数组和`string`类型），但是字符串常量只有一种表示方式，即使用字符数组的方式，用一对双引号括出，这种字符串也叫 C 风格字符串：

```c++
"Hello World!"
```

:::info 为什么只有一种字符串字面值？

实际上，因为`string`类型属于标准库内容而并非 C++ 固有语法的一部分，同时`string`类型和字符数组处理的都是字符串，如果还为`string`类型单独设计一种字符串字面值的话，可能会比较反直觉。

:::

如果用一个数组保存这样的字符串，将需要比字符个数多一个位置的数组，用于保存其末尾的空字符`'\0'`。

字符串字面值默认为`char`类型数组，如果要改变其类型，可以在字符串前面添加前缀，其中前三种前缀和字符前缀相同：

- `u`：`char16_t`
- `U`：`char32_t`
- `L`：`wchar_t`
- `u8`：`char`（UTF-8）

:::caution 注意

和字符前缀一样，字符串前缀也会改变字符串元素的类型和编码。编译器也会对字符串常量本身的编码进行检查，与编译器支持的编码相同才能进行转换，否则将报错。

:::



## 五、布尔字面值

只有两个：

- `true`：真
- `false`：假



## 六、指针字面值

`nullptr`：空指针
