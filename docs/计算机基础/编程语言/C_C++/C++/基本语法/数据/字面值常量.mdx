---
sidebar_position: 2
hide_title: false
slug: /Basic_C++/Syntax/Data/Literal
---



一个形如 42 的值被称作**字面值常量**（literal），这样的值一望而知。每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。

## 一、整型

我们可以将整型字面值写作十进制数、八进制数或十六进制数的形式。以`0`开头的整数代表八进制数，以`0x`或`0X`开头的代表十六进制数。例如，我们可以用下面的任意一种形式表示数值 20：

- 20（十进制）
- 024（八进制）
- 0x14（十六进制）

默认情况下，十进制字面值是带符号数，八进制和十六进制字面值既可能是带符号的也可能是无符号的。十进制字面值的类型是`int`、`long`、`long long`中能容纳字面值并且尺寸最小的那个。而八进制和十六进制字面值的类型是`int`、`unsigned`、`long`、`unsigned long`、`long long`、`unsigned long long`中能容纳字面值并且尺寸最小的那个。如果一个字面值连与之关联的最大的数据类型都放不下，将产生错误。

:::info 提示

不知你有没有想过，字面值类型如此多变，如何才能知道我正在使用的这个字面值是什么类型。实际上，通常我们不需要关心这个字面值的类型，因为我们在使用字面值的时候，总是将其赋值给一个给定类型的变量，如果二者类型不同则会发生类型转换。

一般来说，这个转换不会出问题，我们通常在需要一个变量的时候就已经想好了这个变量要存储的是多大的数，从而选择适合的类型，然后在初始化该变量的时候使用的字面值也是在该范围内的。例如，如果你清楚的知道`unsigned short`可以保存的最大值为 65535 ，那你是不会把 65536 赋值给一个`unsigned short`类型的，我们只会把一个 0 - 65535 之间的整数比如 32 赋值给`unsigned short`，此时虽然 32 是一个`int`类型的字面值，但是`int`到`unsigned short`的转换却并不会出错，因为我们在选择保存 32 的类型的时候已经判断过 32 不会超过`unsigned short`的最大值。

:::

一个默认的整数字面值不可能是`short`类型，也不可能是任何无符号的类型，以及一个没超过`int`最大值的整数字面值默认情况下也不可能是`long`类型，所以为了控制字面值的类型，可以通过添加后缀的方式：

- `u`或`U`：`unsigned`
- `l`或`L`：`long`
- `ll`或`LL`：`long long`

需要注意的是，整数字面值的后缀仅仅改变字面值的最小匹配类型，如果你指定的类型仍然无法保存，则会继续寻找更大的类型保存字面值。其中`u`/`U`后缀会让字面值只在所有无符号类型中查找。



## 二、浮点型

浮点型字面值表现为一个小数或以科学计数法表示的指数，其中指数部分用`E`或`e`标识：

`3.14159`、`3.14159E0`、`0.`、`0e0`、`.001`

在默认情况下，浮点型字面值是一个`double`，如果想把字面值保存为`float`或`long double`类型，则使用下面的后缀：

- `f`或`F`：`float`
- `l`或`L`：`long double`



## 三、字符



## 四、字符串

