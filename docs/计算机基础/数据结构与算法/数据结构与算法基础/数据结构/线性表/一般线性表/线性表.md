---
slug: /Basic_DSA/Linear_List/Common_Linear_List/List
---



## 一、抽象数据类型定义

### 1. 逻辑结构

**线性表**是具有**相同**数据类型的 $n(n\geqslant0)$ 个数据元素的**有限序列**，其中 $n$ 为**表长**，当 $n=0$ 时线性表是一个**空表**。若用 $L$ 命名线性表，则其一般表示为：
$$
L=(a_1, a_2, \dots, a_i, a_{i+1}, \dots, a_n)
$$
式中，$a_1$ 是唯一的 “第一个” 数据元素，称为**表头元素**；$a_n$ 是唯一的 “最后一个” 数据元素，成为**表尾元素**。除第一个元素外，每个元素有且仅有一个**直接前驱**。除最后一个元素外，每个元素有且仅有一个**直接后继**。

> **需要注意以上线性表逻辑定义中的几个特点**：
>
> - 表中元素的个数有限
> - 表中元素具有逻辑上的顺序性，表中元素有其先后顺序
> - 表中元素都是数据元素，每个元素都是单个元素
> - 表中元素的数据类型都相同，这意味着每个数据元素占有相同大小的存储空间
> - 表中元素具有抽象性，即仅讨论元素间的逻辑关系，而不考虑元素究竟表示什么内容



### 2. 基本操作

- `InitList(&L)`：初始化表。构造一个空的线性表
- `Length(L)`：求表长。返回线性表`L`的长度，即`L`中数据元素的个数
- `LocateElem(L, e)`：按值查找操作。在表`L`中查找具有给定关键字值的元素
- `GetElem(L, i)`：按位查找操作。获取表`L`中第`i`个位置的元素的值
- `ListInsert(&L, i, e)`：插入操作。在表`L`中的第`i`个位置上插入指定元素`e`
- `ListDelete(&L, i, &e)`：删除操作。删除表`L`中第`i`个位置的元素，并用`e`返回删除元素的值
- `PrintList(L)`：输出操作。按前后顺序输出线性表`L`的所有元素值
- `Empty(L)`：判空操作。若`L`为空表，则返回`true`，否则返回`false`
- `DestroyList(&L)`：销毁操作。销毁线性表，并释放线性表`L`所占用的内存空间



## 二、物理结构

线性表的物理结构有两种，一是使用类似于数组的实现方式，称为顺序表；二是使用链式存储，称为链表，下面将分别介绍。

### 1. 顺序结构

顺序表是线性表中最简单的一种表结构。它指的是使用物理上连续的内存来存放逻辑上连续的元素。在 C 语言中，顺序表的实现通常使用数组类型，由于 C 语言数组的性质，这导致用数组实现的顺序表其大小无法更改。

当然，我们也可以使用 C 标准库中的动态分配内存方法来灵活分配数组的大小，并在需要的时候进行扩张和收缩。这种方法的好坏取决于其扩张和收缩的策略如何，一个比较理想的策略是当数组的空间装满了元素之后，将其空间扩张为原本的 2 倍，然后在数组中元素个数小于数组大小的 1/2 时，将其空间收缩为原本的 1/2。这样做既避免了每一次插入都分配内存的消耗，也避免了删除元素后产生的空间浪费。当然，这个扩张和收缩的策略可以根据实际情况灵活决定。

可以说使用动态分配内存是一个比较理想的顺序表实现方法，但对于 C/C++ 来说，它有一个比较大的缺陷，就是必须人工管理内存。如果内存管理不到位就可能发生内存泄漏等一系列问题。C++ 现在可以通过智能指针来管理动态分配的内存，算是一个比较好的管理方法，但是对于 C 语言来说，仍然需要人工管理内存，或者自己实现一个类似于 C++ 智能指针的类来管理内存。

#### 1）静态实现

```c
#define MAXSIZE 10		// 最大元素个数
struct list
{
    ElemType data[MAXSIZE];	// 元素内容
    int length;			// 表长
};
typedef struct list SeqList;
```

#### 2）动态实现

```c
#define INITSIZE 10		// 初始大小
strct list
{
    ElemType *data;		// 指针指向动态分配的内存
    int capacity;		// 动态内存当前总大小
    int length;			// 动态内存当前已分配的大小
};
typedef struct list SeqList;
```



### 2. 链式结构

链表是使用指针实现的一种逻辑上连续但物理上内存地址不连续的表结构。当我们使用链表实现线性表时，最明显的一个不同应该是不能再以 $O(1)$ 的时间复杂度通过位序访问元素了。理论上它们在存储空间的灵活性以及插入删除操作的时间复杂度上有区别，但实际上顺序表的存储空间不灵活可以通过动态分配的方式解决，而链表的插入删除看上去很快，但它在插入删除前基本上都需要进行查找，又由于链表的按值查找和按位查找都变成了 $O(n)$，所以实际上链表的插入删除仍然是 $O(n)$。将链表的所有插入删除的时间复杂度优化为 $O(1)$ 也是可行的，但需要传入一个实际的结点指针来表示位置而不是用位序来表示位置。

链表下又细分为多种逻辑结构，分别是单链表、双链表、循环单链表和循环双链表。它们主要是根据可选择的遍历方式区分的。单链表只能从头结点开始往后遍历；双链表可以从头结点或尾结点开始遍历，即正向遍历和反向遍历；循环单链表可以从链表中任意结点开始单向遍历；循环双链表可以从链表中任意结点开始双向遍历。

另外，链表还有一种使用数组实现的方法，这种实现的链表称为静态链表。这种链表虽然充满了不必要性，但是在某些情况下它是很有用的，比如在没有类似于指针的类型的编程语言的链表实现中。由于没有指针或者说没有动态分配内存的操作，所以我们使用的数组也应该是静态数组，同时必须用数组模拟分配内存和释放内存的操作。

#### 1）单链表

```c
typedef struct node
{
    ElemType data;
    struct node *next;
} Node, *SinLList;
```

#### 2）双向链表

```c
typedef struct node
{
    ElemType data;
    struct node *pre;
    struct node *next;
} Node, *DouLList;
```

#### 3）循环链表

同 “单链表”
#### 4）双向循环链表

同 “双向链表”



## 三、算法分析

### 1. 初始化（链表）

在创建链表时，我们可以选择是否创建头结点或尾结点以及是否需要头指针/尾指针（实际上头指针和尾指针的选择应该在类型定义的时候进行），具体可以根据以下内容进行判断：

- **单链表**：

  1. 头指针：必须（作为链表入口）。同时可以使头插和删头操作为 $O(1)$
  2. 头结点：可选。将头插和删头操作一般化
  3. 尾指针：可选。可使尾插操作为 $O(1)$，但删尾操作仍为 $O(n)$
  4. 尾结点：禁用。会将尾部操作特殊化，且无任何正面效果

- **双链表**（在双链表中，头、尾二字可交换看待）：

  1. 头指针：必须（作为链表入口）。同时使头插和删头操作为 $O(1)$

     **注意**：如果你选择将尾指针作为链表入口，则实际上你选择的尾指针就成了头指针，所以在此处说头指针是必须的并无问题，你也可以说尾指针是必须的而头指针是非必须的，这样尾指针也就变成了头指针，头指针也就变成了尾指针。实际上，根据双链表能双向遍历的条件，我们应该一般头尾指针都要设置。

  2. 头结点：可选。将头插和删头操作一般化

  3. 尾指针：可选。使链表能反向遍历；同时使尾插和删尾操作为 $O(1)$

  4. 尾结点：可选。将尾插和删尾操作一般化

- **循环单链表**：

  1. 头指针/尾指针：必选其一（作为链表入口）。
     - 头指针：在有头结点或尾指针时，头插和删头操作为 $O(1)$，否则为 $O(n)$；尾插和删尾操作为 $O(n)$
     - 尾指针：头插和删头操作为 $O(1)$；尾插操作为 $O(1)$，删尾操作为 $O(n)$
  2. 头结点：可选。在通过头指针进行头插和删头时可将操作一般化。但同时会增加从链表任意结点开始遍历的难度。
  3. 尾结点：禁用。会将尾部操作特殊化，同时增加从链表任意结点开始遍历的难度，且无任何正面效果。

- **循环双链表**：

  1. 头指针/尾指针：必选其一（作为链表入口）
     - 头指针：头插和删头操作为 $O(1)$；尾插和删尾操作为 $O(1)$
     - 尾指针：头插和删头操作为 $O(1)$；尾插和删尾操作为 $O(1)$
  2. 头结点/尾结点：可选。可将头部操作或尾部操作的一般化。但同时会增加从链表任意结点开始遍历的难度。



### 2. 表长（链表）

对于链表来说，一般获取表长的方法是对链表进行一次遍历即可，时间复杂度为 $O(n)$；

而为了简化这一步，可以在链表类型中添加一个表长数据项，每次插入或删除元素时都对该数据项进行维护，同时获取表长的操作时间复杂度变成 $O(1)$，虽然在插入和删除时维护这个数据项所消耗的总时间或许和 $O(n)$ 差不多，但是由于我们将一个过程分散到了每次操作中，每次操作只需要多消耗 $O(1)$ 的时间，这对用户来说基本是无感的。



### 3. 按值查找

#### 1）顺序表

对于顺序表来说，如果是无序顺序表直接查找，则毫无疑问是 $O(n)$；而如果是一个有序表，则取决于查找算法。

当然，我们也可以先将一个无序顺序表先进行排序，然后进行查找，这样的时间复杂度则为排序算法与查找算法的时间复杂度之和；

另外，我们也可以在插入和删除时同时维护顺序表的有序性，最后在查找的时候就只取决于查找算法，当然这种方法在插入删除时需要多消耗时间



#### 2）链表

几乎只能进行顺序查找，时间复杂度为 $O(n)$；

当然，也有一些查找算法可以用于链表，比如制作一个关键字与结点地址的索引，通过索引查找或散列查找都是可行的。



### 4. 按位查找（链表）

按位查找对于链表同样一般使用顺序查找，时间复杂度为 $O(n)$；

同样也可以使用空间换时间的方法，建立一个结点地址的数组，这样就是 $O(1)$，空间复杂度为 $O(n)$



### 5. 插入删除

#### 1）顺序表

如果维护的是一个无序表，则插入可以是 $O(1)$，这种情况下删除通常按值进行删除，即按值查找+删除操作的时间复杂度；

但通常需要维护的顺序表都是有序表，此时插入操作为 $O(n)$，删除操作也为 $O(n)$，因为需要将插入位置之后的元素全部后移以及需要将删除位置之后的元素全部前移。

另外，插入删除操作需要记得维护一些变量。



#### 2）链表

如果是一个无序表，则只涉及头插、尾插，其时间复杂度根据所选择的链表类型以及是否有头尾结点和头尾指针决定。删除则和顺序表相同，需要先按值查找，然后进行删除，只不过此时通常只取决于按值查找的时间复杂度。

如果是一个有序表，则每次插入删除时需要找到插入位置，然后进行插入删除，取决于按位查找的时间复杂度。



### 6. 销毁

#### 1）顺序表

对于顺序表来说，销毁操作通常是动态分配的顺序表才需要，需要注意释放内存时的`free`操作的对象。



#### 2）链表

对于链表来说，销毁操作一定是必须的（除了静态链表），每当程序结束，都必须释放分配好的内存，此时由于是每次只分配一个结点而不像动态顺序表一样一次分配一整个数组，所以在释放链表的内存时，必须要保证能遍历到每个结点，释放结点内存和指向下一个结点的顺序需要特别注意，同时在释放之前，应该用另一个指针指向即将被释放的空间，而非直接释放用来遍历的指针。
