---
sidebar_position: 1
hide_title: true
slug: /Basic_DSA/Stack/Common_Stack
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## 一、抽象数据类型定义

### 1. 逻辑结构

**栈**（Stack）是只允许在一端进行插入或删除的线性表。首先栈是一种线性表，但限定这种线性表只能在某一端进行插入和删除操作。

:::tip 基本概念

- **栈顶**（Top）：线性表允许进行插入删除的那一端。
- **栈底**（Bottom）：固定的，不允许进行插入和删除的另一端。
- **空栈**：不含任何元素的空表

:::

假设某个栈 $S=(a_1, a_2, a_3, a_4, a_5)$，则 $a_1$ 为栈底元素，$a_5$ 为栈顶元素。由于栈只能在栈顶进行插入和删除操作，进栈次序依次为 $a_1, a_2, a_3, a_4, a_5$，而出栈次序为 $a_5, a_4, a_3, a_2, a_1$。由此可见，栈的操作特性可以明显地概括为**后进先出**（Last In Frist Out，LIFO）。

:::info 栈的数学性质

$n$ 个不同元素进栈，出栈元素不同排列的个数为 ${1\over {n+1}}C^2_{2n}$。上述公式称为**卡特兰**（Catalan）数，可采用数学归纳法证明。

:::



### 2. 基本操作

- `InitStack(&S)`：初始化一个空栈`S`
- `StackEmpty(S)`：判断一个栈是否为空，若栈`S`为空则返回`true`，否则返回`false`
- `Push(&S, x)`：进栈，若栈`S`未满，则将`x`加入使之成为新栈顶
- `Pop(&S, &x)`：出栈，若栈`S`非空，则弹出栈顶元素，并用`x`返回栈顶元素
- `GetTop(S, &x)`：读栈顶元素，若栈`S`非空，则用`x`返回栈顶元素
- `DestroyStack(&S)`：销毁栈，并释放栈`S`占用的存储空间



## 二、物理结构

由于栈在逻辑结构上是线性表的一种特殊情况，所以自然也可以用线性表的物理结构来实现栈，具体方法仍然分为顺序结构和链式结构：

### 1. 顺序结构

栈的顺序结构和顺序表一样可以用两种实现方式，一是静态实现，二是动态分配内存的方式实现。具体实现代码参考[线性表顺序结构实现](../../../Basic_DSA/Linear_List/Common_List#1-%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84)。

顺序栈的关键点在于把数组的哪一端作为栈底，哪一端作为栈顶。我们知道不论是静态还是动态的数组，它们的增长方向一般都是向后增长（当然如果将数组逻辑上头尾相连也可以反向增长），所以我们选择将数组第一个元素所在的一端作为栈底，与之相反的一端作为栈顶。我们需要一个指向栈顶的指针，以方便插入和删除，在顺序表中，这个值通常还可以代表栈的长度。



### 2. 链式结构

在 4 种链表中，我们应该选用哪一种才是最适合栈这种数据结构应该首先进行如下分析：

我们从最简单的链表开始考虑，即只有一个头指针且不含头结点的单链表，由于栈只需要在头部进行操作，所以实际上这种单链表结构就已经足够表示栈结构了，我们只需要将头指针当作栈顶指针即可。而且并不需要头结点，因为所有的操作都在头部执行，如果添加一个头结点，每次执行头部操作的时候都还要跨越一个头结点，比较麻烦。



## 三、算法分析

### 1. 初始化&栈空判断

<Tabs>

<TabItem value="SeqStack" label="顺序栈" default>

顺序表在初始化时需要考虑到一个问题，那就是栈顶指针在栈为空时应该指向第一个元素还是指向第一个元素之前，即栈顶指针应该为 0 还是 -1。如果选择 0，那么栈顶指针应该永远指向栈顶元素之上的元素；而如果选择 -1，则栈顶指针应该永远指向栈顶元素。

而判断栈空则依赖于你的选择。

</TabItem>

<TabItem value="LinkList" label="链栈">

当我们使用单链表实现栈时，最简单的情况只需要一个头指针（或者说栈顶指针）就可以了。链表实现不需要太考虑栈顶指针的问题，因为如果使用单链表实现毫无疑问当栈为空时，栈顶指针应该指向`NULL`。

所以判断栈空的行为则直接判断栈顶指针是否指向`NULL`即可。

</TabItem>

</Tabs>



### 2. 进栈出栈

<Tabs>

<TabItem value="SeqList" label="顺序表" default>

顺序栈的进栈出栈操作根据你选择的栈空判断因素而有所不同。

如果你选择将栈顶始终指向栈顶元素之上，则每次进栈先在栈顶指针位置插入，然后再递增栈顶指针；每次出栈时先递减栈顶指针，然后将此时的栈顶指针指向位置元素返回。

如果你选择将栈顶始终指向栈顶元素，则每次进栈时先递增栈顶指针，然后写入元素值；每次出站时先保存元素值，然后递减栈顶指针。

不论哪一种方法，进栈出栈操作的时间复杂度始终为 $O(1)$

</TabItem>

<TabItem value="LinkList" label="链表">

链栈的进出栈方式则更简单，因为没有类似于顺序栈的栈顶指针的选择，同时不用添加头结点。

当链栈进栈时，具体的步骤为**创建并初始化结点**，然后**改变结点的指向**，最后**改变栈顶指针的指向**；

当链栈出栈时，具体的步骤为**创建用于删除栈顶元素的指针并指向栈顶元素**，然后**改变栈顶指针的指向**，最后**返回并删除原栈顶元素**即可。

它们的时间复杂度也始终为 $O(1)$

</TabItem>

</Tabs>



### 3. 销毁栈

销毁栈的方法和销毁线性表的方法相同。

如果采用动态顺序表的结构建栈，则使用完成后对整个栈数组进行释放；

如果采用链表的结构建栈，则应该调用出栈函数，依次删除栈顶元素。