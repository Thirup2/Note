---
title: 队列
description: 数据结构中队列的相关内容，本页介绍的是最基本的队列结构
keywords: [数据结构,队列]
---

## 一、抽象数据类型定义

### 1. 逻辑结构

**队列**（Queue）简称队，也是一种操作受限的线性表，只允许在表的一端进行插入，而在表的另一端进行删除。向队列中插入元素称为**入队**或**进队**；删除元素称为**出队**或**离队**。这和我们日常生活中的排队是一致的，最早排队的也是最早离队的，其操作的特性是**先进先出**（First In First Out, FIFO）。

:::tip 关键概念

- **队头**（Front）：允许删除的一端，又称**队首**
- **队尾**（Rear）：允许插入的一端
- **空队列**：不含任何元素的空表

:::



### 2. 基本操作

- `InitQueue(&Q)`：初始化队列，构造一个空队列`Q`
- `QueueEmpty(Q)`：判断队空，若队列`Q`为空返回`true`，否则返回`false`
- `EnQueue(&Q, x)`：入队，若队列`Q`未满，将`x`加入，使之成为新的队尾
- `DeQueue(&Q, &x)`：出队，若队列`Q`非空，删除队头元素，并用`x`返回
- `GetHead(Q, &x)`：读队头元素，若队列`Q`非空，则将队头元素赋值给`x`



## 二、物理结构

队列也有顺序结构和链式结构两种物理结构，分别如下。

### 1. 顺序结构

看上去很好实现，当插入的时候就像栈一样在队尾插入即可，删除时删除前面的元素即可。但实际上这会导致一个问题：当队尾已经是数组末尾的时候，就无法再插入元素了，然而由于我们在对头执行了若干次删除操作，所以前面会空余很多位置，造成一个明明有空间却无法插入的现象。

为了解决这个问题，你当然可以使用动态分配数组的方式来扩大队列容量，但实际上队列这种结构并不适合动态分配内存，因为即使你扩大了后面的空间，前面的空间仍然还是浪费了，而`realloc`函数又无法执行释放队头空间同时扩张队尾空间这样复杂的操作。

最合适的方法应该是将数组当作一个环，将其首尾接在一起。这可以利用除法取余运算来实现。当队尾已经到数组末尾了，而队头之前还有空位时，将队尾位置 + 1 然后对数组长度进行除法取余，就可以得到队尾的后一个元素应该存放的位置了。详细内容参见算法分析部分。

循环队列的类型定义如下：

```c
#define MAXSIZE 10
struct queue
{
    ElemType data[MAXSIZE];
    int front, rear;
};
typedef struct queue SeqQueue;
```



### 2. 链式结构

链式结构相比于顺序结构就要简单一点了。而且同样使用最简单的单链表就可以实现链队列，只需要添加一个队尾指针即可。具体的类型定义如下：

```c
struct node
{
    ElemType data;
    struct node *next;
};
typedef struct node Node;

struct queue
{
    Node *front;
    Node *rear;
};
typedef struct queue LinkQueue;
```



## 三、算法分析

### 初始化

<Tabs>

<TabItem value="Seq" label="循环队列" default>

1. 我们首先需要讨论初始状态下队列的对头指针和队尾指针应该在什么位置。

   由于这是一个循环队列，所以实际上它们的绝对位置并不重要，关键是队头指针和队尾指针的相对位置。

   如果队尾指针放在队头指针之前表示初始状态，要表达的意思就是队尾指针永远指向队尾元素位置，插入时只需要根据队尾指针插入元素即可，即先递增队尾指针再插入元素，队头指针只要不删除元素就不会发生改变。但这种表达方式在队空和队满时相对位置一致，所以需要一些方法来解决（具体内容在第 2 点）

   如果将队尾指针和队头指针指向同一位置表示初始状态，此时有两种可能。你可以用队尾指针永远指向队尾元素，但这种情况下，队列为空的时候和不为空的时候操作不太一样，以及删除最后一个元素和删除其他元素的时候操作也不相同，故不采用这种表示。除此之外，则是用队尾指针永远指向队尾元素之后的位置，队头指针将永远指向队头元素。使用这种表示也会导致队空队满时队头队尾指针的相对位置相同，解决方法具体内容在第 2 点。

   如果将队尾指针放在队头指针之后表示初始状态，则表明队尾指针将永远指向队尾元素的后一个位置，但这也会有第一个元素的特殊操作的问题存在，故一般不采用。

   综上所述，实际上我们一般采用队头队尾指向同一个位置表示队空状态。

2. 其次需要讨论当队空队满时队头队尾指针的表示方式相同时的解决方案，姑且有两种解决方案

   1. 牺牲一个元素位置。当队空时队头队尾相同，当队满时，队尾在队头前一个位置。此时队空的条件为`Q.front==Q.rear`，而队满的条件为`(Q.rear+1)%MaxSize=Q.front`，另外队列中元素个数为`(Q.rear-Q.front+MaxSize)%MaxSize`
   2. 额外添加一个数据项来判断队空和队满。这个数据项可以仅仅用来标志队空队满，比如当它因为插入元素导致`Q.front==Q.rear`则将这个数据项设为 1，否则设为 0。也可以用这个数据项来表示队列的长度，当长度与数组最大尺寸相等时就表示队满，为 0 时表示队空

</TabItem>

<TabItem value="Link" label="链队列">

链队列初始状态需要讨论的一个问题主要是是否需要头结点。当不使用头结点的时候，初始状态下，队头队尾应该都指向 NULL，当插入第一个元素时队头指针也要进行处理，而理想状态下我们应该只在删除时涉及到队头指针。而如果使用头结点，则没有这个问题，初始状态下都指向头结点，插入元素时也只需要移动队尾指针即可。

</TabItem>

</Tabs>