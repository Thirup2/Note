---
title: 串
description: 数据结构中字符串相关的内容，本页介绍的是最基本的串结构的实现
keywords: [数据结构,串,字符串,KMP]
---

## 一、抽象数据类型定义

### 1. 逻辑结构

**串**（string）是由零个或多个字符组成的有限序列。一般记为：
$$
S='a_1a_2\dots a_n'(n\geqslant 0)
$$
其中，$S$ 是串名，单引号阔气来的字符序列是串的值；$a_i$ 可以是字母、数字或其他字符；串中字符的个数 $n$ 称为串的长度。$n=0$ 时的串称为**空串**（用 $\empty$ 表示）。

串中任意多个连续的字符组成的字序列称为该串的**子串**，包含子串的串称为**主串**。某个字符在串中的序号称为该字符在串中的**位置**。子串在主串中的位置以子串的低一个字符在主串中的位置来表示。当两个串的长度相等且每个对应位置的字符都相等时，称这两个串是相等的。



### 2. 基本操作

- `StrAssign(&T, chars)`：赋值操作。把串`T`赋值为`chars`
- `StrCopy(&T, S)`：复制操作。由串`S`复制得到串`T`
- `StrEmpty(S)`：判空操作。若`S`为空串，则返回`true`，否则返回`false`
- `StrCompare(S, T)`：比较操作。若`S>T`，则返回值`>0`；若`S=T`，则返回值`=0`；若`S<T`，则返回值`<0`
- `StrLength(S)`：求串长。返回串`S`的元素个数
- `SubString(&Sub, S, pos, leng)`：求子串。用`Sub`返回串`S`的第`pos`个字符起长度为`len`的子串
- `Concat(&T, S1, S2)`：串联接。用`T`返回由`S1`和`S2`联接而成的新串
- `Index(S, T)`：定位操作。若主串`S`中存在与串`T`值相同的子串，则返回它在主串`S`中第一次出现的位置；否则函数值为 0
- `ClearString(&S)`：清空操作。将`S`清为空串。
- `DestroyString(&S)`：销毁串。将串`S`销毁



## 二、物理结构

### 1. 顺序结构

和其他结构一样，C 语言中的顺序结构有两种，一种是定长数组，一种是动态分配内存的数组。在表示串的时候，这两种结构都可以使用。

如果使用定长数组，那么我们需要一开始就定义好数组的长度。如果我们需要表示的字符串长度均匀，那么使用这种方法也是比较好的。这也是 C 语言默认表示字符串所使用的方法。

当然，如果我们需要表示的字符串长度不均匀，那么使用定长数组的方法则会造成比较严重的空间浪费或者数据溢出，此时最好就使用动态分配内存的数组，相较于定长数组的实现方法，动态分配内存的实现几乎没什么缺点，只是需要我们手动管理每一个字符串的空间，并且在需要重新分配内存时会有一些足以忽略的消耗罢了。

数据类型结构实现如下：

<Tabs>

<TabItem value="Const" label="定长顺序串">

```c
#define MAXSIZE 255
typedef struct
{
    char ch[MAXSIZE];
    int length;
} SString;
```

</TabItem>

<TabItem value="Variable" label="动态顺序串">

```c
typedef struct
{
    char *ch;
    int length;
} HString;
```

</TabItem>

</Tabs>

:::info 提醒

上述实现可以根据需要进行适当的修改，例如算法可能会涉及到 KMP 模式匹配算法，该算法需要生成并保存一个与字符串本身相关的`next`数组，所以我们可以向结构中添加一个与字符串同等长度的`next`数组项。

另外，在你的实现中，可能会希望不使用系统自带的字符类型，你当然也可以将`char`修改为你想要的类型。

:::



### 2. 链式结构

即使用链表的结构实现的字符串类型，显然，这种实现方法具有很强的限制性，例如无法做到随机访问等，所以一般不使用该方法实现字符串结构。

如果使用该方法实现串结构，则需要考虑每一个节点保存多少个字符，如果一个节点保存多个字符，当最后一个节点占不满时通常使用`#`补上。



## 三、算法分析

