`elem_type`即一个数据元素类型，并没有任何特定的实现，仅仅只是一个接口头文件。你可以根据这个接口头文件完成自己的实现，如果有一个源文件调用了`elem_type`提供的接口，你可以在这个源文件编译时链接到你的实现代码。

具体的接口如下面的代码所示：

```cpp title="elem_type.h"
#ifndef ELEM_TYPE_H_
#define ELEM_TYPE_H_

#include <stdbool.h>
#include <stdio.h>

struct elemtype;		// 定义在别处
typedef struct elemtype * elem_type;
typedef const struct elemtype * const_elem_type;

// 定义在别处
DLL_API elem_type CreateElem(void);										// 动态分配一个 elem_type 对象并返回指向该对象的指针，需定义默认初始化效果
DLL_API void DestroyElem(elem_type elem);								// 释放一个 elem_type 对象
DLL_API void CopyElem(elem_type elem, const_elem_type copied);			// 将 copied 指向的对象内容拷贝至 elem 指向的对象
DLL_API bool EqualElems(const_elem_type elem1, const_elem_type elem2);	// 判断两个元素是否相等
DLL_API void PrintElem(const_elem_type elem, FILE* out);				// 打印一个元素到输出流 out
DLL_API bool ReadElem(elem_type elem, FILE* in);						// 从输入流 in 获取一个元素并返回是否输入成功

#endif
```

如果要实现自己的`elem_type`，需要实现的内容有一个`struct elemtype`，以及后续所有函数接口。

在使用这个接口时，需要注意的是由于`struct elemtype`并没有定义，所以此类型占用的大小是不确定的，在使用时无法创建一个`struct elemtype`的对象。所以我们将`elem_type`定义为指向`struct elemtype`的指针，由于指针的大小是确定的，所以实际使用这套接口时，也需要创建`elem_type`的对象，而不是`struct elemtype`的对象。并且在这个指针之上的操作只能通过其函数接口进行，其余任何操作都是未定义的。

后续所有数据结构，都将使用此类型作为数据元素类型。