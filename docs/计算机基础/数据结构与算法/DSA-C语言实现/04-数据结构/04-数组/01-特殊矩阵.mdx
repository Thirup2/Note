## 一、抽象数据类型定义

### 1. 逻辑结构

**数组**是由 $n(n\geqslant 1)$ 个相同类型的数据元素构成的**有限序列**，每个数据元素称为一个**数组元素**，每个元素在 $n$ 个线性关系中的序号称为该元素的**下标**，下标的取值范围称为数组的**维界**，**矩阵**则是一个 2 维的数组。

当矩阵的两个维度的维界都相等时，这个矩阵就称作**方阵**，具体来说应该称为 n 阶方阵或 n 阶矩阵。本节主要讨论的内容都是关于方阵的内容，并且是一些特殊的方阵。

:::tip 数组与线性表的关系

数组是线性表的推广。一维数组可视为一个线性表；二维数组可视为其元素也是**定长**线性表的线性表，以此类推。

需要注意的是，数组和线性表的不同之处在于：数组一旦被定义，其维数和维界就不再改变。因此，除结构的初始化和销毁外，数组只会存取元素和修改元素的操作。

:::



### 2. 基本操作

- `InitMatrix(n)`：创建并初始化一个 n 阶矩阵
- `DestroyMatrix(&M)`：销毁矩阵`M`
- `CreateMatrix(&M)`：读取矩阵内容
- `PrintMatrix(&M)`：打印矩阵内容
- `GetElem(&M, i, j, &E)`：若位置无误，则获取矩阵`M`位于`i`行`j`列的元素到`E`
- `UpdateElem(&M, i, j, E)`：若位置无误，则修改矩阵`M`中`i`行`j`列的元素为`E`



## 二、物理结构

大多数计算机语言都提供了数组数据类型，本节中的数组的逻辑定义虽然和一些编程语言的数组类型有所区别，但基本上可直接采用数组类型进行存储，一个数组的所有元素在内存中占用一段连续的存储空间。

对于多维数组，有两种映射方法：按行优先和按列优先。在编程语言中的数组类型通常是按行优先的，即先行后列，先存储行号较小的元素，行号相等先存储列号较小的元素。

:::caution 注意

需要注意的是，不论是一维数组还是多维数组，它们在内存中的存储永远是线性的，而非逻辑定义上的矩阵。而按行优先和按列优先的排列方式决定了同一个矩阵中的元素存入内存的方式，按行优先是一行一行地将元素存入内存，而按列优先是一列一列地将元素存入内存。

如果使用下标访问元素，则访问同一个元素并不会产生下标的变化。而如果使用地址访问元素，则按行优先和按列优先的访问方式就会产生区别。

:::

### 1. 对称矩阵

**定义**：若对一个 $n$ 阶矩阵 $A$ 中的任意一个元素 $a_{i,j}$ 都有 $a_{i,j}=a_{j,i}\ (1\leqslant i, j\leqslant n)$ 则称其为对称矩阵。其中的元素可以划分为 3 个部分，即上三角区、主对角线和下三角区。

**分析**：对于 $n$ 阶对称矩阵，上三角区的所有元素和下三角区的对应元素相同，若仍然采用二维数组存放，则会浪费几乎一半的空间。实际上真正需要的空间只有一个三角区的空间加上主对角线的元素个数，一共是 $n(n+1)\over 2$

**压缩**：我们用一个一维数组 $B[n(n+1)/2]$ 来存放 $n$ 阶对称矩阵 $A$，然后将下三角区或上三角区加上对角线的元素存入该数组即可，通常选择存储下三角区。如果按照按行优先的方法来存储，此时 $a_{i,j}$ 与 $b_k$ 将有以下关系：$k={i(i-1)\over 2}+j-1$（数组下标从零开始）。而对于没有显式保存的上三角区的元素 $a_{i,j}$ 来说，$b_k$ 与其关系如下：$k={j(j-1)\over 2}+i-1$，即
$$
k=\begin{cases}{i(i-1)\over 2}+j-1,&i\geqslant j\ (下三角区和主对角线元素)\\
{j(j-1)\over 2}+i-1,&i<j\ (上三角区元素\ a_{ij}=a{ji})
\end{cases}
$$

**实现**：由于我们需要根据用户需要的阶数创建矩阵，所以使用动态分配的方式创建矩阵。另外，虽然使用动态分配，但是并不需要后续变更容量。

```c
typedef struct matrix
{
    ElemType *data;
    int order;		// 阶数
} SymMatrix, *PtrSMatrix;
```



### 2. 三角矩阵

**定义**：三角矩阵即某个三角区的所有元素均为同一常量。在上三角矩阵中，整个下三角区的元素为同一常量，而下三角矩阵则相反。

**分析**：与对称矩阵类似，另一个三角区虽然不是完全不用花费空间，但需要的空间仅仅为 1，所以全部需要的空间为 ${n(n+1)\over 2}+1$

**压缩**：和对称矩阵一样，我们用一个一维数组 $B[{n(n+1)\over 2}+1]$ 来存放 $n$ 阶三角矩阵 $A$，特别地，将其元素完全相同的那个三角区的值保存到一维数组最后一个元素位置。

对于下三角矩阵来说，此时 $b_k$ 和 $a_{i,j}$ 的下标对应关系如下：
$$
k=\begin{cases}
{i(i-1)\over 2}+j-1,&i\geqslant j\ (下三角区和主对角线元素)\\
{n(n+1)\over 2},&i<j\ (上三角区元素)
\end{cases}
$$
对于上三角矩阵来说，此时 $b_k$ 和 $a_{i,j}$ 的下标对应关系如下：
$$
k=\begin{cases}
{(i-1)(2n-i+2)\over 2}+(j-i),&i\leqslant j\ (上三角区和主对角线元素)\\
{n(n+1)\over 2},&i>j\ (下三角区元素)
\end{cases}
$$

**实现**：

```c
typedef struct matrix
{
    ElemType *data;
    bool up;		// 标志三角类型，为真时为上三角，反之则反
    int order;
} TriMatrix, *PtrTMatrix;
```



### 3. 三对角矩阵

**定义**：对于 $n$ 阶矩阵 $A$ 中的任意一个元素 $a_{i,j}$，当 $|i-j|>1$ 时，有 $a_{i,j}=0(1\leqslant i,\ j\leqslant n)$，则称为**三对角矩阵**，即所有非零元素都集中在以主对角线为中心的 3 条对角线的区域，其他区域的元素都为零。三对角矩阵是对角矩阵（也称为带状矩阵）的一个特例，一般来说直接研究对角矩阵能直接解决所有包括三对角矩阵在内的所有对角矩阵，但此处仍然选择只研究三对角矩阵。

**分析**：由于三对角矩阵的对角线之外的区域都为零，所以我们也就不用为其分配空间，而一个 $n$ 阶三条对角线需要的总空间为 $3n-2$

**压缩**：我们仍然用一个一维数组 $B[3n-2]$ 来保存这个 $n$ 阶三对角矩阵 $A$。仍然按照按行优先的原则存储元素，可以得到 $b_k$ 与 $a_{i,j}$ 的下标关系如下：
$$
k=2i+j-3,\ (1\leqslant i,\ j\leqslant n,\ |i-j|\leqslant 1)
$$
而如果访问的位置在矩阵中但不在三条对角线中，则代表该位置值为 0

**实现**：

```c
typedef struct matrix
{
    ElemType *data;
    int order;
} TriDiaMatrix, *PtrTDMatrix;
```



### 4. 稀疏矩阵

**定义**：矩阵中非零元素的个数 $t$，相对于矩阵元素的个数 $s$ 来说非常少，即 $s\gg t$ 的矩阵称为**稀疏矩阵**。简单来说，就是矩阵中含有大量的零，而非零元素寥寥无几并且随机排列。

**分析**：若采用常规方法存储稀疏矩阵，毫无疑问会相当浪费存储空间，因此仅存储非零元素。但通常非零元素的分布没有规律，所以仅存储非零元素的值是不够的，还要存储它所在的位置信息。

**压缩**：因此，此时每个数据元素应该由两个数据域构成，一个数据域包含两个数据项表示该元素在矩阵中的位置信息，另一个数据域则保存该位置上的非零元素。假设整个矩阵中非零元素一共 $n$ 个且都为`int`类型，然后位置信息也用两个`int`类型变量进行存储，那么此时总共需要的空间就是 $3n$。也就是说，在这种粗糙的定义下，当 $s>3t$ 时才能称得上是 $s\gg t$，否则就不能将其当作一个稀疏矩阵来进行存储。当然，由于这个定义非常粗糙，实际数据元素的尺寸和用来保存位置信息的元素类型的尺寸都会影响到这个最终需要的空间大小，所以，最终是否将矩阵当作稀疏矩阵进行存储需要考虑实际问题和实现方法。另外，稀疏矩阵在压缩存储后就失去了随机存取的特性，需要注意。

**实现**：由于稀疏矩阵会一个一个进行添加，并且本身没有随机存取的能力，所以可以采用单链表的方式也不会导致性能损失，反而更加灵活。另外，为了查找方便，可以每一行用一个单链表，然后将其头节点的地址保存在一个数组中，这样每一个结点中就还可以减少一个保存行信息的元素空间，每一行的节点也可以按顺序进行插入以方便查找。

```c
typedef struct node
{
    ElemType data;
    int col;
    struct node *next;
} Node, *PtrNode;
typedef struct matrix
{
    PtrNode *row;
    int length;
} SpaMatrix, *PtrSPMatrix;
```



## 三、算法分析

### 查找与更新

这两个操作都需要提供行和列的信息，在 C 语言中不会对下标进行检查，所以在你的实现中也可以继承这一特点。

如果需要检查行和列的信息，需要特别关注稀疏矩阵的链表实现。在检查下标时不仅要检查下标是否在范围内，还需要检查此下标的节点是否已经创建，以防重复创建某个位置对应的节点。