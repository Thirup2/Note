# 一. 字符串类型
## 1. 字符串常量
一串以NUL字节结尾的零个或多个字符, NUL字节是一个位模式全为0的NUL字节
> - **K&R C**: 在字符串常量的存储形式中, 所有的字符和NUL终止符都存储与内存的某个位置. K&R C并没有提及一个字符串常量中的字符是否可以被程序修改, 但它清楚地表明具有相同的值的不同字符串常量在内存中是分开存储的. 因此, 许多编译器都允许程序修改字符串常量.
> - **ANSI C**: 标准声明, 如果对一个字符串常量进行修改, 其效果是未定义的. 它也允许编译器把一个字符串常量存储与一个地方, 即使它在程序中多次出现. 这就使得修改字符串常量变得极为危险, 因为对一个常量进行修改可能殃及程序中其他字符串常量. 因此, 许多ANSI编译器不允许修改字符串常量, 或者提供编译时选项, 让你自行选择是否允许修改字符串常量. 在实践中, 请尽量避免这样做. 如果需要修改字符串, 请把它存储于数组中.

在程序中, 字符串常量会生成一个“指向字符的常量指针”, 因此, 可以把字符串常量赋值给一个"指向字符的指针", 但是不能把字符串常量赋值给一个字符数组

## 2. 字符串长度
字符串长度就是它所包含的字符个数, 不包括NUL字节

# 二. 字符串函数
## 1. 头文件
`<string.h>`

## 2. 返回字符串长度
```c
size_t strlen(char const *string);
```
- 返回类型`size_t`定义在头文件`stddef.h`中, 是一个无符号整型
- 注意无符号数相减的结果也会是一个无符号数, 不可能是负数, 所以`strlen(x) - strlen(y) >= 0`这类判断表达式将永远为真

## 3. 不受限制的字符串函数

### 1). 复制字符串
```c
char *strcpy(char *dst, char const *src);
```
- 操作: 把参数`src`字符串复制到`dst`参数, 如果参数`src`和`dst`在**内存**中出现**重叠**, 其结果是未定义的
- 参数: `dst`将进行修改, 因此它必须是个字符数组或者是一个指向动态分配内存的数组的指针, 不能使用字符串常量
- 返回值: 返回参数`dst`的副本, 即字符串`dst`的地址
- **警告**: 程序员必须保证目标字符数组的空间足以容纳需要复制的字符串. 如果字符串比数组长, 多余的字符仍被复制, 它们将覆盖原先存储于数组后面的内存空间的值. `strcpy`无法解决这个问题, 因为它无法判断目标字符数组的长度.

### 2). 连接字符串
```c
char *strcat(char *dst, char const *src);
```
- 操作: 把参数`src`字符串连接在`dst`参数后面, 要求`dst`参数原先已经包含了一个字符串(可以是空字符串). 它找到这个字符串的末尾, 并把`src`字符串的一份**副本**添加到这个位置. 如果`src`和`dst`在**内存**中出现**重叠**, 其结果是未定义的
- 参数: `dst`将进行修改, 因此它必须是个字符数组或者是一个指向动态分配内存的数组的指针, 不能使用字符串常量
- 返回值: 返回参数`dst`的副本, 即字符串`dst`的地址
- **警告**: 和前面一样, 程序员必须保证目标字符数组剩余的空间足以保存整个源字符串. 这次必须考虑目标数组中原先存在的字符串.

### 3). 字符串比较
- 字符串的大小: 比较两个字符串涉及对两个字符串对应的字符逐个进行比较, 直到发现不匹配为止. 那个最先不匹配的字符中较"小"(也就是说, 在字符集中的序数较小)的那个字符所在的字符串被认为"小于"另外一个字符串. 如果其中一个字符串是另外一个字符串的前面一部分, 那么它也被认为"小于"另外一个字符串, 因为他的NUL字节出现得更早. 这种比较被称为"词典比较", 对于**只包含大写字母或只包含小写字母**的字符串比较, 这种比较过程所给出的结果总是和我们日常所用的字母顺序的比较相同.
```c
int strcmp(char const *s1, char const *s2);
```
- 操作: 比较两个字符串
- 参数: 和前面的字符串相同, 两个参数都必须以NUL字节结尾
- 返回: 若`s1`小于`s2`, `strcmp`函数返回一个小于零的值; 如果`s1`大于`s2`, 函数返回一个大于零的值; 如果两个字符串相等, 函数就返回零.
- **注意**: 标准并未规定用于提示不相等的值, 其返回的大于零的值和小于零的值都是不确定的, 并不总是-1和1

## 4. 长度受限的字符串函数

### 1). 函数原型
```c
char *strncpy(char *dst, char const *src, size_t len);
char *strncat(char *dst, char const *src, size_t len);
int strncmp(char const *s1, char const *s2, size_t len);
```

### 2). 复制字符串
- 操作: 总是正好向`dst`写入`len`个字符
- **注意**: 
    1. 如果`strlen(src)`的值小于`len`, `dst`数组就用额外的NUL字节填充到`len`长度;
    2. 如果`strlrn(src)`的值大于或等于`len`, 那么只有`len`个字符被复制到`dst`中, **它的结果将不会以NUL字节结尾.**
    3. 综上, 若`len`的值大于`dst`的数组长度, 且`src`的长度也大于它, 则依然有可能造成修改到数组外的内存中的值的后果
- **警告**: `strncpy`调用的结果可能不是一个字符串.

### 3). 连接字符串
- 操作: 从`src`中最多复制`len`个字符到目标数组的后面.
- **注意**: 
    1. `strncat`总是在结果字符串后面添加一个NUL字节, 并且不会像`strncpy`那样对目标数组用NUL字节进行填充.
    2. 若参数`src`的长度小于`len`, 则只复制`strlen(src)`个字符到`dst`后面, 再加上一个NUL字节
    3. 若参数`src`的长度大于等于`len`, 则复制`len`个字符到`dst`后面, 再加上一个NUL字节
    4. `strncat`并不理会目标参数`dst`出去原先存在的字符串之后留下的空间够不够, 所以有可能造成数组`dst`后面的内容被修改, 请谨慎选择`len`的值

### 4). 比较字符串
- 操作: 最多比较`len`个字节
- **注意**:
    1. 若两个字符串在第`len`个字符之前存在不相等的字符, 这个函数就像`strcmp`一样停止比较, 并返回结果.
    2. 若两个字符串的前`len`个字符相等, 函数就返回0

## 5. 字符串查找基础

### 1). 查找一个字符
```c
char *strchr(char const *str, int ch);
char *strrchr(char const *str, int ch);
```
- 操作: `strchr`查找某个字符在字符串`str`中第一次出现的位置; `strrchr`查找某个字符在字符串`str`中最后一次出现的位置
- 返回值: 返回查找到的位置的指针. 如果该字符并不存在于字符串中, 函数就返回一个NULL指针

### 2). 查找任何几个字符
```c
char *strpbrk(char const *str, char const *group);
```
- 操作: 查找任何一组字符`group`中**任意一个字符**第一次在字符串`str`中出现的位置
- 返回值: 返回查找到的位置的指针. 如果该字符组并不存在于字符串中, 函数就返回一个NULL指针

### 3). 查找一个字串
```c
char *strstr(char const *s1, char const *s2);
```
- 操作: 在`s1`中查找整个`s2`第一次出现的起始位置
- 返回值: 返回指向查找到的位置的指针; 如果`s2`并没有完整地出现在`s1`地任何地方, 函数将返回一个NULL指针; 如果`s2`是一个空字符串, 函数就返回`s1`

## 6. 高级字符串查找

### 1). 查找一个字符串前缀
```c
size_t strspn(char const *str, char const *group);
size_t strcspn(char const *str, char const *group);
```
- 操作: `strspn`查找`str`起始部分与字符组`group`中任意字符匹配的字符个数, `strcspn`查找`str`起始部分与字符组`group`中每个字符都不匹配的字符个数. (起始部分: 在`strspn`中表示从第一个字符起, 直到与字符组中任意字符都不匹配的字符结束; 在`strcspn`中表示从第一个字符起, 直到与字符组中有任意匹配的字符结束. 二者都包括第一个字符本身)
- 返回值: 返回查找到的数目

### 2). 查找标记
```c
char *strtok(char *str, char const *sep);
```
- 参数: `sep`参数是个字符串, 定义了用作分隔符的字符合集. `str`指定一个字符串, 它包含零个或多个由`sep`字符串中一个或多个分隔符分隔的标记.
- 操作: 如果`strtok`函数的第1个参数不是NULL, 函数将找到字符串的第1个标记, 并保存它在字符串中的位置, 并将分隔符修改为NUL字节. 如果`strtok`函数的第一个参数是NULL, 函数就在之前查找的同一个字符串中从这个被保存的位置开始像前面一样查找下一个标记.
- 返回值: 如果查找到标记, 则返回指向标记地址的指针. 如果未找到标记, 则返回一个NULL指针
- **警告**: 
    1. 在执行任务时, `strtok`函数将会修改它所处理的字符串. 如果源字符串不能被修改, 那就复制一份, 将这份拷贝传递给strtok函数.
    2. 由于`strtok`函数保存它所处理的函数的局部状态信息, 因此不能用它同时解析两个字符串.

# 三. 字符操作
## 1. 头文件
`<ctype.h>`
## 2. 字符分类
### 1). 字符分类函数
|函数|如果它的参数符合下列条件就返回真|
|:-:|:-:|
|`iscntrl`|任何控制字符|
|`isspace`|空白字符: 空格`' '`, 换页`'\f'`, 换行`'\n'`, 回车`'\r'`, 制表符`'\t'`或垂直制表符`'\v'`|
|`isdigit`|十进制数组0~9|
|`isxdigit`|十六进制数, 包括所有十进制数字, 小写字母a~f, 大写字母A~F|
|`islower`|小写字母a~z|
|`isupper`|大写字母A~Z|
|`isalpha`|字母a~z或A~Z|
|`isalnum`|字母或数字(a~z, A~Z或0~9)|
|`ispunct`|标点符号, 任何不属于数字或字母的图形字符(可打印符号)|
|`isgraph`|任何图形字符|
|`isprintf`|任何可打印字符, 包括图形字符和空白字符|

### 2). 接受参数
一个包含字符值的整型参数

### 3). 返回值
返回0或非0

## 3. 字符转换
```c
int tolower(int ch);
int toupper(int ch);
```
- 操作: `toupper`函数返回其参数的对应大写形式, `tolower`函数返回其参数的对应小写形式. 如果函数的参数并不是一个处于适当大小写状态的字符, 函数将不会修改参数, 而是直接返回

# 四. 内存操作
## 1. 头文件
`<string.h>`

## 2. 函数原型
因为字符串函数处理字符串时, 遇到NUL字节就将停止工作, 所以无法使用字符串函数来处理非字符串数据, 所以有以下一组相关函数来处理任意的字节序列: 
```c
void *memcpy(void *dst, void const *src, size_t length);
void *memmove(void *des, void const *src, size_t length);
int memcmp(void const *a, void const *b, size_t length);
void *memchr(void const *a, int ch, size_t length);
void *memset(void *a, int ch, size_t length);
```
每个原型都包含一个显式的参数来说明需要处理的字节数. 但和strn带头的函数不同, 它们在遇到NUL字节时并不会停止操作.

## 3. 功能
### 1). `memcpy`
- 操作: 从`src`的起始位置复制`length`个字节到`dst`的内存起始位置. 可以用这种方法复制任何类型的值, 如果`src`和`dst`以任何形式出现了重叠, 它的结果是未定义的.
- 参数: 第三个参数一般使用`sizeof`运算符获取, 前两个参数并不需要使用强制类型转换, 因为任何类型的指针都可以转换为`void*`指针
- 返回值: `dst`的值

### 2). `memmove`
- 操作: 和`memcpy`类似, 从`src`的起始位置复制`length`个字节到`dst`的内存起始位置, 但实现方式是先将源操作数复制到一个临时位置, 这个临时位置不会与源操作数或目标操作数重叠, 然后再把它从这个临时位置复制到目标操作数, 如果`src`和`dst`存在重叠时, 就应该使用`memmove`

### 3). `memcmp`
- 操作: 对两段内存中的内容进行比较, 这两段内存分别起始于`a`和`b`, 共比较`length`个字节. 这些值按照无符号字符逐字节进行比较
- 返回值: 与`strcmp`一样
- **注意**: 由于这些值是根据一串无符号字节进行比较的, 因此如果`memcmp`函数用于比较不是单字节的数据(如整数或浮点数), 就可能给出不可预料的结果.

### 4). `memchr`
- 操作: 从`a`的起始位置开始查找字符`ch`第1次出现的位置, 并返回一个指向该位置的指针, 它共查找`length`个字节
- 返回值: 返回查找到的位置, 如果未查找到该字符, 函数返回一个NULL值

### 5). `memset`
- 操作: 把从`a`开始的`length`个字节都设置为字符值`ch`