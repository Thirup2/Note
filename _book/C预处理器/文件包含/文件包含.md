# 一. 函数库文件包含
- 语法：
```c
#include <filename>
```
- 对于`filename`，并不存在任何限制，不过根据约定，标准库文件以一个`.h`后缀结尾
- 编译器通过观察由编译器定义的“一系列标准位置”查找函数库头文件。
- 这种编译器有一个命令行选项，允许把其他目录添加到这个列表中，这样就可以创建自己的头文件函数库。

# 二. 本地文件包含
- 语法：
```c
#include "filename"
```
- 标准允许编译器自行决定是否把本地形式的`#include`和函数库形式的`#include`区别对待。
- 可以先对本地头文件使用一种特殊的处理方式，如果失败，编译器再按照函数库头文件的处理方式对它们进行处理。
- 处理本地头文件的一种常见策略是在源文件所在的当前目录进行查找，如果该头文件并未找到，编译器就像查找函数库头文件一样在标准位置查找本地头文件。

# 三. 绝对路径包含
UNIX系统和Borland C编译器所支持的一种变体形式是使用绝对路径名，它不仅指定文件的名字，还指定文件的位置。UNIX系统中的绝对路径名以一个斜杠开头，如下所示：
```
/home/fred/C/my_proj/declaration2.h
```
在MS-DOS系统中，它所使用的是反斜杠。
如果一个绝对路径名出现在任何一种形式的`#include`中，那么正常的目录查找就被跳过，因为这个路径名指定了头文件的位置

# 四. 嵌套文件包含
在一个文件中包含了某个头文件，然后在另一个文件中包含了这个文件，这就称作嵌套文件包含。
标准要求编译器必须支持至少8层的头文件嵌套，但它并没有限定嵌套深度的最大值。事实上，我们并没有很好的理由让`#include`指定的嵌套深度超过一层或两层。

- 对同一个头文件进行多次包含将导致一些错误，要解决这个问题，可以使用条件编译。如果所有的头文件都像下面这样编写：
    ```c
    #ifndef _HEADERNAME_H
    #define _HEADERNAME_H

    #endif
    ```
    那么多重包含的危险就被消除了。